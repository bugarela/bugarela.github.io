[{"title":"Homepage","content":"\n     \n       \n   \n     \n     \n     \n       \n           Gabriela Moreira \n       \n       \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n       \n       \n   Created using Emacs and  org-mode \n \n\n     \n   \n \n\n       \n         Homepage \n         \n Índice \n \n Apresentação \n Aulas \n Trabalho 1 \n \n \n \n Apresentação \n \n \n Aulas \n \n Testando um problema da maratona \n Programação e matemática não são a mesma coisa \n Estruturas de Kripke \n Checando propriedades com Lógica Temporal \n Checando propriedades com Lógica Temporal II \n Por que e pra que métodos formais? \n Introdução à Lógica Temporal das Ações \n Primeiras Especificações \n Revisão de programação funcional em Quint \n Jogo da Velha em Quint \n Introdução ao TLA+ \n Primeiras Especificações em TLA+ \n Exercícios Pokemon \n Especificar vs Implementar \n Efetivação em Duas Fases \n Design de protocolos \n Propriedades \n \n \n \n Trabalho 1 \n \n Trabalho 1 \n FAQ Trabalho 1 \n Dicas Trabalho 1 \n \n \n\n       \n     \n  ","url":"sitemap.html"},{"title":"Métodos Formais ","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Métodos Formais  \n                    \n  \n Links úteis \n \n Apresentação \n Cheatsheet Lógica Temporal (PDF) \n Exercícios para a prova \n \n \n Quint \n \n Getting Started: Quint \n Exemplos \n \n \n \n TLA+ \n \n Getting Started: TLA+ \n Exemplos \n \n \n \n \n Aulas \n \n \n \n Motivação \n \n Programação e matemática não são a mesma coisa \n \n \n \n Lógica \n \n Estruturas de Kripke \n Checando propriedades com Lógica Temporal \n Checando propriedades com Lógica Temporal II \n \n \n \n\n             \n         \n    ","url":"index.html"},{"title":"TLA+ Getting Started","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 TLA+ Getting Started \n                  \nEsse é um pequeno guia cobrindo desde a instalação até sua primeira verificação em TLA+. Baseado no  Getting Started do Quint .\n \n\n \nInstalar a extensão TLA+ Nightly no VSCode\nAbra o painel de extensões (Ctrl+Shift+X ou clicando no ícone)\nProcure por TLA+ Nightly e clique e instalar\n \n Se a extensão “TLA+” estiver instalada, desinstale-a, porque as duas não funcionam bem juntas. A versão Nightly tem mais features, e vamos precisar de uma delas logo. \n \nPS: Se aparecer pra você que essa versão está depreciada e recomendar a nova “TLA+ (Temporal Logic of Actions)”, pode instalar a nova. Na aula de segunda isso não apareceu pra mim, mas vi esse aviso no meu computador de casa agora. Eles acabaram de lançar essa versão, e ela parecer ter tudo o que vamos precisar pra disciplina, então tudo bem. Se instalarem essa, lembrem de desinstalar a TLA+/TLA+ Nightly.\n \n\n \nEscreva sua primeira especificação\nPara rodar as ferramentas do TLA+, precisamos primeiro de uma especificação em TLA+. Vamos usar a seguinte especificação de um banco, que tem um bug:\n \n \n --------------------------  MODULE  bank --------------------------\n EXTENDS  Integers\n\n \\* A state variable to store the balance of each account \n VARIABLE  balances\n\nADDRESSES == {  \"alice\" ,  \"bob\" ,  \"charlie\"  }\n\nDeposit(account, amount) ==\n   \\* Increment balance of account by amount \n  balances' = [balances  EXCEPT  ![account] = @ + amount]\n\nWithdraw(account, amount) ==\n   \\* Decrement balance of account by amount \n  balances' = [balances  EXCEPT  ![account] = @ - amount]\n\nInit ==\n   \\* At the initial state, all balances are zero \n  balances = [ addr \\in ADDRESSES |->  0  ]\n\nNext ==\n   \\* Non-deterministically pick an address and an amount \n  \\E account \\in ADDRESSES, amount \\in  1 .. 100  :\n     \\* Non-deterministically choose to either deposit or withdraw \n    \\/ Deposit(account, amount)\n    \\/ Withdraw(account, amount)\n\nNoNegatives == \\A addr \\in ADDRESSES : balances[addr] >=  0 \n=================================================================\n \n \n\n \nCrie um arquivo  bank.tla  com o conteúdo acima. O arquivo deve ter esse nome, porque em TLA+, o nome do modulo deve ser idêntico ao do arquivo. Vamos tentar checar a invariante  NoNegatives , que diz que nenhum dos saldos ( balances ) pode ser negativo. Uma invariante é algo que precisa ser verdadeiro em todos os estados alcançáveis.\n \n\n \nAdicionalmente, precisamos de um arquivo  bank.cfg  para configurar os parâmeros, com o conteúdo a seguir.\n \n \n INIT\nInit\n\nNEXT\nNext\n\nINVARIANT\nNoNegatives\n \n \n\n \nEncontrando uma violação\nPrimeiro, vamos usar o modo de simulação para encontrar uma violação. Esse modo vai tentar várias (mas não todas) execuções.\n \n\n Abra o arquivo  bank.tla  e use F1 ou Ctrl+Shift+P para abrir o menu de comandos do VSCode \n Selecione a opção “TLA+: Check model with TLC” \n No prompt que aparece, substitua o valor padrão  -coverage=1  por  -simulate num=10000  para rodar o TLC no modo de simulação com 10 mil amostras e aperte Enter. \n \nIsso deve resultar em uma violação, mostrando uma execução onde alguém fica com saldo negativo.\n \n\n \nConsertando o bug\nAtualize a definição  Withdraw  para previnir que esse cenário aconteça: usuários não deveriam poder sacar mais do que eles tem em saldo.\n \n\n \n Withdraw(account, amount) ==\n   \\* A precondition, there should be enough to withdraw \n  /\\ balances[account] >= amount\n   \\* Decrement balance of account by amount \n  /\\ balances' = [balances  EXCEPT  ![account] = @ - amount]\n \n \n\n \nAgora, podemos rodar o simulador novamente (repetir passo 3) e nenhuma violação deve ser encontrada.\n \n\n \nVerificando o resultado\n \n\n \nContudo, o simulador pode não ter considerado algumas execuções. Para ter certeza que o problema foi consertado, devemos rodar o  model checker . O TLC não é um model checker limitado, e como essa especificação lida com inteiros arbitrários, ele vai ficar rodando até ficar sem memória. Então, precisamos antes restringir nosso espaço de busca. Vamos modificar nosso  Next  para que a execução só consiga progredir enquanto os saldos forem menor do que  50  (você pode diminuir esse número se o TLC ainda estiver demorando muito):\n \n \n Next ==\n   \\* Only continue if balance is small enough to avoid a big state space \n  /\\ \\A addr \\in ADDRESSES : balances[addr] <=  50 \n   \\* Non-deterministically pick an address and an amount \n  /\\ \\E account \\in ADDRESSES, amount \\in  1 .. 100  :\n       \\* Non-deterministically choose to either deposit or withdraw \n      \\/ Deposit(account, amount)\n      \\/ Withdraw(account, amount)\n \n \n\n \nAgora podemos rodar:\n \n Abra o arquivo  bank.tla  e use F1 ou Ctrl+Shift+P para abrir o menu de comandos do VSCode \n Selecione a opção “TLA+: Check model with TLC” \n No prompt que aparece, substitua o valor por  -deadlock  e aperte Enter. Como introduzimos um deadlock na nossa especificação (ela não progride quando o saldo fica maior que 50), precisamos pedir pro TLC ignorar deadlocks, e por isso passamos a flag  -deadlock . \n \nEsse comando irá verificar todas as possíveis execuções, e deve retornar sucesso, o que significa que de fato consertamos o problema e não temos mais saldos negativos.\n \n \n         \n    ","url":"20240828153443-tla_getting_started.html"},{"title":"Exercícios para a prova","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Exercícios para a prova \n                  Table of Contents \n \n Estruturas de Kripke \n Questão 1 \n Questão 2 \n \n Lógica temporal \n Questão 3 \n Questão 4 \n \n Propriedades e Suposições \n Questão 5 \n Questão 6 \n Questão 7 \n \n Perguntas gerais \n Questão 8 \n \n TLA+ e Quint \n Questão 9 \n Especificação A \n Especificação B \n \n Questão 10 \n Questão 11 \n Questão 12 \n \n \n \n Estruturas de Kripke \n \n \n \n Questão 1 \n \n \nIdentifique em quais estruturas de Kripke a seguir tem não-determinismo e  justifique sua resposta .\n \n \nSemáforos. Considere o conjunto de estados inicial \\(I = \\{vermelho\\}\\)\n \n\n  [Resposta] \nDeterminístico (não há não-determinismo), porque existe somente um estado inicial e, para cada um dos três estados, há apenas uma possível transição.\n \n \n\n \nChaleira. Considere o conjunto de estados inicial \\(I = \\{temperatura\\_ambiente\\}\\)\n \n\n  [Resposta] \nNão-determinístico (há não-determinismo), porque, para os estados “esquentando” e “esfriando”, há mais de uma transição possível.\n \n \n \n \n \n Questão 2 \n \n \nDefina uma estrutura de Kripke para um sistema de caixa da água com as seguintes características:\n \n A caixa da água contém uma bóia que impede que ela transborde, ou seja, a bóia interrompe o enchimento quando a caixa está completamente cheia. \n A caixa não enche enquanto está sendo usada, ou seja, ela não pode estar enchendo e esvaziando ao mesmo tempo. \n Se a caixa está vazia, ela não pode ser esvaziada. \n O sistema inicia com a caixa vazia \n \nPS: Tente usar o mínimo de estados e transições necessários para representar esse sistema.\n \n [Resposta] \\(S = \\{vazia, enchendo, cheia, esvaziando\\}\\) \n \\(\\rightarrow = \\{vazia \\rightarrow enchendo, enchendo \\rightarrow esvaziando, enchendo \\rightarrow cheia, cheia \\rightarrow esvaziando, esvaziando \\rightarrow enchendo, esvaziando \\rightarrow vazia\\}\\) \n \\(I = \\{vazia\\}\\) \n \n \n \n \n Lógica temporal \n \n \n \n Questão 3 \n \n \nDada uma fórmula temporal e uma execução, indique se a fórmula é verdadeira ou falsa para a execução. Ou seja, responda verdadeiro se a execução satisfaz a fórmula e falso caso não satisfaça. Considere que \\(a\\) e \\(b\\) são proposições.\n \n\n Fórmula: \\(X(b)\\)\n [ ]  \\([b], [b], [a]\\) \n [ ]  \\([a], [b], [a]\\) \n [ ]  \\([a], [a], [b]\\) \n \n Fórmula: \\(a -> b\\)\n [ ]  \\([a], [a], [a]\\) \n [ ]  \\([a], [b], [a]\\) \n [ ]  \\([a, b], [a], [a]\\) \n [ ]  \\([b], [a], [a]\\) \n \n Fórmula: \\(F(a)\\)\n [ ]  \\([a], [a], [a]\\) \n [ ]  \\([b], [a], [b]\\) \n \n [Resposta] Fórmula: \\(X(b)\\)\n [V] \\([b], [b], [a]\\) \n [V] \\([a], [b], [a]\\) \n [F] \\([a], [a], [b]\\) \n \n Fórmula: \\(a -> b\\)\n [F] \\([a], [a], [a]\\) \n [F] \\([a], [b], [a]\\) \n [V] \\([a, b], [a], [a]\\) \n [V] \\([b], [a], [a]\\) \n \n Fórmula: \\(F(a)\\)\n [V] \\([a], [a], [a]\\) \n [V] \\([b], [a], [b]\\) \n \n \n \n \n Questão 4 \n \n \nExplique a diferença entre LTL (Lógica Temporal Linear) e CTL (Lógica de árvore computacional -  Computational Tree Logic ).\n \n [Resposta] \nA representação de árvore da CTL permite que usemos quantificações existenciais com nossas fórmulas temporais: existe alguma execução onde eventualmente X. Já na LTL, todas as fórmulas são implicitamente universalmente quantificadas, e isso não é possível. Essa diferença faz com que existam fórmulas na LTL que não podem ser espressadas em CTL e fórmulas na CTL que não podem ser espressadas na LTL.\n \n \n \n \n \n Propriedades e Suposições \n \n \n \n Questão 5 \n \n \nAssinale as fórmulas abaixo com [V] (verdadeiro) se a propriedade pode ser espressa com uma invariante ou [F] (falso) caso seja preciso uma fórmua temporal. Lembre-se que não importa se a fórmula é verdadeira ou falsa.\n \n [ ]  Para cada compra no cartão de crédito, vem uma cobrança na fatura ao final do mês. \n [ ]  Nunca vou para a academia sem meus fones de ouvido \n [ ]  Em algum momento vou terminar de pagar as parcelas do meu apartamento \n [ ]  Sempre uso óculos para dirigir \n [ ]  Não é possível estar na aula e no shopping ao mesmo tempo \n [ ]  Todos os códigos em C++ serão migrados para Rust \n [Resposta] [F] Para cada compra no cartão de crédito, vem uma cobrança na fatura ao final do mês. \n [V] Nunca vou para a academia sem meus fones de ouvido \n [F] Em algum momento vou terminar de pagar as parcelas do meu apartamento \n [V] Sempre uso óculos para dirigir \n [V] Não é possível estar na aula e no shopping ao mesmo tempo \n [F] Todos os códigos em C++ serão migrados para Rust \n \n \n \n Questão 6 \n \n \nLeia a contextualização e responda:\n \n \n \nEstou vendendo peças de computador e contrato uma transportadora para fazer as entregas. Essas peças são frágeis, e podem quebrar se não forem transportadas de maneira adequada. A caixa não pode ser virada (a mesma face deve permanecer para cima durante todo o transporte), e não pode se mover no baú do caminhão. Para ter certeza de que a transportadora está fazendo seu serviço corretamente, instalei câmeras internas nos baús dos caminhões que me enviam fotos a cada 5 minutos. Agora, só preciso analisar essas fotos e determinar se a transportadora cumpre os requisitos.\n \n \n\n \nConsiderando uma execução dada pela sequência de fotos enviadas, escreva propriedades de segurança e vivacidade que digam sobre a qualidade do serviço da transportadora. Informe o tipo (invariante/temporal e segurança/vivacidade) de cada propriedade. Liste também que tipo de suposições estão sendo feitas para viabilizar essa análise.\n \n\n [Resposta] \nPropriedades:\n \n Invariante de segurança: a face de cima da caixa está para cima \n Temporal de segurança: sempre (a posição da caixa no próximo estado é a mesma que no estado atual ou ela é retirada pra entrega) \n Temporal de vivacidade: eventualmente a caixa é retirada para entrega \n \nSuposições:\n \n é possível determinar a posição da caixa em cada foto \n é possível determinar se a face correta da caixa está pra cima \n se a caixa for retirada, é por conta de uma entrega \n \n \n \n Questão 7 \n \n \nAlice e Bob estavam combinando de se encontrar e Alice mandou a seguinte mensagem para Bob: “Encontre-me as 15h na cafeteria Café Quentinho”. Ao fazer essa comunicação, Alice estava supondo algumas coisas. Descreva qual suposição de Alice estava errada para cada um dos cenários a seguir.\n \n \nBob não apareceu. A bateria do celular dele acabou antes que visse a mensagem de Alice.\nResponda: Alice assumiu que …\n \n [Resposta] \nAlice assumiu que Bob havia recebido a mensagem dela.\n \n \n \nBob foi em outro Café Quentinho - acontece que havia outra cafeteria com esse nome em outro bairro.\nResponda: Alice assumiu que …\n \n [Resposta] \nAlice assumiu que havia apenas uma “Café Quentinho” na cidade\n \n \n \nQuando Alice chegou, o Bob já estava lá por uma hora. Ele havia esquecido de ajustar seu relógio no fim do horário de verão.\nResponda: Alice assumiu que …\n \n [Resposta] \nAlice assumiu que o relógio de Bob estava no mesmo horário que o dela.\n \n \n \n \n \n \n Perguntas gerais \n \n \n \n Questão 8 \n \n \nSuponha que temos um modelo e uma propriedade que é violada numa execução de 5 passos. Considere que estamos usando um simulador aleatório com até 10.000 amostras e 10 passos, e um  model checker  com até 10 passos. Assinale com verdadeiro ou falso  e justifque sua resposta .\n \n [ ]  O simulador irá encontar um contraexemplo para propriedades \n [ ]  O  model checker  encontrará um contraexemplo de 5 passos \n [ ]  O  model checker  demorará mais tempo que o simulador para responder \n [ ]  O simulador demorará mais tempo que o  model checker  para responder \n [ ]  O  model checker  poderá finalizar a execução sem encontrar o contraexemplo \n [ ]  O simulador pode encontrar um contraexemplo de 9 passos \n [Resposta] [F] O simulador irá encontar um contraexemplo para propriedades \n [V] O  model checker  encontrará um contraexemplo de 5 passos \n [F] O  model checker  demorará mais tempo que o simulador para responder \n [F] O simulador demorará mais tempo que o  model checker  para responder \n [F] O  model checker  poderá finalizar a execução sem encontrar o contraexemplo \n [V] O simulador pode encontrar um contraexemplo de 9 passos \n \n \n \n \n TLA+ e Quint \n \n \n \n Questão 9 \n \n \nDada uma especificação simples, escreva uma breve descrição do que ela faz. Observe o seguinte exemplo:\nQuint:\n \n \n var  x:  int \n\n action  init = x' = 0\n\n action  step = x' =  if  (x < 10) x + 1  else  x\n \n \n\n \nTLA+:\n \n \n VARIABLE  x\n\nInit == x =  0 \n\nNext == x' =  IF  (x <  10 )  THEN  x +  1   ELSE  x\n \n \n\n \nPoderíamos descrever como: Um modelo onde x começa em zero e é incrementado até chegar a 10, com incrementos de tamanho 1. Ao chegar a 10, x permanece com o mesmo valor pra sempre\n \n\n \nAgora, responda com uma descrição para cada especificação abaixo:\n \n \n \n Especificação A \n \n \nQuint:\n \n \n var  x:  int \n\n action  init = x' = 0\n\n action  step =  any  {\n   all  {\n    x < 5,\n    x' = x + 1\n  },\n   all  {\n    x > -5,\n    x' = x - 1\n  }\n}\n \n \n\n \nTLA+\n \n \n VARIABLE  x\n\nInit == x =  0 \n\nNext ==\n  \\/ /\\ x <  5 \n     /\\ x' = x +  1 \n  \\/ /\\ x > -5\n     /\\ x' = x -  1 \n\n \n \n\n [Resposta] \nUm modelo onde x começa em zero e pode ser incrementado em 1 caso seja menor que 5, ou decrementado em 1 caso seja maior que -5. Ou seja, a cada passo x terá seu valor modificado (mais um ou menos um) e permanecerá sempre entre -5 e 5.\n \n \n \n \n Especificação B \n \n \nQuint:\n \n \n var  x:  int \n\n action  init = x' = 1\n\n action  step = {\n   nondet  v = 1.to(10).oneOf()\n   all  {\n    x != v,\n    x' = v\n  }\n}\n \n \n\n \nTLA+:\n \n \n VARIABLE  x\n\nInit == x =  1 \n\nNext == \\E v \\in  1 .. 10 :\n  /\\ x /= v\n  /\\ x' = v\n \n \n\n [Resposta] \nUm modelo onde x começa em 1 e a cada passo recebe um novo valor, diferente do atual, entre 1 e 10.\n \n \n \n \n \n Questão 10 \n \n \nConsidere o modelo a seguir:\n \n\n \nQuint:\n \n \n var  x:  int \n\n action  init = x' = 10\n\n action  step =  any  {\n   all  {\n    x < 20,\n    x % 2 == 0,\n    x' = x + 3\n  },\n   all  {\n    x > 5,\n    x' = x - 1\n  }\n}\n \n \n\n \nTLA+:\n \n \n VARIABLE  x\n\nInit == x =  10 \n\nNext ==\n  \\/ /\\ x <  20 \n     /\\ x %  2  =  0 \n     /\\ x' = x +  3 \n  \\/ /\\ x >  5 \n     /\\ x' = x -  1 \n \n \n\n \nPara cada execução a seguir, assinale verdadeiro se o modelo permite a execução e falso caso contrário. Quando responder falso,  justifique sua resposta .\n \n [ ]   x: 7, x: 6, x: 9, x: 8 \n [ ]   x: 10, x: 13, x: 12, x: 11, x: 10 \n [ ]   x: 10, x: 9, x: 8, x: 11 \n [ ]   x: 10, x: 9, x: 12, x: 15 \n [Resposta] [F]  x: 7, x: 6, x: 9, x: 8 \n x não pode ser 7 no estado inicial. Deve ser 10. \n \n [V]  x: 10, x: 13, x: 12, x: 11, x: 10 \n [V]  x: 10, x: 9, x: 8, x: 11 \n [F]  x: 10, x: 9, x: 12, x: 15 \n não podemos somar 3 ao 9 para chegar em 12, porque uma das pré-condições para somar 3 é que x seja divisível por 2, e 9 não é. \n \n \n \n \n Questão 11 \n \n \nO operador primed ( ' ) permite que escrevamos predicados sobre o próximo estado. Assinale verdadeiro se o operador primed está sendo usado corretamente, ou falso se o uso resultará em um erro. Caso responder falso,  justifique sua resposta . Considere que x e y são variáveis. As respostas para Quint ou TLA+ são as mesmas, responda apenas uma delas.\n \n\n \nQuint:\n \n [ ]   all { x' = 1, x' = 2 } \n [ ]   any { x' = 1, x' = 2 } \n [ ]   all { x' = 1, y' = 2 } \n [ ]   any { x' = 1, y' = 2 } \n \nTLA+:\n \n [ ]   x' = 1 /\\ x' = 2 \n [ ]   x' = 1 \\/ x' = 2 \n [ ]   x' = 1 /\\ y' = 2 \n [ ]   x' = 1 \\/ y' = 2 \n [Resposta] \nQuint:\n \n [F]  all { x' = 1, x' = 2 } \n x é atualizado duas vezes na mesma ação \n \n [V]  any { x' = 1, x' = 2 } \n [V]  all { x' = 1, y' = 2 } \n [F]  any { x' = 1, y' = 2 } \n atualização desbalanceada: em uma das ramificações apenas x é atualizado, e em outra apenas y \n \n \nTLA+:\n \n [F]  x' = 1 /\\ x' = 2 \n x é atualizado duas vezes na mesma ação \n \n [V]  x' = 1 \\/ x' = 2 \n [V]  x' = 1 /\\ y' = 2 \n [F]  x' = 1 \\/ y' = 2 \n atualização desbalanceada: em uma das ramificações apenas x é atualizado, e em outra apenas y \n \n \n \n \n Questão 12 \n \n \nAgora escreva a propriedade em Quint ou em TLA+ para:\n \n\n “Não é possível estar na aula e no shopping ao mesmo tempo”. Considere que existam duas variáveis de estado do tipo  bool :  na_aula  e  no_shopping . \n “Sempre uso óculos para dirigir”. Considere que existam duas variáveis de estado do tipo  bool :  estou_dirigindo  e  estou_de_oculos . \n “Em algum momento vou terminar de pagar as parcelas do meu apartamento”. Considere que exista uma variável de estado do tipo  int  para o número restante de parcelas:  parcelas_restantes . \n “Todos os códigos em C++ serão migrados para Rust”. Considere que exista uma variável  codigos  do tipo  int -> { codigo: str, linguagem: str }  sendo a chave (domínio) um identificador único daquele código e o campo  linguagem  pode conter  \"c++\" ,  \"haskell\"  ou  \"rust\" . \n [Resposta] not(na_aula) or not(no_shopping) \n estou_dirigindo implies estou_de_oculos \n eventually(parcelas_restantes == 0) \n codigos.keys().forall(k => codigos.get(k).linguagem ==  \"c++\"   implies  eventually(codigos.get(k).linguagem ==  \"rust\" )) \n \n \n \n\n             \n         \n    ","url":"20240525134648-mfo_exercicios_para_a_prova.html"},{"title":"Checando propriedades com Lógica Temporal II","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Checando propriedades com Lógica Temporal II \n                  Slides \n \n Table of Contents \n \n 1. Revisão & Cheatsheet \n 1.1. \\(\\square\\) ou  G :  Globally , sempre \n 1.2. \\(\\Diamond\\) ou  F : Finally, eventualmente, no Futuro \n 1.3. \\(\\bigcirc\\) ou  X :  Ne( x )t , próximo \n 1.4.  U :  Until , até \n 1.5.  R :  Release , libera \n \n 2. Exemplos \n 2.1. Ônibus \n 2.2. Ar condicionado da sala de aula \n \n 3. Exercício prático \n 3.1. Exercício prático \n 3.2. Tarefa de casa \n 3.3. FIM \n \n \n \n \n 1.  Revisão & Cheatsheet \n \n \n \n 1.1.  \\(\\square\\) ou  G :  Globally , sempre \n \n \n G  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro por toda a execução a partir de agora.  \n\n \n G  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro em  todos  os momentos \\(t' \\geq t\\).  \n\n \nExemplo: Comida sacia a fome.  \n\n\n \n   \n \n \n \n \n 1.2.  \\(\\Diamond\\) ou  F : Finally, eventualmente, no Futuro \n \n \n F  \\(\\phi\\): eventualmente (na execução a partir de agora), \\(\\phi\\) deve ser verdadeiro.  \n\n \n F  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro em  algum  o momento \\(t' \\geq t\\).  \n\n \nExemplo: Eventualmente, terei fome.  \n\n\n \n   \n \n \n \n \n 1.3.  \\(\\bigcirc\\) ou  X :  Ne( x )t , próximo \n \n \n X  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro no próximo estado.  \n\n \n X  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro no momento \\(t + 1\\).  \n\n \nExemplo: Logo após comer, tenho sede.  \n\n\n \n   \n \n \n \n \n 1.4.   U :  Until , até \n \n \n\\(\\psi\\)  U  \\(\\phi\\): \\(\\psi\\) deve ser verdade até que \\(\\phi\\) seja verdade, sendo que \\(\\phi\\) deve ser verdade no presente ou no futuro.  \n\n \n\\(\\psi\\)  U  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro em algum momento \\(t' \\geq t\\) e, para todo tempo \\(t''\\) (tal que \\(t \\leq t'' < t'\\)), \\(\\psi\\) é verdadeiro.  \n\n \nExemplo: Eu tenho fome até eu comer alguma coisa.  \n\n\n \n   \n \n \n \n \n 1.5.   R :  Release , libera \n \n \n\\(\\psi\\)  R  \\(\\phi\\): \\(\\phi\\) deve ser verdade até e incluindo o momento que \\(\\psi\\) se torna verdadeiro. Se \\(\\psi\\) nunca ficar verdadeiro, \\(\\phi\\) deve permanecer verdadeiro para sempre.  \n\n \n\\(\\psi\\)  R  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro em todos os momentos \\(t' \\geq t\\) até e incluindo o momento \\(t''\\) onde \\(\\psi\\) também é verdadeiro. Alternativamente, pode ser que \\(\\psi\\) nunca seja verdadeiro, e nesse caso \\(\\phi\\) deve ser verdadeiro para todo momento \\(t' \\geq t\\).  \n\n \nExemplo: Ao comer chocolate, deixo de ter vontade de comer doce.  \n\n\n \n   \n \n \n \n \n \n 2.  Exemplos \n \n \n \n 2.1.  Ônibus \n \n \nNormalmente, Joãozinho pega ônibus pra udesc e de volta pra casa. Às vezes, Joãozinho erra o ônibus e vai parar em Pirabeiraba.  \n\n \n   \n \n\n F casa : true  \n \n \n \n 2.2.  Ar condicionado da sala de aula \n \n\n \n   \n \n\n aula_acontecendo -> sem_aula V ar_ligado : true  \n aula_acontecendo -> ar_ligado U sem_aula : false, porque podemos ficar em aula pra sempre :)  \n \n \n \n \n 3.  Exercício prático \n \n \n \n 3.1.  Exercício prático \n \n \nVamos escrever um avaliador de operadores para operadores temporais  \n Isso não é um  model checker , porque não vamos considerar todas as possíveis execuções de um sistema  \n Dado uma única execução e uma fórmula temporal, a fórmula é verdadeira para essa execução?  \n \n \n \n 3.2.  Tarefa de casa \n \n \nLer página 10 de  https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf  \n \n \n \n 3.3.  FIM \n \n \n \n \n\n             \n         \n    ","url":"20240306214020-mfo_logica_temporal_2.html"},{"title":"Checando propriedades com Lógica Temporal","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Checando propriedades com Lógica Temporal \n                  Slides \n \n Table of Contents \n \n 1.  Model checking \n 1.1. Contexto \n 1.2. Interface de um  model checker \n 1.3. Vantagens e Desvantagens \n 1.4.    Modelos \n 1.5.    Propriedades -    Lógica temporal \n 1.6.    Propriedades -    Invariantes \n 1.7.    Contra-exemplo \n 1.8.    Exercício: Qual dessas fórmulas pode ser um invariante? \n \n 2. Lógica Temporal \n 2.1. Operadores Temporais - Unários \n 2.2. Operadores Temporais - Binários \n 2.3. LTL e CTL \n 2.4. LTL e CTL - Visualização \n \n 3. LTL \n 3.1. LTL -  Linear Temporal Logic \n 3.2. Equivalências \n 3.3. Negações de fórmulas \n 3.4. Exercícios \n 3.5. LTL em Estruturas de Kripke \n \n 4. CTL \n 4.1. CTL -  Computational Tree Logic \n 4.2. Visualização \n \n 5. Verificando propriedades \n 5.1. LTL vs CTL \n 5.2. Exemplo chaleiras - modelo \n 5.3. Exemplo chaleiras \n 5.4. Exemplo Adultos e Crianças - modelo \n 5.5. Exemplo Adultos e Crianças \n 5.6.  Workaround  para falta do existencial com invariantes \n 5.7. Referências \n \n \n \n \n 1.   Model checking \n \n \n \n 1.1.  Contexto \n \n Problema : É difícil pensar em todos os cenários, principalmente em sistemas concorrentes/distribuídos  \n Solução : Diferentes níveis de verificação     Fuzzing  e simulação  \n    Model checking  \n   Provas (com assistente de provas)  \n \n \n \n \n 1.2.  Interface de um  model checker \n \n \nComo um  model checker  é usado?  \n \n  Duas entradas:  \n   Um modelo - uma máquina de estado finita*  \n   Uma propriedade - uma fórmula de alguma lógica temporal  \n \n \n  Três possíveis saídas  \n   Sucesso  \n   Contra-exemplo: Uma sequência de estados que viola a propriedade  \n   Não há memória suficiente  \n \nOpcionalmente, também pode detectar  deadlocks .  \n Deadlock : o modelo não obedece a restrição de uma estrutura de Kripke, ou seja, existe um estado sem transição alguma saindo dele.  \n \n \n \n \n 1.3.  Vantagens e Desvantagens \n \n \n Vantagens  \n   Contra-exemplos  \n   Verificação parcial  \n   Processo automatizado  \n   Sequências infinitas de estados  \n \n Desvantagens  \n   Explosão de estados  \n   Não permite generalização (i.e. \\(N\\) processos)  \n    Model checkers  em si não são verificados  \n \nNo geral, é um método bom para encontrar falhas em software, que permite a verificação com certas restrições.  \n\n \nComparado a testes e simulações aleatórias, pode ser mais eficiente em encontrar casos de borda onde falhas ocorrem.  \n \n \n \n 1.4.     Modelos \n \n \nLinguagens de especificação fornecem diferentes abstrações para como definir uma máquina de estados. Exemplos: Redes de Petri, TLA+ ( Temporal Logic of Actions+ ), CSP ( Communicating Sequential Processes ), Alloy, entre outras.  \n \n \n \n 1.5.     Propriedades -    Lógica temporal \n \n \nDois operadores temporais principais:  \n Eventualmente (\\(\\Diamond\\)) ou Finalmente (\\(F\\)): Cada semáforo deve eventualmente ficar verde  \n Sempre (\\(\\square\\)) ou (\\(A\\)): O número do próximo estado é sempre maior que o número no estado anterior  \n \nFórmulas de lógica temporal são sobre um comportamento (execução) do sistema modelado.  \n \n \n \n 1.6.     Propriedades -    Invariantes \n \n \nInvariantes são predicados sobre estados individuais do sistema. Um invariante é satisfeito se e somente se ele é verdadeiro para todos os estados do sistema.  \n\n \n Invariantes Indutivos  são tipos especiais de invariantes que podem ser provados com indução matemática, isso é, sem necessidade de explorar todos os estados.  \n Muito poderosos mas também difíceis de se definir  \n \n \n \n 1.7.     Contra-exemplo \n \n \n Entradas:  \n   Modelo: 2 semáforos sem controle de revezamento  \n   Propriedade: para cada semáforo, ele deve eventualmente ficar verde  \n \nExecução do  model checker  \n \n Saída -    Contra-exemplo:  \n Semáforo 1 inicia vermelho, semáforo 2 inicia vermelho  \n Semáforo 1 fica verde (e semáforo 2 permanece vermelho)  \n Semáforo 1 fica amarelo (e semáforo 2 permanece vermelho)  \n Retorna ao estado (1)  \n \nÓtimo artefato para reprodução de bugs e geração de testes automatizados.  \n \n \n \n 1.8.     Exercício: Qual dessas fórmulas pode ser um invariante? \n \n Ao fazer uma transferência bancária, eu acabo com menos dinheiro do que tinha antes  \n Ao ligar uma chaleira elétrica, ela eventualmente chegará a 100 graus  \n Em um jogo da velha, a diferença entre o número de X e O não é maior do que 1  \n \n\\faLightbulb Dica: Um invariante é uma fórmula a ser avaliada em cada estado do sistema.  \n\n \nResposta: 3  \n \n \n \n \n 2.  Lógica Temporal \n \n \n \n 2.1.  Operadores Temporais - Unários \n \n \\(\\square\\) ou  G :  Globally , sempre.  G  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro por toda a execução a partir de agora.  \n Exemplo: Comida sacia a fome  \n \n \\(\\Diamond\\) ou  F : Finally, eventualmente, no Futuro.  F  \\(\\phi\\): eventualmente (na execução a partir de agora), \\(\\phi\\) deve ser verdadeiro.  \n Exemplo: Eventualmente, terei fome  \n \n \\(\\bigcirc\\) ou  X :  Ne( x )t , próximo.  X  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro no próximo estado.  \n Exemplo: Logo após comer, tenho sede  \n \n \n \n \n 2.2.  Operadores Temporais - Binários \n \n U :  Until , até.  \\(\\psi\\)  U  \\(\\phi\\): \\(\\psi\\) deve ser verdade até que \\(\\phi\\) seja verdade, sendo que \\(\\phi\\) deve ser verdade no presente ou no futuro.  \n Exemplo: Eu tenho fome até eu comer alguma coisa  \n \n R :  Release , libera.  \\(\\psi\\)  R  \\(\\phi\\): \\(\\phi\\) deve ser verdade até e incluindo o momento que \\(\\psi\\) se torna verdadeiro. Se \\(\\psi\\) nunca ficar verdadeiro, \\(\\phi\\) deve permanecer verdadeiro para sempre.  \n Exemplo: Ao comer chocolate, deixo de ter vontade de comer doce. Detalhe: Eu posso continuar com vontade de comer e acabar nunca comendo chocolate.  \n \n \n \n \n 2.3.  LTL e CTL \n \n LTL  -  Linear Temporal Logic  (Lógica Temporal Linear). Em LTL, as fórmulas são implicitamente universalmente quantificadas. Propriedades que falam sobre a existência de uma execução não podem ser expressadas.  \n CTL  -  Computational Tree Logic  (Lógica de Árvore Computacional). CTL é uma lógica sobre a ramificação do tempo.  \n \n \n \n 2.4.  LTL e CTL - Visualização \n \n\n \n   \n Figure 1:  Fonte ( BULTAN, 2023 ) \n \n \n \n \n \n 3.  LTL \n \n \n \n 3.1.  LTL -  Linear Temporal Logic \n \n \nNa lógica temporal linear (LTL), temos operadores para descrever eventos ao longo de uma única execução.  \n \nSeja \\(AP\\) um conjunto finito de proposições atômicas (i.e. \\(\\{ p_0, p_1, ..., p_n \\}\\)), o conjunto de fórmulas LTL sobre \\(AP\\) é definido indutivamente por:  \n se \\(p \\in AP\\) então \\(p\\) é uma fórmula LTL;  \n se \\(\\psi\\) e \\(\\phi\\) são fórmulas LTL, então \\(\\neg\\psi\\), \\(\\phi \\lor \\psi\\), \\(\\mathbf{X} \\psi\\), e \\(\\phi \\mathbf{U} \\psi\\) são fórmulas LTL.  \n \n\\[\\phi ::= \\bot\\mid\\top\\mid p\\mid \\neg\\phi \\mid \\phi \\lor \\psi \\mid \\mathbf{X} \\psi \\mid \\phi \\mathbf{U} \\psi\\]  \n \n \n \n 3.2.  Equivalências \n \n \nOs operadores  G ,  F  e  R  podem ser definidos usando somente  X  e  U .  \n\n \\(\\mathbf{G}\\psi \\equiv \\bot\\mathbf{R}\\psi \\equiv \\neg\\mathbf{F}\\neg\\psi\\)  \n \\(\\mathbf{F}\\psi \\equiv \\top\\mathbf{U}\\psi\\)  \n \\(\\phi\\mathbf{R}\\psi \\equiv \\neg(\\neg\\phi\\mathbf{U}\\neg\\psi)\\)  Até o momento que \\(\\psi\\) fica falso, \\(\\phi\\) não pode ser falso  \n \n \\(\\neg\\mathbf{G}\\psi \\equiv \\mathbf{F}\\neg\\psi\\)  \n \n \n \n 3.3.  Negações de fórmulas \n \n \nUma formula ser falsa não significa que sua negação é verdadeira. Por exemplo, a fórmula a seguir não é necessariamente verdadeira:  \n\\[\\mathbf{F}p_1 \\lor \\neg\\mathbf{F}p_1\\]  \n\n \nExemplo:  \n\n \n   \n \n \n \n \n 3.4.  Exercícios \n \n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   X , Next  \n\n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   G , Globally  \n\n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   U , Until  \n\n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   F , Finally  \n\n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   R , Release  \n \n \n \n 3.5.  LTL em Estruturas de Kripke \n \n \nUma fórmula LTL é verdadeira para uma  estrutura de Kripke  se ela é verdadeira no(s)  estado(s) inicial(is) .  \n\n \nUma fórmula LTL é verdadeira em um  estado  se ela é verdadeira para  todas as execuções  iniciando naquele estado.  \n\n \nOu seja, a fórmula deve ser verdadeira para todos as execuções (comportamentos) da estrutura.  \n \n \n \n \n 4.  CTL \n \n \n \n 4.1.  CTL -  Computational Tree Logic \n \n \nA gramática a seguir define fórmulas em CTL (sendo \\(p \\in AP\\)):  \n\\[\\phi ::= \\bot\\mid\\top\\mid p\\mid \\neg\\phi \\mid \\phi \\lor \\psi \\mid A[\\phi\\mathbf{U}\\psi]\\mid E[\\phi\\mathbf{U}\\psi]\\mid A\\mid E\\]  \n\n \nTodos os operadores temporais devem ser precedidos de  A  ( All , Todo) ou  E  ( Exists , Existe).  \n A  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro em todas as execuções a partir do estado atual;  \n E  \\(\\phi\\): Existe ao menos um caminho a partir do estado atual onde \\(\\phi\\) é verdade.  \n \n \n \n 4.2.  Visualização \n \n\n \n   \n Figure 2:  Fonte ( RAJU, 2014 ) \n \n \n \n \n \n 5.  Verificando propriedades \n \n \n \n 5.1.  LTL vs CTL \n \n \n Atenção:  \\(LTL \\nsubseteq CTL\\) and \\(CTL \\nsubseteq LTL\\)  \n\n \\(\\mathbf{F}(\\mathbf{G}p)\\) é uma fórmula LTL que não pode ser expressa em CTL.  \n \\(\\mathbf{EX}p\\) é uma fórmula CTL que não pode ser expressa em LTL.  \n \n \n \n 5.2.  Exemplo chaleiras - modelo \n \n\n \n   \n \n \n \n \n 5.3.  Exemplo chaleiras \n \n \nPS: Release é  V  nesse sistema  \n \n CTL:  \n EF(cem_graus) : true  \n esquentando -> AF cem_graus : false  \n esquentando -> EF temperatura_ambiente : true  \n EF(EG(!cem_graus)) : true  \n \n LTL:  \n F(temperatura_ambiente | cem_graus) : false  \n F(esquentando | esfriando) : true  A não ser que haja uma auto-transição em  temperatura_ambiente  \n \n \n \n \n 5.4.  Exemplo Adultos e Crianças - modelo \n \n\n \n   \n \n \n \n \n 5.5.  Exemplo Adultos e Crianças \n \n \n CTL:  \n EF trabalho : true  \n AF trabalho : false  \n \n LTL:  \n F trabalho : false  Não é possível expressar nada como  EF trabalho  \n \n formatura -> X(G(trabalho | adulto_dormir)) : true  \n formatura -> X(trabalho U adulto_dormir) : true  \n (F brincar) U formatura : false  \n \n \n \n 5.6.   Workaround  para falta do existencial com invariantes \n \n \nNa prática, quando queremos verificar o equivalente a  EF p  onde  p  é uma proposição (não uma fórmula temporal), fazemos o seguinte:  \n \nDefinimos  p  como uma invariante (isso é,  p  deve ser verdade em todos os estados)  \n \nRodamos o  model checker  \n \nInvertemos o resultado:  \n Se for “ok”, é porque a propriedade  EF p  é falsa  \n Se for uma violação, é porque a propriedade  EF p  é verdadeira (e o contra-exemplo é um exemplo de execução onde  F p  é verdade).  \n \n \n \n \n 5.7.  Referências \n \n \n    BULTAN, T.  Cs 267: Automated verification - lecture 2 . Disponível em: < https://sites.cs.ucsb.edu/~bultan/courses/267/lectures/l2.pdf >.  \n    RAJU, D.  Ltl and ctl - lecture notes by dhananjay raju . Disponível em: < https://www.cs.utexas.edu/~draju/Verification/class2.pdf >.  \n \n \n \n \n\n             \n         \n    ","url":"20240303165631-mfo_logica_temporal.html"},{"title":"Estruturas de Kripke","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Estruturas de Kripke \n                  Slides \n \n Table of Contents \n \n 1. Sistemas de transições \n 1.1. Sistema de transições: Definição \n 1.2. Sistema de transições: Definição formal \n 1.3. Sistemas de transições finito \n 1.4. Determinismo e Não-Determinismo \n \n 2. Estruturas de Kripke \n 2.1. Estruturas de Kripke \n 2.2. Exemplo:    Semáforo \n 2.3. Exercício:       Dois semáforos \n 2.4. Exercício:          Três semáforos \n 2.5. N semáforos em TLA+ \n 2.6. N semáforos em Quint \n 2.7. Perguntas \n \n 3. Não determinismo \n 3.1. Não determinismo nos semáforos \n 3.2. Não determinismo na realidade \n 3.3. Definindo a fronteira \n 3.4. Exemplo: Notas de alunos \n 3.5. Exemplo: Notas de alunos - input professor \n 3.6. Exemplo: Notas de alunos - escolhas dos alunos \n 3.7. Exemplo: Vôo com conexões \n 3.8. Exemplo: Vôo com conexões - Não determinismo \n 3.9. Exemplo: Vôo com conexões - Perdendo a conexão \n 3.10. Referências \n \n \n \n \n 1.  Sistemas de transições \n \n \n \n 1.1.  Sistema de transições: Definição \n \n Abstrações que descrevem o comportamento de sistemas com precisão matemática e sem ambiguidade ( BAIER; KATOEN, 2008 ) .  \n Podem ser vistos como grafos dirigidos onde  Os nós são  estados  \n As arestas são  transições  \n \n \nUm  estado  descreve as informações de um sistema em um momento específico.  \n\n \nUma  transição  descreve como um sistema pode mudar de um estado para outro.  \n \n \n \n 1.2.  Sistema de transições: Definição formal \n \n \nUm sistema de transições é definido pela tripla \\((S, \\to, I)\\) onde  \n \\(S\\) é um conjunto de estados,  \n \\(\\to\\ \\subseteq S \\times S\\) é uma relação de transições, e  \n \\(I \\subseteq S\\) é um conjunto de estados iniciais.  \n \nUm  comportamento  ou  execução  \\(\\rho\\) de um sistema de transições é uma sequência de estados tal que  \n\\[\\rho = s_0, s_1, \\dots\\ tal\\ que\\ s_i \\to s_{i+1}\\ para\\ todo\\ i \\geq 0\\]  \n \n \n \n 1.3.  Sistemas de transições finito \n \n \nUm sistema de transições é dito  finito  se e somente se \\(S\\) é finito.  \n\n \n Pergunta : Comportamentos de sistemas de transições finitos são sempre finitos?  \n \n \n \n 1.4.  Determinismo e Não-Determinismo \n \n \nO conjunto de  sucessores  de um estado \\(s\\) é definido por \\(Post(s) = \\{ s' \\in S\\ |\\ s \\to s' \\}\\).  \n\n \nUm sistema de transições é dito  determinístico  se e somente se \\(|I| \\leq 1 \\land \\forall s \\in S : |Post(s)| \\leq 1\\). Ou seja:  \n Tem apenas um estado inicial, e  \n Todo estado tem, no máximo, um sucessor.  \n \nNão-Determinismo acontece quando há múltiplos estados iniciais \\(|I| > 1\\) ou múltiplos sucessores para o mesmo estado (\\(|Post(s)| > 1\\)).  \n \n \n \n \n 2.  Estruturas de Kripke \n \n \n \n 2.1.  Estruturas de Kripke \n \n \nEstruturas de Kripke são um tipo de sistema de transições com uma restrição adicional:  \n \n \nA relação \\(\\to\\) deve ser total  \n \n\n \nou seja  \n\n \n \n\\(\\forall s \\in S, \\exists s' \\in S : s \\to s'\\)  \n \n \n  Estados terminais  \n \nEm sistemas de transições, um estado é dito terminal se \\(Post(s) = \\emptyset\\).  \n\n \nIsso não é possível em estruturas de Kripke, devido a restrição acima. Em  \nestruturas de Kripke, estados terminais são aqueles que possuem apenas  \ntransições para si mesmo, ou seja \\(Post(s) = \\{s\\}\\)  \n \n \n \n \n 2.2.  Exemplo:    Semáforo \n \n \nUm semáforo pode ser representado por uma estrutura de Kripke \\((S, \\to, I)\\) onde  \n \\(S = \\{ verde, amarelo, vermelho \\}\\)  \n \\(\\to = \\{ verde \\to amarelo, amarelo \\to vermelho, vermelho \\to verde \\}\\)  \n \\(I = \\{ vermelho \\}\\)  \n \n   \n \n \n \n \n 2.3.  Exercício:       Dois semáforos \n \n \nUm sistema com  dois  semáforos pode ser representado por uma estrutura de Kripke \\((S, \\to, I)\\) onde …  \n \n \n \n 2.4.  Exercício:          Três semáforos \n \n Vish!  \n Muita coisa pra escrever, certo?  \n Um jeito melhor: linguagens de especificação  \n \n  Vamos perceber algumas generalizações  \n Cada semáforo deve iniciar vermelho, e fazer o caminho vermelho \\(\\to\\) verde \\(\\to\\) amarelo enquanto os outros permanecem vermelhos.  \n Quando um semáforo fecha, queremos que  outro  semáforo abra  Com três semáforos, deve haver um revezamento que garanta que cada um vai abrir de vez em quando.  \n \n \n \n \n \n 2.5.  N semáforos em TLA+ \n \n\n \n   \n \n \n \n \n 2.6.  N semáforos em Quint \n \n \nEspecificação completa no GitHub.  \n\n \n module  semaforos {\n   type  Cor = Vermelho | Verde | Amarelo\n   type  Semaforo =  int \n\n   var  cores: Semaforo -> Cor\n   var  proximo: Semaforo\n\n   const  SEMAFOROS:  Set [Semaforo]\n\n   action  fica_verde(s: Semaforo):  bool  =  all  {\n    proximo == s,\n    SEMAFOROS.forall(s2 => cores.get(s2) == Vermelho),\n\n    cores' = cores.set(s, Verde),\n    proximo' = (s + 1) % SEMAFOROS.size(),\n  }\n\n  ...\n}\n \n \n \n \n \n 2.7.  Perguntas \n \n \nTodos os exemplos de semáforos (1, 2, 3 e N) são sistemas de transições. Quais deles são Estruturas de Kripke?  \n    Para um sistema de transições ser uma estrutura de Kripke, \\(\\to\\) deve ser total:  \\(\\forall s \\in S, \\exists s' \\in S : s \\to s'\\)  \n \n \n \nOs sistemas de semáforos são finitos?  \n   Um sistema de transições é dito  finito  se e somente se \\(S\\) é finito.  \n \n \nNossas definições de semáforo são determinísticas?  \n   O conjunto de  sucessores  de um estado \\(s\\) é definido por \\(Post(s) = \\{ s' \\in S\\ |\\ s \\to s' \\}\\).  \n   Sistema é deterministico sse \\(|I| \\leq 1 \\land \\forall s \\in S : |Post(s)| \\leq 1\\)  \n \n \n \n \n \n 3.  Não determinismo \n \n \n \n 3.1.  Não determinismo nos semáforos \n \n \nComo seriam semáforos com não determinismo?  \n \\(Post(s) = \\{ s' \\in S\\ |\\ s \\to s' \\}\\).  \n Sistema é deterministico sse \\(|I| \\leq 1 \\land \\forall s \\in S : |Post(s)| \\leq 1\\)  \n \nQualquer estado pode ser um estado inicial. Se definirmos isso (\\(I = S\\)), temos não determinismo  \n \\(|I| \\leq 1\\) não é satisfeito  \n \n \nCaso o primeiro semáforo a abrir não esteja definido  \n \\(|Post(1: vermelho\\ e\\ ...\\ e\\ N: vermelho\\ e\\ próximo: indefinido)| \\leq 1\\) não é satisfeito  \n \n \nCaso a definição de próximo seja removida  \n \\(|Post(1: vermelho\\ e\\ ...\\ e\\ N: vermelho)| \\leq 1\\) não é satisfeito  \n \n \n \n \n 3.2.  Não determinismo na realidade \n \n \nOnde podemos encontrar não determinismo em sistemas de software?  \n \n \n \n 3.3.  Definindo a fronteira \n \n \nAo especificar um sistema, especialmente quando há não determinismo, é preciso definir uma fronteira.  \n Até aquela fronteira, fatores externos não especificados determinam o que acontece.  \n O não determinismo é uma forma de abstrair esses fatores externos  i.e. De A, vou pra B ou C. Isso depende de algum fator externo. Se é a jogada de um dado ou o input de um usuário, não me importa.  \n Se isso me importa, então vou modelar a jogada de dado.  \n \n \n \n \n 3.4.  Exemplo: Notas de alunos \n \n \nVamos considerar duas fronteiras diferentes:  \n \nO professor coloca uma nota no SIGA. Se a nota for \\(\\geq 7\\), o aluno passa.  \n Não determinismo no input do professor  \n \n O aluno pode ou não prestar atenção nas aulas. Se prestar atenção, vai se dar bem na prova, sua nota será maior que 7, e portanto vai passar.  Não determinismo nas escolhas do aluno  \n A nota que o professor dá é  determinada  pelas escolhas do aluno  \n \n \nNo caso (2) estamos detalhando mais o mundo externo fora do SIGA, enquanto no (1) a fronteira é na interface do SIGA.  \n\n \nO caso (1) é uma especificação do SIGA, enquanto o (2) fala mais sobre um sistema universitário.  \n \n \n \n 3.5.  Exemplo: Notas de alunos - input professor \n \n\n \n   \n \n \n \n \n 3.6.  Exemplo: Notas de alunos - escolhas dos alunos \n \n\n \n   \n \n \n \n \n 3.7.  Exemplo: Vôo com conexões \n \n \n Versão 1 :  \n \n \nJoinville → São Paulo → Paris  \n \n\n \n Versão 2 :  \n \n \nCheck-in em Joinville → Despacho de Bagagem em Joinville → Check de Segurança em Joinville → Embarque em Joinville → Pouso em São Paulo → Check de Segurança em São Paulo → Embarque em São Paulo → Pouso em Paris → Retirada de bagagem em Paris  \n \n \n \n \n 3.8.  Exemplo: Vôo com conexões - Não determinismo \n \n \nOnde poderia ter  não determinismo ?  \n Chegar atrasado e perder o check-in  \n Acharem uma bomba na bagagem  \n Problemas técnicos no vôo  \n Perder a conexão  \n \nPodemos ter não determinismo em cada estado. Nos casos listados, podemos ou não determinar o que acontece. Cabe ao nível de detalhe, ou a  fronteira  da nossa modelagem.  \n \n \n \n 3.9.  Exemplo: Vôo com conexões - Perdendo a conexão \n \n\n \n   \n \n\n\n \n   \n \n\n\n \n   \n \n \n \n \n 3.10.  Referências \n \n \n    BAIER, C.; KATOEN, J.-P.  Principles of model checking . Cambridge, MA: The MIT Press, 2008.  \n \n \n \n \n\n             \n         \n    ","url":"20240217142930-mfo_estruturas_de_kripke.html"},{"title":"Programação e matemática não são a mesma coisa","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Programação e matemática não são a mesma coisa \n                  Slides \n \n Table of Contents \n \n 1. Introdução \n 1.1. Essa aula não é sobre \n 1.2. Essa aula é sobre \n 1.3. Ainda sobre essa aula \n \n 2. Correspondências interessantes \n 2.1. Philip Wadler \n 2.2. Um pouco de história \n 2.3. Computabilidade \n 2.4. Correspondências interessantes - está tudo interligado! \n 2.5. A matemática é inventada ou descoberta? \n 2.6. A matemática é inventada ou descoberta? - Cont. \n 2.7. Isomorfismo de Curry-Howard \n 2.8. Interpretação algébrica para tipos \n 2.9. Exponenciação como tipos de funções I \n 2.10. Sistemas de tipos \n 2.11. Tipos dependentes \n 2.12. Funções parciais \n \n 3. Diferenças importantes \n 3.1. Erros vs indefinições \n 3.2. Funções vs Maps \n 3.3. Implementação vs definição \n 3.4. Em resumo \n 3.5. Referências \n \n \n \n \n 1.  Introdução \n \n \n \n 1.1.  Essa aula não é sobre \n \n \nEssa aula não é sobre:  \n “Precisa saber matemática pra programar?”  \n “Quem tem base matemática programa melhor?”  \n \n… que muitas vezes são derivados de “precisa ter faculdade pra trabalhar com programação?”  \n\n \nVocês estão cursando Ciência da Computação, então independente disso tudo, vão sim aprender uma base lógica/matemática.  \n \n \n \n 1.2.  Essa aula é sobre \n \n \nComo matemática e programação se relacionam, e a importância de entender as diferenças.  \n \n  Métodos Formais são sobre matemática ou sobre programação?  \n \nVamos trabalhar com ambos no mesmo ambiente, e o domínio sobre quando usar uma perspectiva ou outra é a principal habilidade para se escrever uma boa  especificação formal .  \n\n \nNo geral, nós, programadores, tendemos à  perspectiva da programação , e precisamos nos esforçar para descrever algumas coisas na  perspectiva matemática .  \n\n \nPara isso, primeiro precisamos entender as semelhanças e diferenças  \n \n \n \n \n 1.3.  Ainda sobre essa aula \n \n \nSe você gostar muito do conteúdo dessa aula:  \n Maravilha, considere fazer TCC/pesquisa sobre um dos assuntos!  \n Sinta-se motivado para a disciplina  \n \nSe você  não  gostar da aula e ela só te assustar:  \n Calma, a disciplina não vai ser nesse nível de loucura  \n Começamos tudo do básico na próxima aula, e a maioria do conteúdo dessa aula nem será visto na disciplina  \n \nPensem nisso como uma apresentação de feira de profissões (para a profissão métodos formais e adjacentes).  \n \n \n \n \n 2.  Correspondências interessantes \n \n \n \n 2.1.  Philip Wadler \n \n \nA primeira parte dessa aula é baseada na palestra/artigo do Philip Wadler ( WADLER, 2015 )  \n\n \n   \n \n \n \n \n 2.2.  Um pouco de história \n \n \nEm 1928, Hilbert propõe um desafio intitulado  entscheidungsproblem  (problema de decisão).  \n Ele acredita que existe um possível algoritmo que diz se uma declaração pode ou não ser provada pelas regras de uma lógica.  \n Isso é equivalente a afirmar que a lógica é completa: tudo o que é provado é verdadeiro, e tudo o que e verdadeiro é provável.  \n \nGödel prova a incompletude da lógica em 1931 (teorema da incompletude de Gödel). Ele mostra como representar o seguinte teorema em qualquer lógica capaz de representar aritmética:  \n \n \n“Esta declaração não é provável”  \n \n Se for verdade, não é provável  \n Se for provável, não é verdade  \n \n \n \n 2.3.  Computabilidade \n \n \nO primeiro computador (ENIAC) surgiu somente em 1946. Na época de Hilbert, o conceito de algoritmo é um conjunto de instruções a ser seguido por um humano.  \n Não havia uma definição formal do que é computabilidade/algoritmo  \n \nEnquanto as pessoas acreditavam que Hilbert estava correto, não havia necessidade de definir computabilidade.  \n Quando alguém encontrar a solução para o problema, a solução será um algoritmo.  \n \nPara mostrar que o  entscheidungsproblem  é indecidível, precisamos da definição de computabilidade  \n Para que seja possível mostrar que nenhum possível algoritmo pode resolver o problema.  \n \n \n \n 2.4.  Correspondências interessantes - está tudo interligado! \n \n \nEntão, as pessoas começam a tentar definir computabilidade. Surpreendentemente, três pessoas independentemente encontram soluções:  \n Em maio de 1935, Alonzo Church define o cálculo lambda  \n Em julho de 1935, Kurt Gödel (e seu aluno Kleene) define funções recursivas  \n Em maio de 1936, Alan Turing define maquinas de Turing  \n \nAs três são equivalentes!  \n \n \n \n 2.5.  A matemática é inventada ou descoberta? \n \n ( WADLER, 2015 ) Quais partes dessa imagem um alienígena tem mais chances de entender?  \n \n   \n \n\n Quais linguagens de programação eles teriam mais chances de entender?  \n \n \n \n 2.6.  A matemática é inventada ou descoberta? - Cont. \n \n \nWadler faz uma ótima argumentação de que a matemática é descoberta, o que ressoa muito comigo pessoalmente.  \n Se Church, Gödel e Turing tivessem inventado (e não descoberto) essas definições, quais as chances delas acabarem sendo equivalentes?  \n \nVamos ver mais um argumento de Wadler a favor dessa perspectiva: o Isomorfismo de Curry-Howard.  \n \n \n \n 2.7.  Isomorfismo de Curry-Howard \n \n Proposições como tipos  \n Provas como programas  \n Simplificação de provas como avaliação de programas  \n   Lógica \n Tipos \n Falso \n Void \n Verdadeiro \n () \n \\(a \\lor b\\) \n Either a b \n \\(a \\land b\\) \n (a,b) \n \\(a \\implies b\\) \n a -> b \n \nExemplo: implicação e abstração + aplicação  \n   Lógica \n Tipos \n \\({\\displaystyle {\\frac {}{\\Gamma _{1},\\alpha ,\\Gamma _{2}\\vdash \\alpha }}{\\text{Ax}}} \\rule{0pt}{4ex}\\) \n \\({\\displaystyle {\\frac {}{\\Gamma _{1},x:\\alpha ,\\Gamma _{2}\\vdash x:\\alpha }}}\\) \n \\({\\displaystyle {\\frac {\\Gamma ,\\alpha \\vdash \\beta }{\\Gamma \\vdash \\alpha \\rightarrow \\beta }}\\rightarrow I} \\rule{0pt}{8ex}\\) \n \\({\\displaystyle {\\frac {\\Gamma ,x:\\alpha \\vdash t:\\beta }{\\Gamma \\vdash \\lambda x.t:\\alpha \\rightarrow \\beta }}}\\) \n \\({\\displaystyle {\\frac {\\Gamma \\vdash \\alpha \\rightarrow \\beta \\qquad \\Gamma \\vdash \\alpha }{\\Gamma \\vdash \\beta }}\\rightarrow E} \\rule{0pt}{8ex}\\) \n \\({\\displaystyle {\\frac {\\Gamma \\vdash t:\\alpha \\rightarrow \\beta \\qquad \\Gamma \\vdash u:\\alpha }{\\Gamma \\vdash t\\;u:\\beta }}}\\) \n \n \n \n 2.8.  Interpretação algébrica para tipos \n \n A teoria das categorias define um nível ainda mais alto de abstração para enxergar algumas coisas. Um dos exemplos mais simples de uma categoria é a categoria dos conjuntos (e das funções entre eles) ( DE FRANÇA, 2019 ).  \n As chamadas categorias cartesianas fechadas podem ser relacionadas a nossa álgebra de ensino médio  A categoria dos tipos é uma delas!  \n \n    Lógica \n Tipos \n Álgebra \n Falso \n Void \n \\(0\\) \n Verdadeiro \n () \n \\(1\\) \n \\(a \\lor b\\) \n Either a b \n \\(a + b\\) \n \\(a \\land b\\) \n (a,b) \n \\(a * b\\) \n \\(a \\implies b\\) \n a -> b \n \\(b^a\\) \n \n \n \n 2.9.  Exponenciação como tipos de funções I \n \n \nVamos escrever tipos função ( a -> b ) como operações de exponenciação da álgebra:  \n \n\\(a^0 = 1\\) tem assinatura  Void -> a . Apenas uma função tem essa assinatura (em Haskell,  absurd )  \n \n\\(a^1 = a\\) tem assinatura  () -> a . O número de funções com esse tipo é o mesmo número de valores do tipo  a .  \n Por exemplo, pra  a  sendo  bool , temos  f x = false  e  f x = true  \n Qualquer outra versão de  f x  pra esse tipo será equivalente a uma dessas duas  \n \n \n\\(1^a = 1\\) tem assinatura  a -> () . Apenas uma função tem essa assinatura ( f x = () )  \n \n\\(a^{b+c}\\) tem assinatura  Either b c -> a  \n Para definir uma função desse tipo, temos que definir os casos  Left  com tipo  b -> a  e  Right  com tipo  c -> a  \n Ou seja, \\(a^{b + c} = a^b * a^c\\)  \n \n \n\\((a^b)^c\\) tem assinatura  c -> (b -> a)  \n Lembrando de currying, sabemos que isso é equivalente a  (c,b) -> a .  \n Ou seja, \\((a^b)^c = a^{(b*c)}\\)  \n \n \\((a*b)^c\\) tem assinatura  c -> (a, b)  Equivalente a um par de funções  c -> a  e  c -> b  \n Ou seja, \\((a*b)^c = a^c * b^c\\)  \n \n \n \n \n 2.10.  Sistemas de tipos \n \n Com tudo o que vimos até aqui, é seguro afirmar que istemas de tipos são uma parte da ciência da computação que tem uma grande intersecção com a matemática  \n Sistemas de tipos também são métodos formais: Definimos uma especificação (assinaturas de tipos) e o type checker é nosso sistema de verificação.  \n Estudar matemática avançada pode dar base para usos cada vez mais avançados de sistemas de tipos  Tipos dependentes  \n HoTT (Homotopy Type Theory)  \n \n \n \n \n 2.11.  Tipos dependentes \n \n \nTipos dependentes: quando o tipo depende do valor. No exemplo a seguir, usamos o sistema de tipos para provar que a função  map  não altera o tamanho de um vetor. Isso não é possível sem tipos dependentes.  \n \n map : {A B : Set} {n : Nat} -> (A -> B) -> Vec A n -> Vec B n\nmap f [] = []\nmap f (x :: xs) = f x :: map f xs\n \n \n\n \nTipos dependentes são uma parte importante de muitos assistentes de provas (como Coq e Agda). Bem provável que vamos ver mais sobre eles durante os seminários da disciplina.  \n \n \n \n 2.12.  Funções parciais \n \n \nAgora, um caso mais tangível para voltarmos um pouco para a nossa realidade.  \n \nNa matemática, funções podem ser totais ou parciais  \n Para transformar funções parciais em totais, adicionamos o valor bottom (\\(\\bot\\)) ao co-domínio e mapeamos todos os valores anteriormente indefinidos ao bottom.  \n \n Na computação, funções parciais precisam retornar o tipo soma. Dependendo da linguagem, pode ser algo como:  f(x: int): int | undefined  \n int -> Maybe int  \n \n \n \n \n \n 3.  Diferenças importantes \n \n \n \n 3.1.  Erros vs indefinições \n \n Na matemática, algumas fórmulas são indefinidas.  Divisão não está definida para denominador \\(0\\)  \n Exponenciação não está definida para \\(0^0\\)  \n \n Na programação, precisamos  definir  o que acontece nesses cenários  Normalmente, o que queremos é reportar algum tipo de erro  \n Programação envolve humanos. Humanos erram e precisam entender aonde erraram.  “Opa, você tentou dividir por 0 na linha X coluna Y” - pode salvar alguém de horas de debugging  \n \n \n \n \n \n 3.2.  Funções vs Maps \n \n \nFunções matemáticas podem ser programadas através de funções ou  Maps  ( KONNOV, 2024 ). Pense nos exemplos  \n Função de um número para seu dobro.  \n Função do nome da pessoa para sua idade.  \n \nNa programação, vamos considerar os fatores  \n Uso de Memória  \n Velocidade de resposta  \n \nNuma especificação formal, memória e velocidade não importam da mesma forma  \n \n \n \n 3.3.  Implementação vs definição \n \n \nImagine a seguinte definição:  \n Dada uma função que ordena uma lista de inteiros  \n \nO que você pensou sobre essa função?  \n \nBem possível que pensou em um ou mais algoritmos de ordenação (i.e. bubble sort, selection sort, quick sort)  \n \nNa matemática, não importa  como  a ordenação é feita. A função em questão poderia ser descrita mais precisamente por:  \n Seja \\(f: \\overline{\\mathbb{Z}} \\rightarrow \\overline{\\mathbb{Z}}\\) tal que \\(f(x)_i \\leq f(x)_{i+1}\\) para todo \\(i \\in [0, |x|-1)\\)  \n \nNuma especificação formal, se não há relevância no algoritmo de ordenação (contanto que ele, de fato, ordene), podemos economizar recursos na verificação ao especificar somente a propriedade de ordenação.  \n \n \n \n 3.4.  Em resumo \n \n Matemática e programação estão muito interligados  \n Contudo, há diferenças nos níveis de abstração entre o que costumamos descrever em definições matemáticas e em programas.  Em programas, nos importamos com memória e velocidade, o que normalmente não é representado na matemática.  \n Em programas, precisamos detalhar  como  cada função é implementada, enquanto na matemática podemos somente definir funções pelas suas propriedades.  Inclusive, precisamos detalhar o que acontece em casos indefinidos pela matemática, como divisão por 0.  \n \n \n \n \n \n 3.5.  Referências \n \n \n    DE FRANÇA, F. O.  Tipo função . Disponível em: < https://haskell.pesquisa.ufabc.edu.br/teoria-das-categorias/09-tipofuncao/ >.  \n    KONNOV, I.  You should not care about memory in protocol specifications . Disponível em: < https://konnov.github.io/protocols-made-fun/quint/2024/01/14/maps.html >.  \n    WADLER, P.  Propositions as types .  Commun. acm , v. 58, n. 12, p. 75–84, Nov. 2015.  \n \n \n \n \n\n             \n         \n    ","url":"20240213151141-mfo_programacao_e_matematica_nao_sao_a_mesma_coisa.html"},{"title":"Apresentação","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Apresentação \n                  Slides \n \n Table of Contents \n \n 1. Contexto \n 1.1. Sobre Métodos Formais \n 1.1.1. Essência \n 1.1.2. Histórico da disciplina \n \n 1.2. Sobre Mim \n 1.2.1. Sobre Mim \n 1.2.2. Meu envolvimento com Métodos Formais \n \n \n 2. Plano de Ensino \n \n 2.0.1. Vamos aprender TLA+ e Quint? \n 2.0.2. Vamos aprender TLA+ e Quint? - Continuação \n \n 2.1. Conteúdo \n 2.1.1. Plano de ensino \n 2.1.2. Conteúdo programático \n 2.1.3. Metodologia \n \n 2.2. Sistema de avaliação \n 2.2.1. Do desempenho do aluno \n 2.2.2. OFF: guia para navegar as avaliações \n 2.2.3. Exame \n 2.2.4. Do desempenho da disciplina e da professora \n \n 2.3. Bibliografia \n 2.3.1. Bibliografia básica \n 2.3.2. Bibliografia complementar \n \n \n 3. Recursos \n \n 3.0.1. Recursos \n \n \n \n \n \n 1.  Contexto \n \n \n \n 1.1.  Sobre Métodos Formais \n \n \n \n 1.1.1.  Essência \n \n \nMétodos formais são técnicas, embasadas na matemática, que visam verificar que algum hardware/software faz o que se propõe.  \n\n \nAs técnicas incluem dois componentes:  \n Uma linguagem de especificação  \n Um sistema de verificação  \n \n \n \n 1.1.2.  Histórico da disciplina \n \n Lá por 2015~2017, ensinava-se uma linguagem chamada Z  \n Em ~2018, ensinava-se Redes de Petri  \n Em 2019, o prof Cristiano assumiu a disciplina ensinando Coq  \n Em 2024/1, eu assumi a disciplina ensinando TLA+ (Temporal Logic of Actions+) e Quint  \n \n \n \n \n 1.2.  Sobre Mim \n \n \n \n 1.2.1.  Sobre Mim \n \n \nAcademia:  \n Ciência da Computação - UDESC - 2015-2019  TCC : Tradução automática de especificação formal modelada em TLA+ para linguagem de programação  \n \n Computação Aplicada - UDESC - 2020-2022  Dissertação : Test Generation From TLA+ Specifications  \n \n \nIndústria:  \n Magrathea Labs (agora Trusted Health) - 2018-2021  Estágio (5 meses) + Engenheira de Software  \n \n Informal Systems - 2021-presente  Engenheira de Pesquisa  \n \n \n \n \n 1.2.2.  Meu envolvimento com Métodos Formais \n \n Aprendi TLA+ na graduação para fazer meu TCC, e continuei estudando TLA+ no mestrado  \n \nEntrei na Informal Systems devido à pesquisa ativa (minha e deles) em TLA+  \n Muitos engenheiros com dificuldade em aprender e usar TLA+  \n \nTinham a proposta de uma nova syntaxe para TLA+, que chamamos hoje de  Quint  \n Sou a principal desenvolvedora dessa linguagem desde o início de 2022  \n \n \n \n \n \n \n \n 2.  Plano de Ensino \n \n \n \n 2.0.1.  Vamos aprender TLA+ e Quint? \n \n \nSim, mas vocês vão escolher em qual das duas fazer o primeiro trabalho  \n Na prova, sempre que houver exemplo de código, haverá versões nas duas linguagens  \n \nOs exemplos em aula poderão ser em qualquer uma das linguagens.  \n\n \nMinha expectativa é que vocês consigam entender especificações em ambas as linguagens, já que toda a base lógica para elas é a mesma - e a base lógica é a parte mais importante da disciplina.  \n \n \n \n 2.0.2.  Vamos aprender TLA+ e Quint? - Continuação \n \n \nTLA+ é uma linguagem de especificação bem estabelecida, e será nossa principal fundamentação teórica da disciplina  \n Alguns assuntos mais avançados vamos abordar somente em TLA+  \n \nQuint é opcional, vocês podem escolher fazer tudo em TLA+ se quiserem.  \n A linguagem e o ferramental de Quint pode facilitar bastante a vida de vocês.  \n O trabalho final será em Quint, mas vocês vão receber a especificação pronta.  Será necessário rodar comandos no terminal, então todos terão que instalar o Quint.  \n \n Vamos conversar mais sobre isso no decorrer das aulas.  \n \n \n \n 2.1.  Conteúdo \n \n \n \n 2.1.1.  Plano de ensino \n \n \nDisponível no SIGA (assim que for aprovado). Vamos ver juntos agora.  \n \n  Objetivo Geral  \n \nDesenvolver habilidades para reconhecimento de cenários, em sistemas computacionais, onde o uso de métodos formais é apropriado; e para aplicação de métodos formais.  \n \n \n  Objetivo Específico  \n Estimular o  senso de necessidade  de técnicas que auxiliem a garantir comportamentos em sistemas computacionais.  \n Desenvolver a  capacidade de abstração  ao descrever comportamentos de sistemas em linguagens de especificação formal.  \n Trabalhar técnicas de testes baseados em modelos para  conectar especificações com implementações .  \n \n \n \n \n 2.1.2.  Conteúdo programático \n \n Introdução: Programação e matemática não são a mesma coisa  \n Estruturas de Kripke  \n Lógica Temporal  \n Exemplo com semáforos  \n Motivação para o uso de métodos formais  \n Linguagens de especificação formal  \n Lógica Temporal de Ações: TLA+ e Quint  \n Exemplo com Jogo da Velha  \n Formulas temporais em TLA+ e Quint  \n Métodos formais no design de protocolos  \n Especificações para sistemas distribuídos  \n Exemplo sobre a efetivação em duas fases (two phase commit)  \n Verificação vs testes  \n Testes baseados em modelos  \n Outros métodos formais  \n Métodos formais no ciclo de desenvolvimento de software  \n Model checking  \n Refinamento  \n Model values e conjuntos de simetria  \n \n \n \n 2.1.3.  Metodologia \n \n \nA disciplina será desenvolvida através de aulas expositivo-dialogadas, com exercícios e trabalhos práticos, e seminários. O conteúdo da disciplina poderá ser ministrado na modalidade de ensino a distância em até 20% do total de sua Carga Horária (MEC PORTARIA No 4.059, DE 10 DE DEZEMBRO DE 2004 publicado no DOU de 13/12/2004, Seção 1, p. 34).  \n \n \n \n \n 2.2.  Sistema de avaliação \n \n \n \n 2.2.1.  Do desempenho do aluno \n \n \nA qualidade do desempenho do aluno será avaliada com base em:  \n Uma prova individual (P) - 30%  \n Dois trabalhos práticos (T1 e T2) - 25% cada  \n Um seminário (S) - 10%  \n Exercícios (E) - 10%  \n \nAssim, a Média Semestral (MS) será calculada pela fórmula  \n \nMS = (30 * P + 25 * T1 + 25 * T2 + 10 * S + 10 * E)/100  \n \n \n \n 2.2.2.  OFF: guia para navegar as avaliações \n \n O trabalho 1 é o mais trabalhoso e importante  \n O seminário é bem simples, mas não deixem de fazer porque depois a nota faz falta  É também mais no início do semestre onde vocês tem mais tempo livre  \n \n Os exercícios existem exclusivamente para prepará-los para o primeiro trabalho.  Eu não estava cobrando até semestre passado, mas decidi cobrar para incentivá-los a não chegarem despreparados para o trabalho.  \n \n O trabalho 2 é bem tranquilo. Pensem nele como um impulso extra para passar (e não como um motivo de desistir).  \n \n \n \n 2.2.3.  Exame \n \n \nCaso o discente não obtenha média MS igual ou superior a 7,0, um exame escrito será aplicado objetivando aferir o conhecimento teórico do estudante. Não há recuperação das provas por não comparecimento, exceto nos casos previstos no regulamento da UDESC na resolução 0392015 - CONSEPE.  \n \n \n \n 2.2.4.  Do desempenho da disciplina e da professora \n \n \nOs estudantes terão, igualmente, a oportunidade de fazer uma avaliação do desempenho da professora e da disciplina. As informações sobre esta atividade serão fornecidas pelo coordenador do curso.  \n \n \n \n \n 2.3.  Bibliografia \n \n \n \n 2.3.1.  Bibliografia básica \n \n \n  \n \n    BAIER, C.; KATOEN, J.-P.  Principles of model checking . Cambridge, MA: The MIT Press, 2008.  \n    LAMPORT, L.  Specifying systems: The tla+ language and tools for hardware and software engineers . Boston: Addison-Wesley, 2002.  \n    MONIN, J. F.; HINCHEY, M. G.  Understanding formal methods . Berlin, Heidelberg: Springer-Verlag, 2001.  \n \n \n \n \n 2.3.2.  Bibliografia complementar \n \n \n  \n \n    KONNOV, I.; KUKOVEC, J.  Tla+ language reference manual . Disponível em: < https://apalache.informal.systems/docs/lang/index.html#tla-language-reference-manual- >.  \n    LAMPORT, L.  A science of concurrent programs . 2024. Disponível em: < https://lamport.azurewebsites.net/tla/science.pdf >.  \n    TEAM, T. Q.  Quint . Disponível em: < https://quint-lang.org >.  \n \n \n \n \n \n \n 3.  Recursos \n \n \n \n 3.0.1.  Recursos \n \n Aulas em HTML no meu site:  bugarela.com/mfo  Todo o conteúdo dos slides  \n \n Toda a bibliografia tem disponível online gratuitamente  \n Páginas web relevantes  TLA+:  https://lamport.azurewebsites.net/tla/tla.html  \n Quint:  https://quint-lang.org  \n \n \n \n \n\n             \n         \n    ","url":"20240210123703-mfo_apresentacao.html"}]