[{"title":"Homepage","content":"\n     \n       \n   \n     \n     \n     \n       \n           Gabriela Moreira \n       \n       \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n       \n       \n   Created using Emacs and  org-mode \n \n\n     \n   \n \n\n       \n         Homepage \n         \n Índice \n \n Apresentação \n Aulas \n Trabalho 1 \n \n \n \n Apresentação \n \n \n Aulas \n \n Testando um problema da maratona \n Programação e matemática não são a mesma coisa \n Estruturas de Kripke \n Checando propriedades com Lógica Temporal \n Checando propriedades com Lógica Temporal II \n Por que e pra que métodos formais? \n Introdução à Lógica Temporal das Ações \n Primeiras Especificações \n Revisão de programação funcional em Quint \n Jogo da Velha em Quint \n Introdução ao TLA+ \n Primeiras Especificações em TLA+ \n Exercícios Pokemon \n Especificar vs Implementar \n Efetivação em Duas Fases \n Design de protocolos \n Propriedades \n \n \n \n Trabalho 1 \n \n Trabalho 1 \n FAQ Trabalho 1 \n Dicas Trabalho 1 \n \n \n\n       \n     \n  ","url":"sitemap.html"},{"title":"Métodos Formais ","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Métodos Formais  \n                    \n  \n Links úteis \n \n Apresentação \n Cheatsheet Lógica Temporal (PDF) \n Exercícios para a prova \n \n \n Quint \n \n Getting Started: Quint \n Exemplos \n \n \n \n TLA+ \n \n Getting Started: TLA+ \n Exemplos \n \n \n \n \n Aulas \n \n \n \n Motivação \n \n Programação e matemática não são a mesma coisa \n Por que e pra que métodos formais? \n \n \n \n Lógica \n \n Estruturas de Kripke \n Checando propriedades com Lógica Temporal \n Checando propriedades com Lógica Temporal II \n Introdução à Lógica Temporal das Ações \n \n \n \n Quint \n \n Revisão de programação funcional em Quint \n Primeiras Especificações \n Jogo da Velha em Quint \n \n \n \n TLA+ \n \n Introdução ao TLA+ \n Primeiras Especificações em TLA+ \n \n \n \n \n Seminário \n \n Seminário \n \n \n \n Trabalho 1 \n \n Exercícios Pokemon \n \n \n\n             \n         \n    ","url":"index.html"},{"title":"TLA+ Getting Started","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 TLA+ Getting Started \n                  \nEsse é um pequeno guia cobrindo desde a instalação até sua primeira verificação em TLA+. Baseado no  Getting Started do Quint .\n \n\n \nInstalar a extensão TLA+ Nightly no VSCode\nAbra o painel de extensões (Ctrl+Shift+X ou clicando no ícone)\nProcure por TLA+ Nightly e clique e instalar\n \n Se a extensão “TLA+” estiver instalada, desinstale-a, porque as duas não funcionam bem juntas. A versão Nightly tem mais features, e vamos precisar de uma delas logo. \n \nPS: Se aparecer pra você que essa versão está depreciada e recomendar a nova “TLA+ (Temporal Logic of Actions)”, pode instalar a nova. Na aula de segunda isso não apareceu pra mim, mas vi esse aviso no meu computador de casa agora. Eles acabaram de lançar essa versão, e ela parecer ter tudo o que vamos precisar pra disciplina, então tudo bem. Se instalarem essa, lembrem de desinstalar a TLA+/TLA+ Nightly.\n \n\n \nEscreva sua primeira especificação\nPara rodar as ferramentas do TLA+, precisamos primeiro de uma especificação em TLA+. Vamos usar a seguinte especificação de um banco, que tem um bug:\n \n \n --------------------------  MODULE  bank --------------------------\n EXTENDS  Integers\n\n \\* A state variable to store the balance of each account \n VARIABLE  balances\n\nADDRESSES == {  \"alice\" ,  \"bob\" ,  \"charlie\"  }\n\nDeposit(account, amount) ==\n   \\* Increment balance of account by amount \n  balances' = [balances  EXCEPT  ![account] = @ + amount]\n\nWithdraw(account, amount) ==\n   \\* Decrement balance of account by amount \n  balances' = [balances  EXCEPT  ![account] = @ - amount]\n\nInit ==\n   \\* At the initial state, all balances are zero \n  balances = [ addr \\in ADDRESSES |->  0  ]\n\nNext ==\n   \\* Non-deterministically pick an address and an amount \n  \\E account \\in ADDRESSES, amount \\in  1 .. 100  :\n     \\* Non-deterministically choose to either deposit or withdraw \n    \\/ Deposit(account, amount)\n    \\/ Withdraw(account, amount)\n\nNoNegatives == \\A addr \\in ADDRESSES : balances[addr] >=  0 \n=================================================================\n \n \n\n \nCrie um arquivo  bank.tla  com o conteúdo acima. O arquivo deve ter esse nome, porque em TLA+, o nome do modulo deve ser idêntico ao do arquivo. Vamos tentar checar a invariante  NoNegatives , que diz que nenhum dos saldos ( balances ) pode ser negativo. Uma invariante é algo que precisa ser verdadeiro em todos os estados alcançáveis.\n \n\n \nAdicionalmente, precisamos de um arquivo  bank.cfg  para configurar os parâmeros, com o conteúdo a seguir.\n \n \n INIT\nInit\n\nNEXT\nNext\n\nINVARIANT\nNoNegatives\n \n \n\n \nEncontrando uma violação\nPrimeiro, vamos usar o modo de simulação para encontrar uma violação. Esse modo vai tentar várias (mas não todas) execuções.\n \n\n Abra o arquivo  bank.tla  e use F1 ou Ctrl+Shift+P para abrir o menu de comandos do VSCode \n Selecione a opção “TLA+: Check model with TLC” \n No prompt que aparece, substitua o valor padrão  -coverage=1  por  -simulate num=10000  para rodar o TLC no modo de simulação com 10 mil amostras e aperte Enter. \n \nIsso deve resultar em uma violação, mostrando uma execução onde alguém fica com saldo negativo.\n \n\n \nConsertando o bug\nAtualize a definição  Withdraw  para previnir que esse cenário aconteça: usuários não deveriam poder sacar mais do que eles tem em saldo.\n \n\n \n Withdraw(account, amount) ==\n   \\* A precondition, there should be enough to withdraw \n  /\\ balances[account] >= amount\n   \\* Decrement balance of account by amount \n  /\\ balances' = [balances  EXCEPT  ![account] = @ - amount]\n \n \n\n \nAgora, podemos rodar o simulador novamente (repetir passo 3) e nenhuma violação deve ser encontrada.\n \n\n \nVerificando o resultado\n \n\n \nContudo, o simulador pode não ter considerado algumas execuções. Para ter certeza que o problema foi consertado, devemos rodar o  model checker . O TLC não é um model checker limitado, e como essa especificação lida com inteiros arbitrários, ele vai ficar rodando até ficar sem memória. Então, precisamos antes restringir nosso espaço de busca. Vamos modificar nosso  Next  para que a execução só consiga progredir enquanto os saldos forem menor do que  50  (você pode diminuir esse número se o TLC ainda estiver demorando muito):\n \n \n Next ==\n   \\* Only continue if balance is small enough to avoid a big state space \n  /\\ \\A addr \\in ADDRESSES : balances[addr] <=  50 \n   \\* Non-deterministically pick an address and an amount \n  /\\ \\E account \\in ADDRESSES, amount \\in  1 .. 100  :\n       \\* Non-deterministically choose to either deposit or withdraw \n      \\/ Deposit(account, amount)\n      \\/ Withdraw(account, amount)\n \n \n\n \nAgora podemos rodar:\n \n Abra o arquivo  bank.tla  e use F1 ou Ctrl+Shift+P para abrir o menu de comandos do VSCode \n Selecione a opção “TLA+: Check model with TLC” \n No prompt que aparece, substitua o valor por  -deadlock  e aperte Enter. Como introduzimos um deadlock na nossa especificação (ela não progride quando o saldo fica maior que 50), precisamos pedir pro TLC ignorar deadlocks, e por isso passamos a flag  -deadlock . \n \nEsse comando irá verificar todas as possíveis execuções, e deve retornar sucesso, o que significa que de fato consertamos o problema e não temos mais saldos negativos.\n \n \n         \n    ","url":"20240828153443-tla_getting_started.html"},{"title":"Seminário - Outros métodos formais","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Seminário - Outros métodos formais \n                  PDF  \n 1.  Informações importantes \n \n Data de apresentação: 05 e 07 de maio \n Trabalho individual ou em dupla \n Enviar slides no moodle (em PDF) \n Tempo de apresentação: 15 minutos (dupla) ou 10 minutos (individual) \n \n \n \n 2.  Introdução \n \n \nExiste uma variedade de técnicas e ferramentas de métodos formais, e seria inviável aprender várias delas nesta disciplina. O objetivo deste seminário é explorar superficialmente outras técinas/ferramentas para a compreensão dessa variedade e das possíveis alternativas.\n \n \n \n \n 3.  Sugestões de Tópicos \n \n \nDentro da técnica de  model checking  que temos estudado, existem várias outras ferramentas (além de TLA+ e Quint):\n \n PlusCal (versão “imperativa” de TLA+) \n Alloy \n NuSMV \n Spin \n Redes de Petri \n PRISM \n P \n Mais na  lista do Wikipedia \n \nUma técnica que já mencionamos na disciplina algumas vezes é a de assistentes de provas. Seguem algumas ferramentas:\n \n Coq \n Isabelle \n Agda \n Lean (brasileiro!) \n Idris \n Dafny \n F* \n Mais na  lista do Wikipedia \n \nFerramentas para verificação de programas escritos em linguagens de programação:\n \n Dafny \n Viper \n Prusti (para Rust) \n Gobra (para Go) \n Nagini (para Python) \n \nOutras técnicas (além de  model checking  e assistentes de provas):\n \n Máquina de estado abstrata ( Abstract State Machine  - ASM) \n Calculo \\(\\pi\\) (π-calculus) \n Continuation Passing Style  (CSP) \n Lógica de Hoare \n Método de desenvolvimento Viena ( Vienna Development Method  - VDM) \n \n \n \n 4.  Estrutura \n \n \nO enfoque da apresentação deve ser a técnica/ferramenta em si: como usá-la, para que é boa, para que é ruim, em que(ais) área(s) é mais aplicada. Desejável: casos de uso (i.e. empresa X usou pra verificar Y). Indesejável: Detalhes históricos.\n \n Mostre ao menos um exemplo (código/fórmula) \n \n \n\n             \n         \n    ","url":"20240531080208-mfo_seminario.html"},{"title":"Exercícios para a prova","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Exercícios para a prova \n                  Table of Contents \n \n Estruturas de Kripke \n Questão 1 \n Questão 2 \n \n Lógica temporal \n Questão 3 \n Questão 4 \n \n Propriedades e Suposições \n Questão 5 \n Questão 6 \n Questão 7 \n \n Perguntas gerais \n Questão 8 \n \n TLA+ e Quint \n Questão 9 \n Especificação A \n Especificação B \n \n Questão 10 \n Questão 11 \n Questão 12 \n \n \n \n Estruturas de Kripke \n \n \n \n Questão 1 \n \n \nIdentifique em quais estruturas de Kripke a seguir tem não-determinismo e  justifique sua resposta .\n \n \nSemáforos. Considere o conjunto de estados inicial \\(I = \\{vermelho\\}\\)\n \n\n  [Resposta] \nDeterminístico (não há não-determinismo), porque existe somente um estado inicial e, para cada um dos três estados, há apenas uma possível transição.\n \n \n\n \nChaleira. Considere o conjunto de estados inicial \\(I = \\{temperatura\\_ambiente\\}\\)\n \n\n  [Resposta] \nNão-determinístico (há não-determinismo), porque, para os estados “esquentando” e “esfriando”, há mais de uma transição possível.\n \n \n \n \n \n Questão 2 \n \n \nDefina uma estrutura de Kripke para um sistema de caixa da água com as seguintes características:\n \n A caixa da água contém uma bóia que impede que ela transborde, ou seja, a bóia interrompe o enchimento quando a caixa está completamente cheia. \n A caixa não enche enquanto está sendo usada, ou seja, ela não pode estar enchendo e esvaziando ao mesmo tempo. \n Se a caixa está vazia, ela não pode ser esvaziada. \n O sistema inicia com a caixa vazia \n \nPS: Tente usar o mínimo de estados e transições necessários para representar esse sistema.\n \n [Resposta] \\(S = \\{vazia, enchendo, cheia, esvaziando\\}\\) \n \\(\\rightarrow = \\{vazia \\rightarrow enchendo, enchendo \\rightarrow esvaziando, enchendo \\rightarrow cheia, cheia \\rightarrow esvaziando, esvaziando \\rightarrow enchendo, esvaziando \\rightarrow vazia\\}\\) \n \\(I = \\{vazia\\}\\) \n \n \n \n \n Lógica temporal \n \n \n \n Questão 3 \n \n \nDada uma fórmula temporal e uma execução, indique se a fórmula é verdadeira ou falsa para a execução. Ou seja, responda verdadeiro se a execução satisfaz a fórmula e falso caso não satisfaça. Considere que \\(a\\) e \\(b\\) são proposições.\n \n\n Fórmula: \\(X(b)\\)\n [ ]  \\([b], [b], [a]\\) \n [ ]  \\([a], [b], [a]\\) \n [ ]  \\([a], [a], [b]\\) \n \n Fórmula: \\(a -> b\\)\n [ ]  \\([a], [a], [a]\\) \n [ ]  \\([a], [b], [a]\\) \n [ ]  \\([a, b], [a], [a]\\) \n [ ]  \\([b], [a], [a]\\) \n \n Fórmula: \\(F(a)\\)\n [ ]  \\([a], [a], [a]\\) \n [ ]  \\([b], [a], [b]\\) \n \n [Resposta] Fórmula: \\(X(b)\\)\n [V] \\([b], [b], [a]\\) \n [V] \\([a], [b], [a]\\) \n [F] \\([a], [a], [b]\\) \n \n Fórmula: \\(a -> b\\)\n [F] \\([a], [a], [a]\\) \n [F] \\([a], [b], [a]\\) \n [V] \\([a, b], [a], [a]\\) \n [V] \\([b], [a], [a]\\) \n \n Fórmula: \\(F(a)\\)\n [V] \\([a], [a], [a]\\) \n [V] \\([b], [a], [b]\\) \n \n \n \n \n Questão 4 \n \n \nExplique a diferença entre LTL (Lógica Temporal Linear) e CTL (Lógica de árvore computacional -  Computational Tree Logic ).\n \n [Resposta] \nA representação de árvore da CTL permite que usemos quantificações existenciais com nossas fórmulas temporais: existe alguma execução onde eventualmente X. Já na LTL, todas as fórmulas são implicitamente universalmente quantificadas, e isso não é possível. Essa diferença faz com que existam fórmulas na LTL que não podem ser espressadas em CTL e fórmulas na CTL que não podem ser espressadas na LTL.\n \n \n \n \n \n Propriedades e Suposições \n \n \n \n Questão 5 \n \n \nAssinale as fórmulas abaixo com [V] (verdadeiro) se a propriedade pode ser espressa com uma invariante ou [F] (falso) caso seja preciso uma fórmua temporal. Lembre-se que não importa se a fórmula é verdadeira ou falsa.\n \n [ ]  Para cada compra no cartão de crédito, vem uma cobrança na fatura ao final do mês. \n [ ]  Nunca vou para a academia sem meus fones de ouvido \n [ ]  Em algum momento vou terminar de pagar as parcelas do meu apartamento \n [ ]  Sempre uso óculos para dirigir \n [ ]  Não é possível estar na aula e no shopping ao mesmo tempo \n [ ]  Todos os códigos em C++ serão migrados para Rust \n [Resposta] [F] Para cada compra no cartão de crédito, vem uma cobrança na fatura ao final do mês. \n [V] Nunca vou para a academia sem meus fones de ouvido \n [F] Em algum momento vou terminar de pagar as parcelas do meu apartamento \n [V] Sempre uso óculos para dirigir \n [V] Não é possível estar na aula e no shopping ao mesmo tempo \n [F] Todos os códigos em C++ serão migrados para Rust \n \n \n \n Questão 6 \n \n \nLeia a contextualização e responda:\n \n \n \nEstou vendendo peças de computador e contrato uma transportadora para fazer as entregas. Essas peças são frágeis, e podem quebrar se não forem transportadas de maneira adequada. A caixa não pode ser virada (a mesma face deve permanecer para cima durante todo o transporte), e não pode se mover no baú do caminhão. Para ter certeza de que a transportadora está fazendo seu serviço corretamente, instalei câmeras internas nos baús dos caminhões que me enviam fotos a cada 5 minutos. Agora, só preciso analisar essas fotos e determinar se a transportadora cumpre os requisitos.\n \n \n\n \nConsiderando uma execução dada pela sequência de fotos enviadas, escreva propriedades de segurança e vivacidade que digam sobre a qualidade do serviço da transportadora. Informe o tipo (invariante/temporal e segurança/vivacidade) de cada propriedade. Liste também que tipo de suposições estão sendo feitas para viabilizar essa análise.\n \n\n [Resposta] \nPropriedades:\n \n Invariante de segurança: a face de cima da caixa está para cima \n Temporal de segurança: sempre (a posição da caixa no próximo estado é a mesma que no estado atual ou ela é retirada pra entrega) \n Temporal de vivacidade: eventualmente a caixa é retirada para entrega \n \nSuposições:\n \n é possível determinar a posição da caixa em cada foto \n é possível determinar se a face correta da caixa está pra cima \n se a caixa for retirada, é por conta de uma entrega \n \n \n \n Questão 7 \n \n \nAlice e Bob estavam combinando de se encontrar e Alice mandou a seguinte mensagem para Bob: “Encontre-me as 15h na cafeteria Café Quentinho”. Ao fazer essa comunicação, Alice estava supondo algumas coisas. Descreva qual suposição de Alice estava errada para cada um dos cenários a seguir.\n \n \nBob não apareceu. A bateria do celular dele acabou antes que visse a mensagem de Alice.\nResponda: Alice assumiu que …\n \n [Resposta] \nAlice assumiu que Bob havia recebido a mensagem dela.\n \n \n \nBob foi em outro Café Quentinho - acontece que havia outra cafeteria com esse nome em outro bairro.\nResponda: Alice assumiu que …\n \n [Resposta] \nAlice assumiu que havia apenas uma “Café Quentinho” na cidade\n \n \n \nQuando Alice chegou, o Bob já estava lá por uma hora. Ele havia esquecido de ajustar seu relógio no fim do horário de verão.\nResponda: Alice assumiu que …\n \n [Resposta] \nAlice assumiu que o relógio de Bob estava no mesmo horário que o dela.\n \n \n \n \n \n \n Perguntas gerais \n \n \n \n Questão 8 \n \n \nSuponha que temos um modelo e uma propriedade que é violada numa execução de 5 passos. Considere que estamos usando um simulador aleatório com até 10.000 amostras e 10 passos, e um  model checker  com até 10 passos. Assinale com verdadeiro ou falso  e justifque sua resposta .\n \n [ ]  O simulador irá encontar um contraexemplo para propriedades \n [ ]  O  model checker  encontrará um contraexemplo de 5 passos \n [ ]  O  model checker  demorará mais tempo que o simulador para responder \n [ ]  O simulador demorará mais tempo que o  model checker  para responder \n [ ]  O  model checker  poderá finalizar a execução sem encontrar o contraexemplo \n [ ]  O simulador pode encontrar um contraexemplo de 9 passos \n [Resposta] [F] O simulador irá encontar um contraexemplo para propriedades \n [V] O  model checker  encontrará um contraexemplo de 5 passos \n [F] O  model checker  demorará mais tempo que o simulador para responder \n [F] O simulador demorará mais tempo que o  model checker  para responder \n [F] O  model checker  poderá finalizar a execução sem encontrar o contraexemplo \n [V] O simulador pode encontrar um contraexemplo de 9 passos \n \n \n \n \n TLA+ e Quint \n \n \n \n Questão 9 \n \n \nDada uma especificação simples, escreva uma breve descrição do que ela faz. Observe o seguinte exemplo:\nQuint:\n \n \n var  x:  int \n\n action  init = x' = 0\n\n action  step = x' =  if  (x < 10) x + 1  else  x\n \n \n\n \nTLA+:\n \n \n VARIABLE  x\n\nInit == x =  0 \n\nNext == x' =  IF  (x <  10 )  THEN  x +  1   ELSE  x\n \n \n\n \nPoderíamos descrever como: Um modelo onde x começa em zero e é incrementado até chegar a 10, com incrementos de tamanho 1. Ao chegar a 10, x permanece com o mesmo valor pra sempre\n \n\n \nAgora, responda com uma descrição para cada especificação abaixo:\n \n \n \n Especificação A \n \n \nQuint:\n \n \n var  x:  int \n\n action  init = x' = 0\n\n action  step =  any  {\n   all  {\n    x < 5,\n    x' = x + 1\n  },\n   all  {\n    x > -5,\n    x' = x - 1\n  }\n}\n \n \n\n \nTLA+\n \n \n VARIABLE  x\n\nInit == x =  0 \n\nNext ==\n  \\/ /\\ x <  5 \n     /\\ x' = x +  1 \n  \\/ /\\ x > -5\n     /\\ x' = x -  1 \n\n \n \n\n [Resposta] \nUm modelo onde x começa em zero e pode ser incrementado em 1 caso seja menor que 5, ou decrementado em 1 caso seja maior que -5. Ou seja, a cada passo x terá seu valor modificado (mais um ou menos um) e permanecerá sempre entre -5 e 5.\n \n \n \n \n Especificação B \n \n \nQuint:\n \n \n var  x:  int \n\n action  init = x' = 1\n\n action  step = {\n   nondet  v = 1.to(10).oneOf()\n   all  {\n    x != v,\n    x' = v\n  }\n}\n \n \n\n \nTLA+:\n \n \n VARIABLE  x\n\nInit == x =  1 \n\nNext == \\E v \\in  1 .. 10 :\n  /\\ x /= v\n  /\\ x' = v\n \n \n\n [Resposta] \nUm modelo onde x começa em 1 e a cada passo recebe um novo valor, diferente do atual, entre 1 e 10.\n \n \n \n \n \n Questão 10 \n \n \nConsidere o modelo a seguir:\n \n\n \nQuint:\n \n \n var  x:  int \n\n action  init = x' = 10\n\n action  step =  any  {\n   all  {\n    x < 20,\n    x % 2 == 0,\n    x' = x + 3\n  },\n   all  {\n    x > 5,\n    x' = x - 1\n  }\n}\n \n \n\n \nTLA+:\n \n \n VARIABLE  x\n\nInit == x =  10 \n\nNext ==\n  \\/ /\\ x <  20 \n     /\\ x %  2  =  0 \n     /\\ x' = x +  3 \n  \\/ /\\ x >  5 \n     /\\ x' = x -  1 \n \n \n\n \nPara cada execução a seguir, assinale verdadeiro se o modelo permite a execução e falso caso contrário. Quando responder falso,  justifique sua resposta .\n \n [ ]   x: 7, x: 6, x: 9, x: 8 \n [ ]   x: 10, x: 13, x: 12, x: 11, x: 10 \n [ ]   x: 10, x: 9, x: 8, x: 11 \n [ ]   x: 10, x: 9, x: 12, x: 15 \n [Resposta] [F]  x: 7, x: 6, x: 9, x: 8 \n x não pode ser 7 no estado inicial. Deve ser 10. \n \n [V]  x: 10, x: 13, x: 12, x: 11, x: 10 \n [V]  x: 10, x: 9, x: 8, x: 11 \n [F]  x: 10, x: 9, x: 12, x: 15 \n não podemos somar 3 ao 9 para chegar em 12, porque uma das pré-condições para somar 3 é que x seja divisível por 2, e 9 não é. \n \n \n \n \n Questão 11 \n \n \nO operador primed ( ' ) permite que escrevamos predicados sobre o próximo estado. Assinale verdadeiro se o operador primed está sendo usado corretamente, ou falso se o uso resultará em um erro. Caso responder falso,  justifique sua resposta . Considere que x e y são variáveis. As respostas para Quint ou TLA+ são as mesmas, responda apenas uma delas.\n \n\n \nQuint:\n \n [ ]   all { x' = 1, x' = 2 } \n [ ]   any { x' = 1, x' = 2 } \n [ ]   all { x' = 1, y' = 2 } \n [ ]   any { x' = 1, y' = 2 } \n \nTLA+:\n \n [ ]   x' = 1 /\\ x' = 2 \n [ ]   x' = 1 \\/ x' = 2 \n [ ]   x' = 1 /\\ y' = 2 \n [ ]   x' = 1 \\/ y' = 2 \n [Resposta] \nQuint:\n \n [F]  all { x' = 1, x' = 2 } \n x é atualizado duas vezes na mesma ação \n \n [V]  any { x' = 1, x' = 2 } \n [V]  all { x' = 1, y' = 2 } \n [F]  any { x' = 1, y' = 2 } \n atualização desbalanceada: em uma das ramificações apenas x é atualizado, e em outra apenas y \n \n \nTLA+:\n \n [F]  x' = 1 /\\ x' = 2 \n x é atualizado duas vezes na mesma ação \n \n [V]  x' = 1 \\/ x' = 2 \n [V]  x' = 1 /\\ y' = 2 \n [F]  x' = 1 \\/ y' = 2 \n atualização desbalanceada: em uma das ramificações apenas x é atualizado, e em outra apenas y \n \n \n \n \n Questão 12 \n \n \nAgora escreva a propriedade em Quint ou em TLA+ para:\n \n\n “Não é possível estar na aula e no shopping ao mesmo tempo”. Considere que existam duas variáveis de estado do tipo  bool :  na_aula  e  no_shopping . \n “Sempre uso óculos para dirigir”. Considere que existam duas variáveis de estado do tipo  bool :  estou_dirigindo  e  estou_de_oculos . \n “Em algum momento vou terminar de pagar as parcelas do meu apartamento”. Considere que exista uma variável de estado do tipo  int  para o número restante de parcelas:  parcelas_restantes . \n “Todos os códigos em C++ serão migrados para Rust”. Considere que exista uma variável  codigos  do tipo  int -> { codigo: str, linguagem: str }  sendo a chave (domínio) um identificador único daquele código e o campo  linguagem  pode conter  \"c++\" ,  \"haskell\"  ou  \"rust\" . \n [Resposta] not(na_aula) or not(no_shopping) \n estou_dirigindo implies estou_de_oculos \n eventually(parcelas_restantes == 0) \n codigos.keys().forall(k => codigos.get(k).linguagem ==  \"c++\"   implies  eventually(codigos.get(k).linguagem ==  \"rust\" )) \n \n \n \n\n             \n         \n    ","url":"20240525134648-mfo_exercicios_para_a_prova.html"},{"title":"Exercícios Pokemon","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Exercícios Pokemon \n                  PDF  Especificações base \n\n \nOs exercícios a seguir podem ser feitos em TLA+ ou em Quint. Faça download (moodle) da especificação base que deseja usar (TLA+ ou Quint) e modifique-a conforme os exercícios pedem.\n \n\n Na especificação base, ao examinar uma execução, é um pouco difícil entender o que aconteceu de um estado pra outro. Introduza uma variável que, a cada estado, grave qual foi o último ataque feito, de forma a facilitar a compreensão de uma execução.\n em Quint, sem tipo soma:  { attacker: Pokemon, receiver: Pokemon, attack: str, damage: int } \n Neste caso, você vai precisar inventar valores arbitrários para essa variável no estado inicial \n \n em Quint, com tipo soma:  Option[{ attacker: Pokemon, receiver: Pokemon, attack: str, damage: int }] \n O tipo  Option  é definido por  Option[a] = Some(a) | None \n Neste caso, o valor da variável pode ser  None  no estado inicial, e  Some(...)  nos demais estados. \n \n em TLA+, sem tipo. Pode ter valor  \"\"  no estado inicial. \n \n\n Pokemons com uma vantagem elemental tem mais changes de ganhar. Contudo, TLA+ e Quint não trabalham com estatísticas, e só conseguimos tirar conclusões do tipo “A sempre ganha de B” ou “A nunca ganha de B”. Para ajudar com isso, não estamos especificando a chance de um ataque acertar. Mesmo assim, na especificação base, a vantagem elemental não garante que o pokemon vença a batalha.\n Escreva uma invariante dizendo que um pokemon do tipo fogo sempre ganha de um pokemon do tipo grama.\n Ao verificar/simular essa invariante, você deve encontrar um contraexemplo. Examine esse contraexemplo e responda: Em que cenário é possível que um pokemon do tipo grama vença um pokemon do tipo fogo? \n \n Agora, implemente uma estratégia (semelhante ao que fizemos no jogo da velha) para que essa invariante seja satisfeita.\n A estratégia é bem simples: quando o pokemon tiver vantagem elemental, ele deve usar o ataque elemental. \n \n \n\n Adicione um novo pokemon do tipo elétrico conforme a tabela de modificadores de dano a seguir \n \n  \n \n\n             \n         \n    ","url":"20240415205323-mfo_exercicios_pokemon.html"},{"title":"Primeiras Especificações em TLA+","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Primeiras Especificações em TLA+ \n                  Slides  \n Table of Contents \n \n 1. Correção exercícios \n 1.1. Correção dos exercícios \n \n 2. Modelos em TLA+ \n 2.1. Modelos em TLA+ \n \n 3. Semáforos \n 3.1. Especificação para os semáforos \n 3.2. Estado inicial \n 3.3. Próximo semáforo fica verde \n 3.4. Próximo semáforo fica verde: Exercício \n 3.5. Próximo semáforo fica verde: Exercício \n 3.6. Um semáforo que está verde fica amarelo \n 3.7. Um semáforo que está amarelo fica vermelho \n 3.8. Função de próximo estado \n 3.9. Propriedades \n \n 4. Jogo da Velha \n 4.1. Jogo da Velha em TLA+ \n 4.2. Módulo \n 4.3.  Tipos e  variáveis \n 4.4. Definições sobre coordenadas e tabuleiro \n 4.5. Definindo “ganhar” - coordenadas \n 4.6. Definindo “ganhar” - operador won \n 4.7. Ações - Move \n 4.8. Ações - MoveToEmpty \n 4.9. Ações - MoveO \n 4.10. Estratégia para o jogador X \n 4.11. Começando com os cantos \n 4.12. Condições para as jogadas \n 4.13. Ações - Win \n 4.14. Ações - BlockWin \n 4.15. Ações - TakeCenter e SetupWin \n 4.16. Ações - MoveX \n 4.17. Estado inicial \n 4.18. Transições \n 4.19. Invariantes \n 4.20. Referências \n \n \n \n \n 1.  Correção exercícios \n \n \n \n 1.1.  Correção dos exercícios \n \n \nVamos corrigir juntos no VSCode.  \n\n Mostrar em PDF  \n \n \n \n \n 2.  Modelos em TLA+ \n \n \n \n 2.1.  Modelos em TLA+ \n \n \nAté agora, vimos principalmente a parte funcional da linguagem.  \n Diferente de Quint, não temos operadores exclusivos para ações. Ações são bem parecidas com a parte funcional.  \n Podemos identificar ações pelo operador  primed  ( '  ), e pelo  UNCHANGED  \n \n Estado inicial:  \n Em Quint, o estado inicial é uma ação (como  x' = 0 )  \n Em TLA+, o estado inicial é um predicado (como  x = 0 , que em Quint seria  x==0 ).  Lemos como “Um estado é um estado inicial sse satisfaz \\(Init\\)”  \n \n \n \n \n \n 3.  Semáforos \n \n \n \n 3.1.  Especificação para os semáforos \n \n \n -----  MODULE  Semaforos ------\n EXTENDS  Integers, FiniteSets\n VARIABLE  cores, proximo\n CONSTANT  SEMAFOROS\n \\* ... \n=============================\n \n \n\n \nPS: Consultei a  gramática  de TLA+ e precisamos de pelo menos 4 hífens ( ----  ) antes e depois de  MODULE nome  e pelo menos 4 iguais ( ==== ) no final.  \n\n \n TLAPlusGrammar ==  \\* ... \n  G.Module ::= AtLeast4( \"-\" )\n    & tok( \"MODULE\" ) & Name & AtLeast4( \"-\" )\n    & (Nil | (tok( \"EXTENDS\" ) & CommaList(Name)))\n    & (G.Unit)^*\n    & AtLeast4( \"=\" )  \\* ... \n \n \n \n \n \n 3.2.  Estado inicial \n \n \n Init ==\n  /\\ cores = [s \\in SEMAFOROS |->  \"vermelho\" ]\n  /\\ proximo =  0 \n \n \n \n \n \n 3.3.  Próximo semáforo fica verde \n \n \n FicaVerde(s) ==\n  /\\ proximo = s\n  /\\ \\A s2 \\in SEMAFOROS : cores[s2] =  \"vermelho\" \n  /\\ cores' = [cores  EXCEPT  ![s] =  \"verde\" ]\n  /\\ proximo' = (s +  1 ) % Cardinality(SEMAFOROS)\n \n \n\n \nQual a pré-condição dessa ação?  \n \n /\\ proximo = s\n/\\ \\A s2 \\in SEMAFOROS : cores[s2] =  \"vermelho\" \n \n \n \n \n \n 3.4.  Próximo semáforo fica verde: Exercício \n \n \n FicaVerde(s) ==\n  /\\ proximo = s\n  /\\ \\A s2 \\in SEMAFOROS : cores[s2] =  \"vermelho\" \n  /\\ cores' = [cores  EXCEPT  ![s] =  \"verde\" ]\n  /\\ proximo' = (s +  1 ) % Cardinality(SEMAFOROS)\n \n \n\n \n Lendo essa ação : tente prencher as lacunas  \n“ FicaVerde  para um semáforo  s  define uma transição onde, no estado atual,  __________  deve ser  __________  e  ___________  deve  _________ ; e no próximo estado,  _________  deve ser  _________  e  ___________  deve ser  ___________ ”  \n \n \n \n 3.5.  Próximo semáforo fica verde: Exercício \n \n \n FicaVerde(s) ==\n  /\\ proximo = s\n  /\\ \\A s2 \\in SEMAFOROS : cores[s2] =  \"vermelho\" \n  /\\ cores' = [cores  EXCEPT  ![s] =  \"verde\" ]\n  /\\ proximo' = (s +  1 ) % Cardinality(SEMAFOROS)\n \n \n\n \n Possível resolução:  \n“ FicaVerde  para um semáforo  s  define uma transição onde, no estado atual,  o valor de proximo  deve ser  igual ao semáforo s  e  o valor de cores para cada semáforo em SEMAFOROS  deve ser vermelho; e no próximo estado,  o valor de cores  deve ser  igual a cores no estado atual, exceto que o valor de s deve ser verde  e  o valor de proximo  deve ser  o incremento do valor no estado atual módulo o tamanho do conjunto SEMAFOROS ”.  \n \n \n \n 3.6.  Um semáforo que está verde fica amarelo \n \n \n FicaAmarelo(s) ==\n  /\\ cores[s] =  \"verde\" \n  /\\ cores' = [cores  EXCEPT  ![s] =  \"amarelo\" ]\n  /\\  UNCHANGED  << proximo >>\n \n \n \nQual a pré-condição dessa ação?  \n \n cores[s] =  \"verde\" \n \n \n \n \n \n 3.7.  Um semáforo que está amarelo fica vermelho \n \n \n FicaVermelho(s) ==\n  /\\ cores[s] =  \"amarelo\" \n  /\\ cores' = [cores  EXCEPT  ![s] =  \"vermelho\" ]\n  /\\  UNCHANGED  << proximo >>\n \n \n \nQual a pré-condição dessa ação?  \n \n cores[s] =  \"amarelo\" \n \n \n \n \n \n 3.8.  Função de próximo estado \n \n \n Next == \\E s \\in SEMAFOROS : FicaVerde(s) \\/ FicaAmarelo(s) \\/ FicaVermelho(s)\n \n \n\n \nLembrando que TLA+ permite usarmos ações dentro de um  exists , diferentemente de Quint onde é necessário usar o  nondet  e  oneOf .  \n \n \n \n 3.9.  Propriedades \n \n \nUma invariante para check de sanidade:  \n \n Inv == cores[ 2 ] /=  \"amarelo\" \n \n \n\n \nUma propriedade do sistema: para que os veículos não colidam, não podemos ter mais de um semáforo aberto ao mesmo tempo.  \n \n SemColisao == Cardinality({s \\in SEMAFOROS : cores[s] =  \"verde\" }) <=  1 \n \n \n \n \n \n \n 4.  Jogo da Velha \n \n \n \n 4.1.  Jogo da Velha em TLA+ \n \n \nVamos ver a mesma especificação do jogo da velha, agora em TLA+  \n Vamos direto pra versão onde o jogador X usa estratégia  \n Vou usar a versão original do autor ( SWART, 2022 )  A especificação em Quint é baseada nesta, mas não é uma tradução direta. Poderíamos escrever a tradução mais próxima possível, mas não é esse o caso. Eu escrevi como achei que seria melhor, dado os recursos da linguagem.  \n \n \n \n \n 4.2.  Módulo \n \n \n --------  MODULE  tictactoexwin ---------\n\n EXTENDS  Naturals\n\n \\* ... \n\n=======================================\n \n \n \n \n \n 4.3.   Tipos e  variáveis \n \n \nDefinimos as seguintes variáveis  \n \n VARIABLES \n  board,  \\* board[1..3][1..3] A 3x3 tic-tac-toe board \n  nextTurn  \\* who goes next \n \n \n \n \n \n 4.4.  Definições sobre coordenadas e tabuleiro \n \n \n BoardIs(coordinate, player) ==\n    board[coordinate[ 1 ]][coordinate[ 2 ]] = player\n\nBoardFilled ==\n     \\* There does not exist \n    ~\\E i \\in  1 .. 3 , j \\in  1 .. 3 :\n         \\* an empty space \n         LET  space == board[i][j]  IN \n        space =  \"_\" \n\nBoardEmpty ==\n     \\* There does not exist \n    \\A i \\in  1 .. 3 , j \\in  1 .. 3 :\n         \\* an empty space \n         LET  space == board[i][j]  IN \n        space =  \"_\" \n \n \n \n \n \n 4.5.  Definindo “ganhar” - coordenadas \n \n Como o tabuleiro é sempre 3x3, é mais fácil listar todas as combinações de coordenadas que levam a uma vitória do que implementar os cálculos.  \n Usamos tuplas! Na implementação em Quint, usamos  filter  e  size  para ver se um  pattern  tinha dois X e um branco, um X e dois brancos, etc. Aqui, o autor usa listas de permutação.  \n \n WinningPositions == {\n     \\* Horizonal wins \n    <<<<1,1>>, <<1,2>>, <<1,3>>>>,\n    <<<<2,1>>, <<2,2>>, <<2,3>>>>,\n    <<<<3,1>>, <<3,2>>, <<3,3>>>>,\n     \\* Vertical wins \n    <<<<1,1>>, <<2,1>>, <<3,1>>>>,\n    <<<<1,2>>, <<2,2>>, <<3,2>>>>,\n    <<<<1,3>>, <<2,3>>, <<3,3>>>>,\n     \\* Diagonal wins \n    <<<<1,1>>, <<2,2>>, <<3,3>>>>,\n    <<<<3,1>>, <<2,2>>, <<1,3>>>>\n}\n \n \n \n \n \n 4.6.  Definindo “ganhar” - operador won \n \n \nUsamos a definição  winningPositions  para determinar se um jogador venceu.  \n \n Won(player) ==\n     \\* A player has won if there exists a winning position \n    \\E winningPosition \\in WinningPositions:\n         \\* Where all the needed spaces \n        \\A i \\in  1 .. 3 :\n             \\* are occupied by one player \n            board[winningPosition[i][ 1 ]][winningPosition[i][ 2 ]] = player\n \n \n \n \n \n 4.7.  Ações - Move \n \n \nUm dado jogador faz uma jogada (um  move ) em uma dada coordenada  \n Determinístico  \n \n Move(player, coordinate) ==\n    /\\ board[coordinate[ 1 ]][coordinate[ 2 ]] =  \"_\" \n    /\\ board' = [board  EXCEPT \n                        ![coordinate[ 1 ]][coordinate[ 2 ]] = player]\n\n \n \n \nQual é a pré-condição pra essa ação?  \n A pré-condição para essa ação é que a coordenada esteja vazia  \n \n \n \n \n 4.8.  Ações - MoveToEmpty \n \n \nUm dado jogador faz uma jogada em  alguma  coordenada  \n Não-determinístico  \n \n MoveToEmpty(player) ==\n  /\\ \\E i \\in  1 .. 3 : \\E j \\in  1 .. 3 :  \\* There exists a position on the board \n    /\\ board[i][j] =  \"_\"   \\* Where the board is currently empty \n    /\\ Move(player, <<i,j>>)\n \n \n \nQual é a pré-condição pra essa ação?  \n A pré-condição para essa ação é que o jogo ainda não tenha acabado  \n \n \nAonde temos não determinismo aqui?  \n No uso da ação  Move , que atualiza a variável  board  dentro de um  exists  ( \\E ).  \n \n \n \n \n 4.9.  Ações - MoveO \n \n \n MoveO ==\n  /\\ nextTurn =  \"O\"   \\* Only enabled on O's turn \n  /\\ ~Won( \"X\" )  \\* And X has not won \n  /\\ MoveToEmpty( \"O\" )  \\* O still tries every empty space \n  /\\ nextTurn' =  \"X\"   \\* The future state of next turn is X \n \n \n\n \nQual é a pré-condição pra essa ação?  \n \n     /\\ nextTurn =  \"O\"   \\* Only enabled on O's turn \n    /\\ ~Won( \"X\" )  \\* And X has not won \n \n \n Implicitamente, também temos a pré-condição de  MoveToEmpty  empregada nessa ação  \n \n \n \n \n 4.10.  Estratégia para o jogador X \n \n \n Estratégia :  \n A primeira jogada é sempre nos cantos  \n As outras jogadas fazem a primeira jogada possível nessa lista de prioridade:  Ganhar  \n Bloquear  \n Jogar no centro  \n Preparar uma vitória (preenchendo 2 de 3 quadrados numa fila/coluna/diagonal)  \n Jogada qualquer  \n \n \n \n \n 4.11.  Começando com os cantos \n \n \n Corners == {\n    <<1,1>>,\n    <<3,1>>,\n    <<1,3>>,\n    <<3,3>>\n}\n\nStartInCorner ==\n    \\E corner \\in Corners:\n        Move( \"X\" , corner)\n \n \n \n \n \n 4.12.  Condições para as jogadas \n \n \nPrecisamos definir as condições que determinam se cada uma das jogadas na lista de prioridade pode ser feita.  \n \nPara isso, nessa especificação, definimos as permutações, e fazemos um nível a mais de interação (com  exists ), verificando, para cada  winningPosition  e para cada permutação, se aquela permutação da  winningPosition  é uma ordem específica do que queremos (X, X, e vazio).  \n \n PartialWins == {\n    <<1, 2 ,3>>,\n    <<2, 3 ,1>>,\n    <<3, 1 ,2>>\n}\n \n \n\n \n CanWin == \\E winningPostion \\in WinningPositions, partialWin \\in PartialWins:\n  /\\ BoardIs(winningPostion[partialWin[ 1 ]], \"X\" )\n  /\\ BoardIs(winningPostion[partialWin[ 2 ]], \"X\" )\n  /\\ BoardIs(winningPostion[partialWin[ 3 ]], \"_\" )\n\nCanBlockWin == \\E winningPostion \\in WinningPositions, partialWin \\in PartialWins:\n  /\\ BoardIs(winningPostion[partialWin[ 1 ]],  \"O\" )\n  /\\ BoardIs(winningPostion[partialWin[ 2 ]],  \"O\" )\n  /\\ BoardIs(winningPostion[partialWin[ 3 ]],  \"_\" )\n\n \n \n\n \n CanTakeCenter == board[ 2 ][ 2 ] =  \"_\" \n\nCanSetupWin == \\E winningPostion \\in WinningPositions, partialWin \\in PartialWins:\n  /\\ BoardIs(winningPostion[partialWin[ 1 ]],  \"X\" )\n  /\\ BoardIs(winningPostion[partialWin[ 2 ]],  \"_\" )\n  /\\ BoardIs(winningPostion[partialWin[ 3 ]],  \"_\" )\n \n \n \n \n \n 4.13.  Ações - Win \n \n \n Win == \\E winningPostion \\in WinningPositions, partialWin \\in PartialWins:\n  /\\ BoardIs(winningPostion[partialWin[ 1 ]], \"X\" )\n  /\\ BoardIs(winningPostion[partialWin[ 2 ]], \"X\" )\n  /\\ BoardIs(winningPostion[partialWin[ 3 ]], \"_\" )\n  /\\ Move( \"X\" , winningPostion[partialWin[ 3 ]])\n \n \n\n Qual é a pré-condição pra essa ação?  \n \n \\E winningPostion \\in WinningPositions, partialWin \\in PartialWins:\n  /\\ BoardIs(winningPostion[partialWin[ 1 ]], \"X\" )\n  /\\ BoardIs(winningPostion[partialWin[ 2 ]], \"X\" )\n  /\\ BoardIs(winningPostion[partialWin[ 3 ]], \"_\" )\n\n \n \n Percebam que essa pré condição é exatamente  CanWin  \n Porém, não conseguimos usar  CanWin  aqui porque precisamos saber em qual posição jogar.  \n \n \n \n 4.14.  Ações - BlockWin \n \n \nDe forma semelhante,  BlockWin :  \n \n BlockWin == \\E winningPostion \\in WinningPositions, partialWin \\in PartialWins:\n  /\\ BoardIs(winningPostion[partialWin[ 1 ]],  \"O\" )\n  /\\ BoardIs(winningPostion[partialWin[ 2 ]],  \"O\" )\n  /\\ BoardIs(winningPostion[partialWin[ 3 ]],  \"_\" )\n  /\\ Move( \"X\" , winningPostion[partialWin[ 3 ]])\n \n \n \n \n \n 4.15.  Ações - TakeCenter e SetupWin \n \n \n TakeCenter ==\n    /\\ Move( \"X\" , <<2,2>>)\n\nSetupWin == \\E winningPostion \\in WinningPositions, partialWin \\in PartialWins:\n  /\\ BoardIs(winningPostion[partialWin[ 1 ]],  \"X\" )\n  /\\ BoardIs(winningPostion[partialWin[ 2 ]],  \"_\" )\n  /\\ BoardIs(winningPostion[partialWin[ 3 ]],  \"_\" )\n  /\\ \\E i \\in  2 .. 3 :\n    Move( \"X\" , winningPostion[partialWin[i]])\n \n \n \n \n \n 4.16.  Ações - MoveX \n \n \n MoveX ==\n    /\\ nextTurn =  \"X\"   \\* Only enabled on X's turn \n    /\\ ~Won( \"O\" )  \\* And X has not won \n     \\* This specifies the spots X will move on X's turn \n    /\\ \\/ /\\ BoardEmpty\n          /\\ StartInCorner\n       \\/ /\\ ~BoardEmpty  \\* If its not the start \n          /\\ \\/ /\\ CanWin\n                /\\ Win\n             \\/ /\\ ~CanWin\n                /\\  \\/ /\\ CanBlockWin\n                       /\\ BlockWin\n                    \\/ /\\ ~CanBlockWin\n                       /\\ \\/ /\\ CanTakeCenter\n                             /\\ TakeCenter\n                          \\/ /\\ ~CanTakeCenter\n                             /\\ \\/ /\\ CanSetupWin\n                                   /\\ SetupWin\n                                \\/ /\\ ~CanSetupWin\n                                  /\\ MoveToEmpty( \"X\" )  \\* No more strategies. Pick spot \n    /\\ nextTurn' =  \"O\"   \\* The future state of next turn is O \n \n \n \n \n \n 4.17.  Estado inicial \n \n \n Init ==\n  /\\ nextTurn =  \"X\"   \\* X always goes first \n   \\* Every space in the board states blank \n  /\\ board = [i \\in  1 .. 3  |-> [j \\in  1 .. 3  |->  \"_\" ]]\n \n \n \n \n \n 4.18.  Transições \n \n \n GameOver == Won( \"X\" ) /\\ Won( \"O\" ) /\\ BoardFilled\n\n \\* Every state, X will move if X's turn, O will move on O's turn \nNext == MoveX \\/ MoveO \\/ (GameOver /\\  UNCHANGED  << board, nextTurn >>)\n \n \n\n Nota: isso está um pouco diferente na especificação original, porque o autor usa a definição de  Spec  ao invés de somente  Init  e  Next .  \n \n \\* Every state, X will move if X's turn, O will move on O's turn \nNext == MoveX \\/ MoveO\n\n \\* A description of every possible game of tic-tac-toe \n \\* will play until the board fills up, even if someone won \nSpec == Init /\\ [][Next]_<<board,nextTurn>>\n \n \n \n \n \n 4.19.  Invariantes \n \n \n XHasNotWon == ~Won( \"X\" )\nOHasNotWon == ~Won( \"O\" )\n\n \\* It's not a stalemate if one player has won or the board is not filled \nNotStalemate ==\n    \\/ Won( \"X\" )\n    \\/ Won( \"O\" )\n    \\/ ~BoardFilled\n \n \n \n \n \n 4.20.  Referências \n \n \n    SWART, E.  Introduction to pragmatic formal modeling . Disponível em: < https://elliotswart.github.io/pragmaticformalmodeling/ >.  \n \n \n \n \n\n             \n         \n    ","url":"20240408201756-mfo_primeiras_especificacoes_em_tla.html"},{"title":"Introdução ao TLA+","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Introdução ao TLA+ \n                  Slides  \n Table of Contents \n \n 1. Quint -> TLA+ \n 1.1. Quint -> TLA+ \n 1.2. Tipos \n 1.3. TLA+ REPL \n 1.4. TLA+ REPL em qualquer terminal \n 1.5. Constantes e variáveis \n 1.6. Instanciando módulos \n 1.7. Imports \n 1.8. Literais \n 1.9. Lambdas (Operadores Anônimos) \n 1.10. LET … IN … \n 1.11. Conjunção e Disjunção \n 1.12. Condicional \n 1.13. Sets! \n 1.14. Operadores sobre sets \n 1.15. Não-determinismo \n 1.16. Exercícios Sets \n 1.17. Maps \n 1.18. Maps - construtor \n 1.19. Maps - construtor como em Quint \n 1.20. Maps - acesso \n 1.21. Operadores sobre Maps \n 1.22. Records \n 1.23. Listas (ou Sequências) \n 1.24. Tuplas \n 1.25. Unchanged \n 1.26. Folds \n 1.27. Exercícios Fold \n 1.28. Exercícios TLA+ \n \n \n \n \n 1.  Quint -> TLA+ \n \n \n \n 1.1.  Quint -> TLA+ \n \n \nJá aprendemos Quint, então vamos ver TLA+ pensando nas equivalencias com Quint.  \n O próprio  Manual do Quint  trás essas comparações entra TLA+ e Quint  \n \n \n \n 1.2.  Tipos \n \n \nTLA+ não tem tipos!  \n No TLC, erros de tipo serão detectados em runtime  Se seu modelo tiver  1 + \"bla\"  no sétimo estado da execução, o TLC só vai perceber o problema quando chegar nesse estado em sua exploração  \n \n No Apalache, é preciso traduzir o modelo para fórmulas SMT, que precisam ser tipadas  TLA+ para o Apalache é tipado  \n \nA linguagem em si não é tipada, mas o Apalache espera que os tipos sejam anotados nos comentários  \n \n      VARIABLES \n       \\* @type: Int -> Int; \n      clock,\n       \\* @type: Int -> (Int -> Int); \n      req,\n       \\* @type: Int -> Set(Int); \n      ack,\n \n \n Mais informações no  Manual do Apalache  Não vamos nos aprofundar nisso na disciplina!  \n \n \n \n \n \n 1.3.  TLA+ REPL \n \n O TLA+ tem uma REPL que só funciona para expressões constantes  Não podemos usar ela para definir variáveis e avaliar transições  \n \n Só está disponível na pre-release do TLA+, então  No VSCode, o novo plugin lançado já tem  \n No  .jar , precisamos da versão 1.8.0  \n \n \nAtenção para como faremos pra rodar ela nos computadores da UDESC:  \n No VSCode, baixar a extensão:  TLA+ (Temporal Logic of Actions)  \n Aperte F1 e escolha: TLA+: Run REPL in Terminal.  \n \n \n \n 1.4.  TLA+ REPL em qualquer terminal \n \n \nOpção 1 (com ou sem  sudo , somente UNIX):  \n https://github.com/pmer/tla-bin  \n \nInstalar:  \n \n    git  clone https://github.com/pmer/tla-bin.git\n   cd  tla-bin\n  sh download_or_update_tla.sh --nightly\n  sh install.sh ~/.local\n   #  ou, se tiver sudo: \n   sudo  install.sh\n \n \n \nExecutar:  \n \n    cd  ~/.local/bin\n  ./tlarepl\n \n \n \nOpção 2 (sem  sudo) :  \n Baixar o  tla2tools.jar  versão 1.8.0. Duas opções:  Do GitHub:  https://github.com/tlaplus/tlaplus/releases/download/v1.8.0/tla2tools.jar  \n Ou, se você já instalou a extensão do VSCode, esse arquivo já existe em  ~/.vscode/extensions/alygin.vscode-tlaplus-nightly-<versao>/tools/tla2tools.jar  \n \n Executar o  jar :  java -cp tla2tools.jar tlc2.REPL  \n \nOpção 3 (com  sudo ):  \n Seguir as instruções em  https://lamport.azurewebsites.net/tla/standalone-tools.html  \n Executar com  java tlc2.REPL  \n \n \n \n 1.5.  Constantes e variáveis \n \n \nEm Quint:  \n \n const  MY_CONST:  int \n\n var  x:  str \n var  y:  bool \n \n \n\n \nEm TLA+:  \n \n CONSTANT  MY_CONST\n VARIABLES  x, y\n \n \n\n \nTemos as palavras-chave:  CONSTANT ,  CONSTANTS ,  VARIABLE  e  VARIABLES .  \n \n \n \n 1.6.  Instanciando módulos \n \n \nLembram nos semáforos, quando tínhamos a constante  SEMAFOROS , e instanciávamos o módulo com:  \n \n module  semaforos_3 {\n   import  semaforos(SEMAFOROS=Set(0, 1, 2)).*\n}\n \n \n\n \nEm TLA+, usaríamos o  INSTANCE :  \n \n INSTANCE  semaforos  WITH  SEMAFOROS <- { 0 ,  1  , 2 }\n \n \n\n \nInclusive, em TLA+ podemos atribuir  variáveis  nas instâncias também, o que não é permitido em Quint.  \n\n \nPS: Constantes e Instâncias são um tanto complicadas. A utilização delas nos trabalhos da disciplina é totalmente opcional.  \n \n \n \n 1.7.  Imports \n \n \nEm Quint, tempos os imports  \n \n import  meu_modulo.*\n import  meu_modulo.minha_definicao\n import  meu_modulo  as  M\n \n \n\n \nEm TLA+  \n \n EXTENDS  meu_modulo\n \n \n\n \nInclusive, os interios não são  built-in  em TLA+. Temos que importar o módulo de inteiros com  \n \n EXTENDS  Integers\n \n \n \n \n \n 1.8.  Literais \n \n false  em Quint é  FALSE  em TLA+  \n true  em Quint é  TRUE  em TLA+  \n inteiros e strings são a mesma coisa  Divisão de inteiros é feita com  \\div  \n \n \n \n \n 1.9.  Lambdas (Operadores Anônimos) \n \n \nEm Quint, temos lambdas como o a seguir. Contudo (por hora), lambdas só podem ser usados como argumentos pra outros operadores, como para o  map  e  fold :  \n \n my_set.map(x => x + 1)\nmy_set.fold(0, (acc, i) => acc + i)\n \n \n\n \nEm TLA+, temos lambdas, de forma geral, como:  \n \n LAMBDA  x: x +  1 \n LAMBDA  x, y: x + y\n \n \n \n \n \n 1.10.  LET … IN … \n \n \nEm Quint, podemos declarar varios operadores seguidos de uma expressão:  \n \n pure   val  a = {\n   pure   val  b = 1\n   pure   val  c = b + 1\n  c + 1\n}\n \n \n\n \nEm TLA+, fazemos o semelhante com:  \n \n a ==  LET  b ==  1 \n         c == b +  1 \n       IN  c +  1 \n \n \n\n \nPercebam que usamos duplo  =   ( == ) para definições. Para o predicado de igualdade, usamos um único  = , diferente de linguagens de programação. Basicamente, o oposto de Quint.  \n \n \n \n 1.11.  Conjunção e Disjunção \n \n \n  Conjunção  \n \nConjunção em Quint:  \n \n pure   val  pred = a  and  b\n action  conj =  all  {\n  A,\n  B,\n  C,\n}\n \n \n\n \nConjunção em TLA+:  \n \n pred == a /\\ b\nconj ==\n   /\\ A\n   /\\ B\n   /\\ C\n \n \n \n \n  Disjunção  \n \nDisjunção em Quint:  \n \n pure   val  pred = a  or  b\n action  disj =  any  {\n  A,\n  B,\n  C,\n}\n \n \n\n \nDisjunção em TLA+:  \n \n pred == a \\/ b\nconj ==\n   \\/ A\n   \\/ B\n   \\/ C\n \n \n \n \n \n \n 1.12.  Condicional \n \n \nEm Quint:  \n \n pure   def  f(x) =  if  (x == 0) 10  else  20\n \n \n\n \nEm TLA+:  \n \n f(x) ==  IF  x =  0   THEN   10   ELSE   20 \n \n \n \n \n \n 1.13.  Sets! \n \n \nEm Quint:  \n \n Set (1, 2, 3)\n \n \n\n \nEm TLA+:  \n \n { 1 ,  2 ,  3 }\n \n \n \n \n \n 1.14.  Operadores sobre sets \n \n \nExiste e para todo:  \n \n \\E x \\in S: P  \\* S.exists(x => P) \n\\A x \\in S: P  \\* S.forall(x => P) \n \n \n\n \n map  e  filter :  \n \n { e: x \\in S }  \\* S.map(x => e) \n{ x \\in S: P }  \\* S.filter(x => P) \n \n \n \nPredicados:  \n \n e \\in S  \\* e.in(S) ou S.contains(e) \nS \\union T  \\* S.union(T) \nS \\intersect T  \\* S.intersect(T) \nS \\ T  \\* S.exclude(T) \nS \\subseteq T  \\* S.subseteq(T) \n \n \n\n \nOutros operadores:  \n \n SUBSET  S  \\* S.powerset() \n UNION  S  \\* S.flatten() \nCardinality(S)  \\* S.size() \na..b  \\* a.to(b) \n \n \n\n \nPS: Para usar  Cardinality , precisamos fazer  EXTENDS FiniteSets  \n \n \n \n 1.15.  Não-determinismo \n \n \nEm Quint:  \n \n nondet  name = my_set.oneOf()\nx' = name\n \n \n\n \nEm TLA+, é apenas um  exists  normal:  \n \n \\E name \\in my_set: x' = name\n \n \n\n \nLembrando que o equivalente ao  exists  ( my_set.exists(name => x' = name) ) não é permitido em Quint, pois não podemos usar  ações  como argumentos do  exists .  \n \n \n \n 1.16.  Exercícios Sets \n \n \nResolva usando os equivalentes a  map  e  filter  na REPL:  \n \nDado um conjunto de números, retorne um conjunto do quadrado desses números.  \n \n LET  quadrado(S) == resolucao  IN  quadrado({ 1 ,  2 ,  3 ,  4 })\n \n \n \nDado um conjunto de números, retorne um conjunto apenas com os números pares.  \n \n LET  pares(S) == resolucao  IN  pares({ 1 ,  2 ,  3 ,  4 })\n \n \n \n \n \n 1.17.  Maps \n \n Chamados funções em TLA+, mas podemos continuar chamando de mapas para não confundir.  \n Contudo, a perspectiva aqui é a de funções. Não temos uma boa forma de expressar um mapa que começa vazio e vai crescendo conforme o sistema evolui.  Geralmente inicializamos o mapa com as chaves já definidas, e algum valor inicial.  \n Isso é uma boa prática para Quint também!  \n \n \n \n \n 1.18.  Maps - construtor \n \n \nEm Quint:  \n \n S.mapBy(x => e)\n \n \n\n \nEm TLA+:  \n \n [ x \\in S |-> e ]\n \n \n\n \nPor exemplo, criando uma estrutura para guardar o saldo no banco de cada pessoa:  \n \n [ pessoa \\in {  \"alice\" ,  \"bob\" ,  \"charlie\"  } |->  0  ]\n \n \n\n \nSe eu ainda não souber quem são as pessoas, aí sim preciso criar um mapa vazio:  \n \n [ pessoa \\in {} |->  0  ]\n \n \n \n \n \n 1.19.  Maps - construtor como em Quint \n \n \nO equivalente a:  \n \n Map(k_1 -> v_1, k_2 -> v_2, k_3 -> v_3)\n \n \n\n \nseria:  \n \n [ x \\in { a: <<a, b>> \\in S } |-> ( CHOOSE  p \\in S: p[ 1 ] = x)[ 2 ]]\n \n \n\n \nO  CHOOSE  é um operador um tanto complicado  \n Ele parece não determinístico, mas é completamente determinístico  \n Vamos evitar ele por agora. Talvez voltamos nisso no final da disciplina.  \n \nSolução:  SetAsFun  \n\n \nPodemos copiar o operador  SetAsFun  do Apalache e usá-lo. Primeiro, copie e cole a seguinte definição  \n \n SetAsFun(S) ==\n     LET  Dom == { x: <<x, y>> \\in S }\n        Rng == { y: <<x, y>> \\in S }\n     IN \n    [ x \\in Dom |->  CHOOSE  y \\in Rng: <<x, y>> \\in S ]\n \n \n\n \nE para utilizar, basta fornecer um conjundo de duplas do tipo    como parâmetro:  \n \n MeuMapa == SetAsFun({ <<k_1, v_1>>, <<k_2, v_2>>, <<k_3, v_3>> })\n \n \n \n \n \n 1.20.  Maps - acesso \n \n \nPara acessar uma chave  e  de um mapa  f :  \n \n f[e]  \\* f.get(e) \n \n \n\n \nUm exemplo na REPL.  \n PS: A REPL de TLA+ imprime somente os valores de um mapa quando imprime um mapa.  \n \n (tla+) [ x \\in { 1 ,  2 } |-> x +  1  ]\n \\* <<2, 3>> \n(tla+)  LET  m == [ x \\in { 1 ,  2 } |-> x +  1  ]  IN  m[ 1 ]\n \\* 2 \n \n \n \n \n \n 1.21.  Operadores sobre Maps \n \n \nObtendo o conjunto com as chaves:  \n \n DOMAIN  f  \\* f.keys() \n \n \n\n \nObtendo todos os mapas possíveis:  \n \n [ S -> T ]  \\* setOfMaps(S, T) \n \n \n\n \nAtualizando e adicionando valores:  \n \n [f  EXCEPT  ![e1] = e2]  \\* f.set(e1, e2) \n[f  EXCEPT  ![e1] = e2, ![e3] = e4]\n \\* f.set(e1, e2).set(e3, e4) \n[f  EXCEPT  ![e1] = @ + y]\n \\* f.setBy(e1, (old => old + y)) \n(k :> v) @@ f  \\* f.put(k, v) \n \n \n \n \n \n 1.22.  Records \n \n \nConstrutor:  \n \n [ f_1 |-> e_1, ..., f_n |-> e_n ]\n \\* { f_1: e_1, ..., f_n: e_n } \n \n \n\n \nAcesso, idêntico ao Quint:  \n \n r.meu_campo  \\* r.meu_campo \n \n \n\n \nAtualização:  \n \n [r  EXCEPT  !.f = e]\n \\* r.with(\"f\", e) ou  { ...r, f: e } \n[r  EXCEPT  !.f1 = e1, !fN = eN]  \\* N campos \n \n \n \nObtendo todos os possíveis records:  \n \n [ f_1: S_1, ..., f_n: S_n ]\n \\* tuples(S_1, ..., S_n).map(((a_1, ..., a_n)) => { f_1: a_1, ..., f_n: a_n }) \n \n \n\n \nObtendo os nomes dos campos:  \n \n DOMAIN  r  \\* r.fieldNames() \n \n \n \n \n \n 1.23.  Listas (ou Sequências) \n \n \nConstrutor:  \n \n <<e_1, ..., e_n>>  \\* [ e_1, ..., e_n ] \n \n \n\n \nAcesso, sendo que os índices iniciam em 1:  \n \n s[i]  \\* l[i - 1] \n \n \n\n \nAtualização em um índice:  \n \n [ s  EXCEPT  ![i] = e ]  \\* l.replaceAt(i - 1, e) \n \n \n\n \nAdicionando elementos:  \n \n Append(s, e)  \\* l.append(e) \nl \\circ t  \\* l.concat(t) \n \n \n \nOutros operadores:  \n \n Head(l)  \\* l.head() \nTail(l)  \\* l.tail() \nLen(s)  \\* l.length() \n DOMAIN   i  \\* l.indices().map(i => i - 1) \nSubSeq(lst, start, end)  \\* l.slice(start - 1, end) \nSelectSeq(s, Test)  \\* select(l, Test) \n \n \n \n \n \n 1.24.  Tuplas \n \n \nJá que não temos tipos em TLA+, tuplas são nada mais do que uma lista.  \n elementos podem ter tipos distintos em ambas (heterogenindade).  \n \nConstrutor:  \n \n << e_1, ..., e_n >>  \\* (e_1, ..., e_n) \n \n \n\n \nAcesso:  \n \n t[ 1 ], t[ 2 ], ... , t[ 50 ]  \\* t._1, t._2, ..., t._50 \n \n \n\n \nObtendo todas as possíveis tuplas:  \n \n S_1 \\X S_2 \\X ... \\X S_n  \\* tuples(S_1, S_2, ..., S_n) \n \n \n \n \n \n 1.25.  Unchanged \n \n \nTLA+ fornece um operador para o caso especial onde uma variável se mantém com o mesmo valor em uma ação:  \n\n \nAo invés de escrevermos:  \n \n MinhaAcao ==\n  /\\ a' = a\n  /\\ b' = b\n \n \n\n \nPodemos escrever:  \n \n MinhaAcao ==\n   UNCHANGED  << a, b >>\n \n \n \n \n \n 1.26.  Folds \n \n \nNão consegui descobir um jeito de fazer  EXTENDS  pela REPL. Então, vamos usar o VSCode com a funcionalidade de avaliação:  \n Selecione o texto de uma  expressão  \n Aperte F1 e selecione TLA+: Evaluate selected expression  \n \nPara usar o fold, precisamos de:  \n EXTENDS FiniteSetsExt  para  FoldSet  \n EXTENDS SequencesExt  para  FoldSeq ,  FoldRight  e  FoldLeft  \n \nEm Quint:  \n \n Set (1, 2, 3, 4).fold(0, (acc, i) => acc + i)\n \n \n\n \nEm TLA+:  \n \n FoldSet( LAMBDA  i, acc : acc + i,  0 , S)\n \n \n \n \n \n 1.27.  Exercícios Fold \n \n \nExercício: Re-escreva nossos exemplos anteriores usando  FoldSet  \nAgora, resolva ambos usando  FoldSet .  \n \n \n \n 1.28.  Exercícios TLA+ \n \n Escreva um operador que recebe um conjunto de inteiros positivos e retorna o maior valor.  \n Dado um conjunto de  records  como  [ nome |-> \"Gabriela\", idade |-> 26 ] , escreva um operador que recebe esse conjunto e retorna a diferença de idade entre o mais velho e o mais novo.  \n Defina um valor que contenha todos os conjuntos possíveis com valores inteiros de 1 a 10, que contenham o número 5 ou o 6.  \n Escreva um operador que calcule o fatorial de um número. Lembre-se que recursão não é permitida.  \n Escreva um operador que recebe uma lista e retorna um mapa onde as chaves são os elementos da lista, e os valores são inteiros representando a quantidade de ocorrências daquele elemento na lista.  \n \nAtenção aos tipos!  \n \nDica: você vai precisar dos módulos importados pela expressão:  \n \n EXTENDS  FiniteSets, FiniteSetsExt, Integers, Sequences, SequencesExt\n \n \n \n \n \n\n             \n         \n    ","url":"20240331223036-mfo_introducao_ao_tla.html"},{"title":"Jogo da Velha em Quint","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Jogo da Velha em Quint \n                  Slides  \n Table of Contents \n \n 1. Jogando de qualquer jeito \n 1.1. Jogo da Velha \n 1.2. Tipos e variáveis \n 1.3. Definições sobre coordenadas \n 1.4. Definições sobre o tabuleiro \n 1.5. Definindo “ganhar” - coordenadas \n 1.6. Definindo “ganhar” - operador won \n 1.7. Ações - Move \n 1.8. Ações - MoveToEmpty \n 1.9. Ações - MoveO e MoveX \n 1.10. Estado inicial \n 1.11. Transições \n 1.12. Rodando jogos aleatórios com o simulador \n 1.13. Usando uma invariante para procurar jogos que “dão velha” \n 1.14. Contraexemplo \n \n 2. Jogando pra ganhar \n 2.1. Jogando pra ganhar \n 2.2. Começando com os cantos \n 2.3. Condições para as jogadas \n 2.4. Condições para as jogadas - definições auxiliares \n 2.5. Ações - Win \n 2.6. Ações - Block \n 2.7. Ações - TakeCenter e SetupWin \n 2.8. Ações - alterando MoveX \n 2.9. Invariantes \n 2.10. Fórmulas temporais \n 2.11. Tarefa de casa \n 2.12. FIM \n \n \n \n \n 1.  Jogando de qualquer jeito \n \n \n \n 1.1.  Jogo da Velha \n \n \nTodos conhecem jogo da velha?  \n \nPS: a partir de hoje, não vou mais traduzir as especificações para português  \n Acho legal usar português no início para que fique claro o que são  keywords  (sempre em inglês) e o que podemos escolher o nome (nesses casos, em português)  \n A partir daqui, vou usar os exemplos originais, em inglês.  \n \n \n \n 1.2.  Tipos e variáveis \n \n \nDefinimos os seguintes tipos  \n \n type  Player = X | O\n type  Square = Occupied(Player) | Empty\n \n \n\n \nE as seguintes variáveis  \n \n // / A 3x3 tic-tac-toe board \n var  board:  int  ->  int  -> Square\n\n // / Who goes next \n var  nextTurn: Player\n \n \n \n \n \n 1.3.  Definições sobre coordenadas \n \n \n pure   val  boardCoordinates = tuples(1.to(3), 1.to(3))\n\n def  square(coordinate: ( int ,  int )): Square =\n  board.get(coordinate._1).get(coordinate._2)\n\n def  hasPlayer(coordinate, player) =\n  match square(coordinate) {\n    | Empty       =>  false \n    | Occupied(p) => player == p\n  }\n\n def  isEmpty(coordinate) =\n  match square(coordinate) {\n    | Empty  =>  true \n    | _      =>  false \n  }\n \n \n \n \n \n 1.4.  Definições sobre o tabuleiro \n \n \n val  boardEmpty = boardCoordinates.forall(isEmpty)\n\n val  boardFull =  not (boardCoordinates.exists(isEmpty))\n \n \n \n \n \n 1.5.  Definindo “ganhar” - coordenadas \n \n Como o tabuleiro é sempre 3x3, é mais fácil listar todas as combinações de coordenadas que levam a uma vitória do que implementar os cálculos.  \n Usamos  Set  - não precisamos de ordem nem de repetição, logo não devemos usar  List .  \n \n pure   val  winningPatterns =  Set (\n   //  Horizonal wins \n   Set ((1,1), (1,2), (1,3)),\n   Set ((2,1), (2,2), (2,3)),\n   Set ((3,1), (3,2), (3,3)),\n   //  Vertical wins \n   Set ((1,1), (2,1), (3,1)),\n   Set ((1,2), (2,2), (3,2)),\n   Set ((1,3), (2,3), (3,3)),\n   //  Diagonal wins \n   Set ((1,1), (2,2), (3,3)),\n   Set ((3,1), (2,2), (1,3))\n)\n \n \n \n \n \n 1.6.  Definindo “ganhar” - operador won \n \n \nUsamos as definições para  winningPaterns  e  hasPlayer  para determinar se um jogador venceu.  \n \n def  won(player) = winningPatterns.exists(pattern =>\n  pattern.forall(coordinate => hasPlayer(coordinate, player))\n)\n \n \n\n \nCom essa definição e  boardFull , podemos determinar se um jogo já acabou.  \n \n val  gameOver = won(X)  or  won(O)  or  boardFull\n \n \n Reparem que o operador  or  pode ser usado na forma infixa (no meio dos argumentos)  \n \n \n \n 1.7.  Ações - Move \n \n \nUm dado jogador faz uma jogada (um  move ) em uma dada coordenada  \n Determinístico  \n \n action  Move(player, coordinate) =  all  {\n  isEmpty(coordinate),\n  board' = board.setBy(\n    coordinate._1,\n    row => row.set(coordinate._2, Occupied(player))\n  ),\n}\n \n \n \nQual é a pré-condição pra essa ação?  \n A pré-condição para essa ação é que a coordenada esteja vazia  \n \n setBy  é bem útil pra atualizar mapas aninhados (como nesse caso,  int -> int -> Square )  \n \n \n \n 1.8.  Ações - MoveToEmpty \n \n \nUm dado jogador faz uma jogada em  alguma  coordenada  \n Não-determinístico  \n \n action  MoveToEmpty(player) =  all  {\n   not (gameOver),\n   nondet  coordinate = boardCoordinates.filter(isEmpty).oneOf()\n  Move(player, coordinate)\n}\n \n \n \nQual é a pré-condição pra essa ação?  \n A pré-condição para essa ação é que o jogo ainda não tenha acabado  \n \n \n \n \n 1.9.  Ações - MoveO e MoveX \n \n Por enquanto, as ações  MoveO  e  MoveX  são bem parecidas porque ambos jogam “de qualquer jeito”. Não vamos parametrizar elas porque depois vamos mudar somente o comportamento de  X .  \n \n  Move0  \n \n action  MoveO =  all  {\n  nextTurn == O,\n  MoveToEmpty(O),\n  nextTurn' = X,\n}\n \n \n \n \n  MoveX  \n \n action  MoveX =  all  {\n  nextTurn == X,\n  MoveToEmpty(X),\n  nextTurn' = O,\n}\n \n \n \n \n      B_ignoreheading  \n \nQual é a pré-condição pra essas ações?  \n Para ambas, a pré-condição é que seja o turno do jogador a fazer a jogada  Implicitamente, também temos a pré-condição de  MoveToEmpty  empregada nessa ação  \n \n \n \n \n \n \n 1.10.  Estado inicial \n \n \n action  init =  all  {\n   //  X always goes first \n  nextTurn' = X,\n   //  Every space in the board starts blank \n  board' = 1.to(3).mapBy(_ => 1.to(3).mapBy(_ => Empty)),\n}\n \n \n \n \n \n 1.11.  Transições \n \n \n action  step =  any  {\n  MoveX,\n  MoveO,\n   //  If the game is over, we don't need to do anything \n   all  { gameOver, board' = board, nextTurn' = nextTurn },\n}\n \n \n \n \n \n 1.12.  Rodando jogos aleatórios com o simulador \n \n \n quint run tictactoe.qnt --max-samples= 1 \n \n \n\n \n ...\n\n[State 20]\n{\n  board:\n    Map(\n      1 -> Map(1 -> Occupied(O), 2 -> Occupied(X), 3 -> Occupied(X)),\n      2 -> Map(1 -> Occupied(X), 2 -> Occupied(O), 3 -> Occupied(O)),\n      3 -> Map(1 -> Occupied(X), 2 -> Occupied(O), 3 -> Occupied(X))\n    ),\n  nextTurn: O\n}\n \n \n \n \n \n 1.13.  Usando uma invariante para procurar jogos que “dão velha” \n \n \n“Dar velha”, ou  stalemate , quer dizer que o tabuleiro está cheio e ninguém ganhou. É um empate.  \n \n val  stalemate = boardFull  and   not (won(X))  and   not (won(O))\n\n val  NotStalemate =  not (stalemate)\n \n \n\n \nEssa invariante é fácil de quebrar, podemos usar o simulador ao invés do  model checker  tranquilamente:  \n \n quint run tictactoe.qnt --invariant=NotStalemate\n \n \n\n \nMas podemos usar o  model checker  também! Ele vai demorar mais, porque faz BFS e vai levar um tempo para chegar em jogos com 9 jogadas feitas, que são necessárias para um tabuleiro completo.  \n \n quint verify tictactoe.qnt --invariant=NotStalemate\n \n \n \n \n \n 1.14.  Contraexemplo \n \n \n [State 9]\n{\n  board:\n    Map(\n      1 -> Map(1 -> Occupied(O), 2 -> Occupied(X), 3 -> Occupied(O)),\n      2 -> Map(1 -> Occupied(O), 2 -> Occupied(X), 3 -> Occupied(X)),\n      3 -> Map(1 -> Occupied(X), 2 -> Occupied(O), 3 -> Occupied(X))\n    ),\n  nextTurn: O\n}\n \n \n \n \n \n \n 2.  Jogando pra ganhar \n \n \n \n 2.1.  Jogando pra ganhar \n \n Jogo da velha é um jogo bem simples e fácil  \n Ainda quando crianças, enjoamos do jogo, porque percebemos que “sempre dá velha”  \n Hipótese: Se um jogador seguir uma certa estratégia, ele nunca perde.  Consequência: Se os dois jogadores seguirem essa estratégia, nenhum dos dois perde - “sempre dá velha”  \n \n \n Estratégia :  \n A primeira jogada é sempre nos cantos  \n As outras jogadas fazem a primeira jogada possível nessa lista de prioridade:  Ganhar  \n Bloquear  \n Jogar no centro  \n Preparar uma vitória (preenchendo 2 de 3 quadrados numa fila/coluna/diagonal)  \n Jogada qualquer  \n \n \nVamos implementar essa estratégia para o jogador X, enquanto o jogador O continua jogando “de qualquer jeito”.  \n \n \n \n 2.2.  Começando com os cantos \n \n \n pure   val  corners =  Set (\n  (1,1),\n  (3,1),\n  (1,3),\n  (3,3)\n)\n\n action  StartInCorner =\n   nondet  corner = oneOf(corners)\n  Move(X, corner)\n \n \n \n \n \n 2.3.  Condições para as jogadas \n \n \nPrecisamos definir as condições que determinam se cada uma das jogadas na lista de prioridade pode ser feita.  \n Ganhar  \n Bloquear  \n Jogar no centro  \n Preparar uma vitória  \n \n val  canWin = winningPatterns.exists(canWinWithPattern)\n val  canBlock = winningPatterns.exists(canBlockWithPattern)\n val  canTakeCenter = isEmpty((2,2))\n val  canSetupWin = winningPatterns.exists(canSetupWinWithPattern)\n \n \n\n \n( canWinWithPattern ,  canBlockWithPattern  e  canSetupWintWithPattern  a seguir)  \n \n \n \n 2.4.  Condições para as jogadas - definições auxiliares \n \n \nDado um  winning pattern , podemos  ganhar  com aquele  pattern  sse duas das coordenadas tiverem  X  e a outra estiver vazia. Lembrando que a ordem não importa.  \n \n def  canWinWithPattern(pattern) =  and  {\n  pattern.filter(coordinate => coordinate.hasPlayer(X)).size() == 2,\n  pattern.filter(coordinate => coordinate.isEmpty()).size() == 1,\n}\n \n \n\n \nDado um  winning pattern , podemos  bloquear  com aquele  pattern  sse duas das coordenadas tiverem  O  e a outra estiver vazia.  \n \n def  canBlockWithPattern(pattern) =  and  {\n  pattern.filter(coordinate => coordinate.hasPlayer(O)).size() == 2,\n  pattern.filter(coordinate => coordinate.isEmpty()).size() == 1,\n}\n \n \n\n \nDado um  winning pattern , podemos  preparar uma vitória  com aquele  pattern  sse uma das coordenadas tiver  X  e as outras duas estiverem vazias.  \n \n def  canSetupWinWithPattern(pattern) =  and  {\n  pattern.filter(coordinate => coordinate.hasPlayer(X)).size() == 1,\n  pattern.filter(coordinate => coordinate.isEmpty()).size() == 2,\n}\n \n \n \n \n \n 2.5.  Ações - Win \n \n \n action  Win =  all  {\n  canWin,\n   nondet  pattern = winningPatterns.filter(canWinWithPattern).oneOf()\n   nondet  coordinate = pattern.filter(isEmpty).oneOf()\n  Move(X, coordinate),\n}\n \n \n \nQual é a pré-condição pra essa ação?  \n canWin , lembrando que  canWin  é definido por:  \n \n    val  canWin = winningPatterns.exists(canWinWithPattern)\n \n \n Isso é importante para garantir que nunca estamos chamando  oneOf  em um set vazio.  \n \n \n \n \n 2.6.  Ações - Block \n \n \n action  Block =  all  {\n  canBlock,\n   nondet  pattern = winningPatterns.filter(canBlockWithPattern).oneOf()\n   nondet  coordinate = pattern.filter(isEmpty).oneOf()\n  Move(X, coordinate),\n}\n \n \n\n \nObservem o uso de  oneOf  para selecionar a coordenada aqui. Nesses casos (tanto  Win  quanto  Block ), essa seleção é  determinística , porque sabemos que sempre haverá uma única coordenada vazia nesses  patterns . Contudo, o Quint não sabe disso.  \n Não existe algo como “pegar o primeiro elemento do set” - porque sets não são ordenados!  \n \n \n \n 2.7.  Ações - TakeCenter e SetupWin \n \n \n action  TakeCenter = Move(X, (2, 2))\n\n action  SetupWin =  all  {\n   nondet  pattern = winningPatterns.filter(canSetupWinWithPattern).oneOf()\n   nondet  coordinate = pattern.filter(isEmpty).oneOf()\n  Move(X, coordinate),\n}\n \n \n \n \n \n 2.8.  Ações - alterando MoveX \n \n \nTemos todas as ações para a estratégia definidas, agora basta definir um novo  MoveX  que chama essas ações conforme a prioridade estabelecida.  \n \n action  MoveX =  all  {\n  nextTurn == X,\n   if  (boardEmpty) StartInCorner  else \n   if  (canWin) Win  else \n   if  (canBlock) Block  else \n   if  (canTakeCenter) TakeCenter  else \n   if  (canSetupWin) SetupWin  else \n  MoveToEmpty(X),\n  nextTurn' = O,\n}\n \n \n \n \n \n 2.9.  Invariantes \n \n \nCom isso, temos nosso modelo. Agora, vamos definir algumas invariantes para o uso dessa estratégia.  \n \n    // / X has not won. This does not hold, as X wins most of the times. \n   val  XHasNotWon =  not (won(X))\n\n   // / O has not won. This should hold, as O can only achieve a draw. \n   val  OHasNotWon =  not (won(O))\n \n \n \n \n \n 2.10.  Fórmulas temporais \n \n \n // / This is not always true, as if O picks the right moves, the game will \n // / result in a stalemate. \n temporal  XMustEventuallyWin = eventually(won(X))\n \n \n\n Infelizmente, a implementação de propriedades temporais no Apalache ainda é bem rudimentar.  \n Podemos traduzir Quint pra TLA+ e usar o TLC para checar essa propriedade  Existe um script para chamar o TLC com os parâmetros apropriados, que podemos usar enquanto a integração não está pronta  sh tlc/check_with_tlc.sh --file tictactoe.qnt --temporal XMustEventuallyWin  \n \n \n O simulador não suporta fórmulas temporais  Poderia suportar parcialmente com aquela implementação que fizemos em C++/Haskell na disciplina  \n \n \n \n \n 2.11.  Tarefa de casa \n \n \nTarefa para a próxima aula: ler o blogpost  https://elliotswart.github.io/pragmaticformalmodeling/  \n Serve como uma revisão de alguns conteúdos da matéria até agora  \n Explica a modelagem do jogo da velha em TLA+, que veremos na próxima aula  \n Também conta como referência pra essa aula :)  \n \n \n \n 2.12.  FIM \n \n \n \n \n\n             \n         \n    ","url":"20240330105337-mfo_jogo_da_velha_em_quint.html"},{"title":"Revisão de programação funcional em Quint","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Revisão de programação funcional em Quint \n                  Slides  \n Table of Contents \n \n 1. Introdução \n 1.1. Restrições de Quint e TLA+ \n 1.2. Forma dos operadores em Quint \n \n 2. Conjuntos \n 2.1. Conjuntos! \n 2.2. map, seu novo melhor amigo \n 2.3. map com operadores de múltiplos argumentos \n 2.4. map com operadores que esperam uma dupla \n 2.5. map não resolve tudo! \n 2.6. filter permite filtrar o conjunto \n 2.7. fold permite acumular um valor ao percorrer o conjunto \n 2.8. Exercício: map e filter com fold \n 2.9. Operações de conjuntos \n 2.10. Operadores booleanos para conjuntos \n 2.11. Powerset - Conjunto das partes \n 2.12. flatten, para conjuntos de conjuntos \n \n 3. Maps \n 3.1. Maps \n 3.2. Chaves e valores \n 3.3. Acessando e atualizando \n 3.4. Atualizando com setBy \n 3.5. Criando todos os Maps possíveis \n \n 4. Tuplas \n 4.1. Tuplas \n 4.2. Acessando itens \n 4.3. Criando todas as tuplas possíveis \n \n 5. Records \n 5.1. Records \n 5.2. Acessando e atualizando \n \n 6. Listas \n 6.1. Listas \n 6.2. Acessando \n 6.3. Atualizando \n 6.4. Filtrando listas \n 6.5. foldl e foldr \n 6.6. Use indices para fazer um map \n \n 7. Tipos \n 7.1. Definindo tipos ( aliases ) \n 7.2. Tipos soma \n 7.3. Recursos \n 7.4. Exercícios \n \n \n \n \n 1.  Introdução \n \n \n \n 1.1.  Restrições de Quint e TLA+ \n \n Não há recursão*  *Existe recursão em TLA+, mas foi adicionado posteriormente. Não suportado pelo Apalache.  \n \n Não há laços de repetição ( for ,  while )  \n Não há manipulação de  string  \n \n \n \n 1.2.  Forma dos operadores em Quint \n \n \nTodos os operadores (exceto os com símbolos, como  + ) podem ser aplicados de duas formas em Quint:  \n operador(arg0, ..., argn)  \n arg0.operador(arg1, ..., argn)  \n \nEscolha a forma que você acha mais fácil de ler!  \n \n \n \n \n 2.  Conjuntos \n \n \n \n 2.1.  Conjuntos! \n \n \nConjuntos, ou  Sets , são a principal estrutura de dados em Quint em TLA+.  \n A não ser que a  ordem  dos elementos seja realmente importante, ou que seja necessário ter elementos repetidos, use conjuntos em vez de listas.  \n Importante! Isso é um ponto que vou avaliar no trabalho de vocês.  \n \nO tipo de um conjunto é dado por  Set[<elemento>] . Ou seja, um conjunto de inteiros tem tipo  Set[int] .  \n\n \nCriando conjuntos:  \n \n Set (1, 2, 3)  //  Set(1, 2, 3) \n1.to(3)  //  Set(1, 2, 3) \n \n \n \n \n \n 2.2.  map, seu novo melhor amigo \n \n \nEm linguagens funcionais, usamos muito a função  map , que permite a aplicação de uma função a cada elemento de um conjunto.  \n\n \n Set (1, 2, 3).map(x => x * 2)  //  Set(2, 4, 6) \n \n \n\n \nPode ser usado com lambdas (operadores anônimos), como acima, ou com operadores nomeados:  \n\n \n pure   def  quadrado(x:  int ):  int  = x * x\n\n Set (1, 2, 3).map(quadrado)  //  Set(1, 4, 9) \n \n \n \n \n \n 2.3.  map com operadores de múltiplos argumentos \n \n \nDado um conjunto de duplas, podemos aplicar um operador em cada uma das duplas. Mas cuidado! Se o operador espera dois argumentos, temos que fazer o  unpacking  das duplas, utilizando parênteses duplos.  \n\n \n pure   def  soma(x:  int , y:  int ):  int  = x + y\n\n Set ((1, 1), (2, 3)).map(soma)\n //  static analysis error: error: [QNT000] Expected 1 arguments, got 2 \n\n Set ((1, 1), (2, 3)).map(((a, b)) => soma(a, b))\n //  Set(2, 5) \n \n \n \n \n \n 2.4.  map com operadores que esperam uma dupla \n \n \n pure   def  somaDupla(t: ( int ,  int )):  int  = t._1 + t._2\n\n Set ((1, 1), (2, 3)).map(somaDupla)\n //  Set(2, 5) \n \n \n \n \n \n 2.5.  map não resolve tudo! \n \n \nO  map  só nos ajuda quando queremos um conjunto como retorno.  \n Dado um conjunto de números, retorne um conjunto do quadrado desses números.  \n Dado um conjunto de pessoas, retorne um conjunto com as idades das pessoas.  \n \n map  não pode ser usado para as seguintes operações:  \n Dado um conjunto de números, retorne a soma de todos esses números.  \n Dado um conjunto de números, retorne um conjunto apenas com os números pares.  \n \nLembram quais funções podem ajudar com esses casos?  \n \n \n \n 2.6.  filter permite filtrar o conjunto \n \n \nExemplo: Dado um conjunto de números, retorne um conjunto apenas com os números pares.  \n\n \n Set (1, 2, 3, 4).filter(x => x % 2 == 0)\n //  Set(2, 4) \n \n \n \n \n \n 2.7.  fold permite acumular um valor ao percorrer o conjunto \n \n \nArgumentos do  fold  \n O conjunto sobre o qual iterar  \n Um valor inicial para o acumulador  \n Um operador que recebe dois argumentos (o acumulador, e o elemento iterado), e retorna o novo valor para o acumulador  \n \nExemplo: Dado um conjunto de números, retorne a soma de todos esses números.  \n \n Set (1, 2, 3, 4).fold(0, (acc, i) => acc + i)\n //  10 \n \n \n \n Atenção : Não assumir nada sobre a ordem em que os elementos são iterados.  \n \n \n \n 2.8.  Exercício: map e filter com fold \n \n \nExercício: Re-escreva nossos exemplos anteriores usando  fold  ao invés de  map  e  filter :  \n Dado um conjunto de números, retorne um conjunto do quadrado desses números.  \n Dado um conjunto de números, retorne um conjunto apenas com os números pares.  \n \nVocê vai precisar usar:  \n União de conjuntos  s1  e  s2 :  s1.union(s2)  \n Condicional:  if (cond) bloco1 else bloco2  \n \n \n \n 2.9.  Operações de conjuntos \n \n União:  union  \n Intersecção:  intersect  \n Diferença:  exclude  \n \n \n \n 2.10.  Operadores booleanos para conjuntos \n \n Pertence, \\(\\in\\):  in ,  contains  e.in(S)  é equivalente a  S.contains(e)  \n Contido, \\(\\subseteq\\):  subseteq  \n Para todo, \\(\\forall\\):  forall  \n Existe, \\(\\exists\\):  exists  \n \n \n \n 2.11.  Powerset - Conjunto das partes \n \n \n Set (1, 2).powerset()\n //  Set(Set(), Set(1), Set(2), Set(1, 2)) \n \n \n\n \nÚtil quando queremos gerar várias possibilidades para escolher dentre elas.  \n \n \n \n 2.12.  flatten, para conjuntos de conjuntos \n \n \nUm conjunto de conjuntos de elementos to tipo  t  pode ser convertido em um conjunto de elementos do tipo  t  com o operador  flatten .  \n \n Set ( Set (1, 2),  Set (1, 3)).flatten()\n //  Set(1, 2, 3) \n \n \n \n \n \n \n 3.  Maps \n \n \n \n 3.1.  Maps \n \n \nMap é a estrutura de dicionário em Quint. Em TLA+, essa mesma estrutura tem nome de função.  \n\n \nO tipo de um mapa é dado por  <chave> -> <valor> . Ou seja, um mapa de inteiros para strings tem tipo  int -> str .  \n\n \nCriando  Maps :  \n \n Map(1 ->  \"a\" , 2 ->  \"b\" )\n //  Map(1 -> \"a\", 2 -> \"b\") \n\n Set ((1,  \"a\" ), (2,  \"b\" )).setToMap()\n //  Map(1 -> \"a\", 2 -> \"b\") \n\n Set (1, 2).mapBy(x =>  if  (x < 2)  \"a\"   else   \"b\" )\n //  Map(1 -> \"a\", 2 -> \"b\") \n \n \n \n \n \n 3.2.  Chaves e valores \n \n \nPara obter todas as chaves:  \n \n Map(1 ->  \"a\" , 2 ->  \"b\" ).keys()\n //  Set(1, 2) \n \n \n\n \nE os valores?  \n \n val  m = Map(1 ->  \"a\" , 2 ->  \"b\" )\nm.keys().map(k => m.get(k))\n //  Set(\"a\", \"b\") \n \n \n \n \n \n 3.3.  Acessando e atualizando \n \n \n set  atualiza um elemento existente, e  put  pode criar um novo par chave-valor.  \n\n \n val  m = Map(1 ->  \"a\" , 2 ->  \"b\" )\n\nm.get(1)\n //  \"a\" \n\nm.set(1,  \"c\" )\n //  Map(1 -> \"c\", 2 -> \"b\") \n\nm.set(3,  \"c\" )\n //  runtime error: error: [QNT507] Called 'set' with a non-existing key \n\nm.put(3,  \"c\" )\n //  Map(1 -> \"a\", 2 -> \"b\", 3 -> \"c\") \n \n \n \n \n \n 3.4.  Atualizando com setBy \n \n \n setBy  é uma utilidade para quando queremos fazer uma operação sobre um valor existente no mapa.  \n \n val  m = Map( \"a\"  -> 1,  \"b\"  -> 2)\n\nm.set( \"a\" , m.get( \"a\" ) + 1)\n //  Map(\"a\" -> 2, \"b\" -> 2) \n\nm.setBy( \"a\" , x => x + 1)\n //  Map(\"a\" -> 2, \"b\" -> 2) \n \n \n \n \n \n 3.5.  Criando todos os Maps possíveis \n \n \nPara criar todos os  Maps  possíveis dado um domínio e um co-domínio, podemos usar o  setOfMaps :  \n \n Set (1, 2).setOfMaps( Set ( \"a\" ,  \"b\" ))\n //  Set(Map(1 -> \"a\", 2 -> \"a\"), Map(1 -> \"b\", 2 -> \"a\"), \n //      Map(1 -> \"a\", 2 -> \"b\"), Map(1 -> \"b\", 2 -> \"b\")) \n \n \n \n \n \n \n 4.  Tuplas \n \n \n \n 4.1.  Tuplas \n \n \nTuplas são combinações de tipos diferentes em um mesmo valor, onde a ordem dos elementos é o que define o tipo esperado.  \n\n \nO tipo de uma tupla é dado por  (t0, ..., tn) . Uma tupla com tipo  (int, str, bool)  permite valores como  (1, \"a\", true) .  \n\n \nExiste um único jeito de criar uma tupla:  \n \n (1,  \"a\" ,  true )\n \n \n \n \n \n 4.2.  Acessando itens \n \n \nItens de tuplas são acessados com  ._1 ,  ._2 ,  ._3 , …  \n \nNão existe  ._0 , a contagem inicia do 1.  \n \n val  t = (1,  \"a\" ,  true )\n\nt._1\n //  1 \n\nt._3\n //  true \n \n \n \n \n \n 4.3.  Criando todas as tuplas possíveis \n \n \nPara criar um conjunto com todas as tuplas possíveis com elementos em dados conjuntos, usamos o  tuples :  \n \n tuples( Set (1, 2),  Set ( \"a\" ,  \"b\" ))\n //  Set((1, \"a\"), (2, \"a\"), (1, \"b\"), (2, \"b\")) \n\ntuples( Set (1),  Set ( \"a\" ,  \"b\" ),  Set ( false ))\n //  Set((1, \"a\", false), (1, \"b\", false)) \n \n \n \n \n \n \n 5.  Records \n \n \n \n 5.1.  Records \n \n \n Records  são combinações de tipos diferentes em um mesmo valor, onde os elementos são nomeados.  \n\n \nO tipo de um  record  é dado por  { field0: t0, ..., fieldn: tn } . Um  record  com tipo  { nome: str, idade: int }  permite valores como  { nome: \"Gabriela\", idade: 26 } .  \n \n \n \n 5.2.  Acessando e atualizando \n \n \n val  r = { nome:  \"Gabriela\" , idade: 26 }\n\nr.nome\n //  \"Gabriela\" \n\nr.with( \"idade\" , 27)\n //  { nome: \"Gabriela\", idade: 27 } \n\n{ ...r, idade: 27 }\n //  { nome: \"Gabriela\", idade: 27 } \n\nr\n //  { nome: \"Gabriela\", idade: 26 } \n \n \n \n \n \n \n 6.  Listas \n \n \n \n 6.1.  Listas \n \n \nListas são como conjuntos, porém com uma ordem definida e, possivelmente, com elementos repetidos. Em TLA+, essa mesma estrutura tem nome de sequência.  \n\n \nO tipo de uma lista é dado por  List[<elemento>] . Ou seja, uma lista de inteiros tem tipo  List[int] .  \n\n \nCriando listas:  \n \n [1, 2, 3]\n //  [1, 2, 3] \n\n List (1, 2, 3)\n //  [1, 2, 3] \n\nrange(1, 4)\n //  [1, 2, 3] \n \n \n \n \n \n 6.2.  Acessando \n \n \n val  l = [1, 2, 3]\n\nl[1]\n //  2 \n\nl.head()\n //  1 \n\nl.tail()\n //  [2, 3] \n \n \n \n \n \n 6.3.  Atualizando \n \n \n val  l = [1, 2, 3]\n\nl.replaceAt(0, 5)\n //  [5, 2, 3] \n\nl.concat([4, 5])\n //  [1, 2, 3, 4, 5] \n\nl.append(4)\n //  [1, 2, 3, 4] \n\nl\n //  [1, 2, 3] \n \n \n \n \n \n 6.4.  Filtrando listas \n \n \n slice  retorna uma nova lista com um intervalo de elementos da lista original.  \n \n [1, 2, 3].slice(0, 1)\n //  [1] \n \n \n\n \n select  é semelhante ao  filter  (de conjuntos).  \n \n [1, 2, 3, 4, 5].select(x => x > 3)\n //  [4, 5] \n \n \n \n \n \n 6.5.  foldl e foldr \n \n \nDiferente do  fold  pra conjuntos, a operação de  fold  sobre listas respeita uma ordem específica.  foldl  ( fold left ) vai iterar da esquerda pra direita, enquanto  foldr  ( fold right ) vai iterar da direita pra esquerda.  \n \nAtenção também para a ordem dos argumentos do operador dado como último argumento.  \n \n [1, 2, 3].foldl([], (acc, i) => acc.append(i))\n //  [1, 2, 3] \n\n[1, 2, 3].foldr([], (i, acc) => acc.append(i))\n //  [3, 2, 1] \n \n \n \n \n \n 6.6.  Use indices para fazer um map \n \n \nO operador  map  não funciona pra listas. Conseguimos reproduzir essa funcionalidade usando o operador  indices , que returna o índices de uma lista (isso é, \\(0\\) até \\(length(l) - 1\\)).  \n \n val  l = [1, 2, 3]\n def  f(x) = x + 1\n\nl.indices().map(i => f(l[i]))\n //  Set(2, 3, 4) \n \n \n\n \nPerceba que o resultado aqui é um conjunto. Para que o resultado seja uma lista, temos que usar  foldl  ou  foldr .  \n \n \n \n \n 7.  Tipos \n \n \n \n 7.1.  Definindo tipos ( aliases ) \n \n \nNomes de tipos devem sempre iniciar com letra maiúscula.  \n \n type  Idade =  int \n\n val  a: Idade = 1\n \n \n \n \n \n 7.2.  Tipos soma \n \n \n type  Periodo = Manha | Tarde | Noite\n\n type  EstadoLogin = Logado( str ) | Deslogado\n\n type  Opcional[a] = Algum(a) | Nenhum\n \n \n \n \n \n 7.3.  Recursos \n \n Cheatsheet Quint  \n Documentação dos builtins  \n Spells  - bibliotecas auxiliares  PS: Quer contribuir pra opensource? Esse é um ótimo local pra começar  \n \n Manual do Quint  \n \n \n \n 7.4.  Exercícios \n \n Escreva um operador que recebe um conjunto de inteiros positivos e retorna o maior valor.  \n Dado um conjunto de  records  do tipo  { nome: str, idade: int } , escreva um operador que recebe esse conjunto e retorna a diferença de idade entre o mais velho e o mais novo.  \n Defina um valor que contenha todos os conjuntos possíveis com valores inteiros de 1 a 10, com tamanho maior que 2 e menor que 5.  \n Escreva um operador que calcule o fatorial de um número. Lembre-se que recursão não é permitida.  \n Escreva um operador que recebe uma lista e retorna um mapa onde as chaves são os elementos da lista, e os valores são inteiros representando a quantidade de ocorrências daquele elemento na lista.  \n \nAtenção aos tipos!  \n \n \n \n\n             \n         \n    ","url":"20240324195706-mfo_revisao_de_programacao_funcional.html"},{"title":"Primeiras Especificações","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Primeiras Especificações \n                  Slides  \n Table of Contents \n \n 1. REPL \n 1.1. Usando a REPL \n 1.2. PS: Definições aninhadas \n \n 2. Ações em Quint \n 2.1. Ações \n 2.2. all e any \n 2.3. nondet e oneOf \n 2.4. if também pode ser usado em ações \n 2.5. Balanceamento de atualizações \n 2.6. Exemplos desbalanceados \n 2.7. Exemplos com múltiplas atualizações da mesma variável \n \n 3. Modos de Quint \n 3.1. Modos de Quint \n 3.2. Definição dos modos \n \n 4. Jarros de Água \n 4.1. Exercício - Jarros de Água \n 4.2. Variáveis \n 4.3. Ações \n 4.4. Estado inicial \n 4.5. Tentando resolver na REPL \n 4.6. Ação de próximo estado e invariante \n 4.7. Encontrando um contraexemplo \n \n 5. Runs \n 5.1. Runs \n 5.2. Definindo uma run para a solução dos jarros \n 5.3. Rodando runs como testes \n 5.4. Invocando runs na REPL \n 5.5. FIM \n \n \n \n \n 1.  REPL \n \n \n \n 1.1.  Usando a REPL \n \n \nx’ = x + 1 na REPL  \n \n >>>  var  x:  int \n\n>>> x' = 0\n true \n>>> x\n0\n>>>  action  step = x' = x + 1\n\n>>> step\n true \n>>> step\n true \n>>> x\n2\n \n \n \n \n \n 1.2.  PS: Definições aninhadas \n \n \nSempre podemos definir operadores, valores e ações dentro do próprio corpo de outra definição. Semelhante ao  let  do Haskell.  \n Para isso, basta escrever a(s) definição(ões) seguidas por fim da expressão final a ser retornada.  Sem separar com vírgula!  \n \n \n pure   def  f(x) = {\n   pure   def  quadrado(y) = y * y\n   pure   def  dobro(y) = 2 * y\n  quadrado(x) + dobro(x)\n}\n \n \n\n \nAs chaves  {}  são opcionais, e você pode usar elas quando quiser pra deixar mais claro o escopo, por exemplo:  \n \n val  foo =  pure   def  f(x) = 2 * x { f(5) }\n \n \n \n \n \n \n 2.  Ações em Quint \n \n \n \n 2.1.  Ações \n \n \nAções são expressões booleanas que podem incluir o operador  primed  ( ' ).  \n\n \nContudo, não podemos usar os operadores booleanos normais sobre essa expressão. Quint não permite isso para evitar possíveis confusões. Por exemplo, as seguintes operações  não  são permitidas:  \n not(x' = 1)  \n x' = 1 or x' = 2  \n x' > 1 and x' < 2  \n Set(1, 2, 3).exists(i ==> x' = i)  \n \nOs equivalentes em TLA+ são permitidos. Em Quint, somos forçados a escrever as ações de um jeito específico, de uma forma que elas não possam ser confundidas com não-ações.  \n \n \n \n 2.2.  all e any \n \n \nEm vez de  and , usamos  all  \n \n    action  incrementa_x_e_y =  all  {\n    x' = x + 1,\n    y' = y + 1,\n  }\n \n \n \nEm vez de  or , usamos  any  \n \n    action  incrementa_ou_decrementa_x =  any  {\n    x' = x + 1,\n    x' = x - 1,\n  }\n \n \n \n \n \n 2.3.  nondet e oneOf \n \n \nEm vez de  exists , usamos  nondet  e  oneOf  \n \n    action  x_recebe_algum_valor = {\n     nondet  valor =  Set (1, 2, 3).oneOf()\n    x' = valor\n  }\n \n \n \nImportante: O  oneOf  só pode ser usado nesse cenário (dentro de uma ação, em uma definição do tipo  nondet , sem operações adicionais sobre ele).  \n A syntaxe em Quint é dessa forma para deixar o não-determinismo explícito, mas na lógica (TLA), isso ainda é um  exists .  \n Por exemplo, não é possível usar o  oneOf  na implementação de uma função, i.e. para encontrar o máximo em um conjunto.  \n \n \n \n \n 2.4.  if também pode ser usado em ações \n \n \nO  if  não tem uma versão especial pra ações. Usamos ele normalmente.  \n \n    action  incrementa_x_se_par = {\n     if  (x % 2 == 0) {\n      x' = x + 1\n    }  else  {\n      x' = x\n    }\n  }\n \n \n \n \n \n 2.5.  Balanceamento de atualizações \n \n \nTodas as ações em Quint devem ser devidamente balanceadas, e uma variável nunca pode ser atualizada mais de uma vez em uma mesma ação.  \n\n \nIsso significa que:  \n Todas as ações em um  any  devem atualizar as mesmas variáveis  \n Em um  if , os blocos  then  e  else  devem atualizar as mesmas variáveis  \n Em um  all , as variáveis atualizadas por cada ação não podem se repetir  \n \nEssas restrições valem pra TLA+ também, mas em TLA+ isso só será detectado na hora de rodar o  model checker . Em Quint, vocês vão ver sublinhados vermelhos no editor.  \n \n \n \n 2.6.  Exemplos desbalanceados \n \n \nOs exemplos a seguir  não  são permitidos no Quint. PS: Para vê-los no editor, você precisa declarar as variáveis ( var x: int  e  var y: int ).  \n \n action  any_desbalanceado =  any  {\n  x' = 1,\n  y' = 2,\n}\n\n action  if_desbalanceado = {\n   if  (x > 0) {\n    x' = 1\n  }  else  {\n    y' = 2\n  }\n}\n \n \n \n \n \n 2.7.  Exemplos com múltiplas atualizações da mesma variável \n \n \nOs exemplos a seguir  não  são permitidos no Quint.  \n \n action  all_multiplas_atualizacoes =  all  {\n  x' = 1,\n  x' = 2,\n}\n\n action  a1 = x' = 1\n action  a2 = x' = 2\n action  all_multiplas_atualizacoes =  all  { a1, a2 }\n \n \n \n \n \n \n 3.  Modos de Quint \n \n \n \n 3.1.  Modos de Quint \n \n \nPercebam como nas últimas aulas conversamos sobre coisas um tanto diferentes:  \n Aula passada, definimos  operadores  com  def  e  pure def  \n valores  com  val  e  pure val  \n \n Nessa aula, usaremos ações com  action  \n \n \n \n 3.2.  Definição dos modos \n \n \nPrimeiramente, temos a diferença entre  val  e  def  \n val  (ou  pure val ): Valores, onde não há nenhum parâmetro.  \n def  (ou  pure def ): Operadores, onde há pelo menos um parâmetro.  \n \nEsses são os  modos  das definições. Eles definem o tanto de acesso que as definições tem às variáveis.  \n pure def  e  pure val : Nenhum acesso. Como funções puras, onde o mesmo input vai sempre gerar o mesmo output.  \n def  e  val : Leitura.  \n action : Escrita e Leitura.  \n \nAlém destes, temos alguns modos adicionais:  \n nondet : Para declarações com não determinismo (que usam  oneOf ).  \n temporal : Para fórmulas temporais.  \n run : Para execuções mais específicas, permitindo operadores que ajudam a definir o passo a passo esperado.  \n \n \n \n \n 4.  Jarros de Água \n \n \n \n 4.1.  Exercício - Jarros de Água \n \n Você tem dois jarros:  um grande, com capacidade de 5 litros  \n um pequeno, com capacidade de 3 litros  \n \n\n Você tem uma torneira de água com capacidade infinita  \n Você pode descartar água a qualquer momento  \n É possível, com precisão, ter uma medida de 4 litros de água?  \n \n \n \n 4.2.  Variáveis \n \n \n module  jarros {\n   var  grande:  int \n   var  pequeno:  int \n\n  ...\n}\n \n \n \n \n \n 4.3.  Ações \n \n \nTente escrever as ações abaixo, definindo os valores para  grande  e  pequeno  em cada uma delas. Nenhuma dessas ações precisa de parâmetros.  \n \n    action  enche_grande\n   action  enche_pequeno\n   action  esvazia_grande\n   action  esvazia_pequeno\n   action  grande_pro_pequeno\n   action  pequeno_pro_grande\n \n \n \n \n \n 4.4.  Estado inicial \n \n \n    action  init =  all  {\n    grande' = 0,\n    pequeno' = 0,\n  }\n \n \n \n \n \n 4.5.  Tentando resolver na REPL \n \n \n quint -r jarros.qnt::jarros\n \n \n\n \nComece com  init , e verifique os valores de  grande  e  pequeno . Depois, tente invocar as outras ações, lembrando que o objetivo é chegar em um estado onde um dos jarros tem 4 litros.  \n \n \n \n 4.6.  Ação de próximo estado e invariante \n \n \nAgora, vamos usar o  model checker  para encontrar a solução. Para isso, vamos definir:  \n step , a ação de próximo estado. A cada passo, podemos tomar qualquer uma das ações definidas.  \n inv , nossa invariante. Nesse caso, esperamos que a invariante seja quebrada, para obter nossa solução como contraexemplo.  \n \n    action  step =  any  {\n    enche_grande,\n    enche_pequeno,\n    esvazia_grande,\n    esvazia_pequeno,\n    grande_pro_pequeno,\n    pequeno_pro_grande,\n  }\n\n   val  inv = grande != 4\n \n \n \n \n \n 4.7.  Encontrando um contraexemplo \n \n \n $ quint verify jarros.qnt --invariant=inv\nAn example execution:\n\n[State 0] { grande: 0, pequeno: 0 }\n[State 1] { grande: 5, pequeno: 0 }\n[State 2] { grande: 2, pequeno: 3 }\n[State 3] { grande: 2, pequeno: 0 }\n[State 4] { grande: 0, pequeno: 2 }\n[State 5] { grande: 5, pequeno: 2 }\n[State 6] { grande: 4, pequeno: 3 }\n\n[violation] Found an issue (156ms).\nerror: found a counterexample\n \n \n \n \n \n \n 5.  Runs \n \n \n \n 5.1.  Runs \n \n Representação de uma  execução  finita.  Pode ser uma execução concreta, ou  \n Pode ter não determinismo, representando mais de uma execução  \n \n Descreve como reproduzir uma ou mais execuções, se possível  \n \nEssa é uma feature exclusiva do Quint, e não há uma representação equivalente em TLA+.  \n Em TLA+, só podemos usar o estado em si para determinar cada passo a ser dado.  \n Em Quint, as runs permitem definir isso externamente, sem necessidade de manipular o estado.  \n \nO propósito de runs está relacionado a testes, e não tem função alguma para o  model checker .  \n \n \n \n 5.2.  Definindo uma run para a solução dos jarros \n \n \n   run solution =\n    init\n      .then(enche_grande)\n      .then(grande_pro_pequeno)\n      .then(esvazia_pequeno)\n      .then(grande_pro_pequeno)\n      .then(enche_grande)\n      .then(grande_pro_pequeno)\n      .expect(grande == 4)\n \n \n\n \nAdicionando o  expect  no final, essa run também funciona como um teste  \n \n \n \n 5.3.  Rodando runs como testes \n \n \n quint test jarros.qnt --match solution\n\n  jarros\n    ok solution passed  1  test ( s ) \n\n   1  passing  ( 12ms ) \n \n \n \n \n \n 5.4.  Invocando runs na REPL \n \n \n $ quint -r jarros.qnt::jarros\n>>> solution\n true \n>>> grande\n4\n>>> pequeno\n3\n \n \n \n \n \n 5.5.  FIM \n \n \n \n \n\n             \n         \n    ","url":"20240322161707-mfo_primeiras_especificacoes.html"},{"title":"Introdução à Lógica Temporal das Ações","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Introdução à Lógica Temporal das Ações \n                  Slides  Specs \n \n Table of Contents \n \n 1. Lógica Temporal das Ações (TLA) \n 1.1. Introdução \n 1.2. Operador  primed \n 1.3. Exemplos: operador  primed \n 1.4. Ações definem Transições \n 1.5. Uma fórmula temporal define o modelo! \n \n 2. TLA+ e Quint \n 2.1. TLA+ e Quint \n 2.2. TLC e Apalache \n 2.3.  Model checking  TLA+ \n 2.4.  Model checking  Quint \n 2.5. Instalando as ferramentas - Dependências \n 2.6. Quint \n 2.7. TLC \n 2.8. Apalache \n \n 3. Exemplos \n 3.1. Semáforos \n 3.2. Testando as ferramentas \n 3.3. Referências \n \n \n \n \n 1.  Lógica Temporal das Ações (TLA) \n \n \n \n 1.1.  Introdução \n \n \nA Lógica Temporal das Ações ( Temporal Logic of Actions  - TLA) foi proposta em ( LAMPORT, 1994 ).  \n\n \nSeu principal conceito são  ações . Uma ação é uma expressão booleana composta de variáveis, variáveis  primed  e constantes.  \n\n \nNessa aula, vamos focar em como usar ações, com o operador  primed  ( ' ), para definir estruturas de Kripke. Mais adiante, em outra aula, falaremos sobre outros conceitos.  \n \n \n \n 1.2.  Operador  primed \n \n \n\\(f'\\) (f  primed ) para uma função de estado \\(f\\) é o valor de \\(f\\) no  final de um passo .  \n\n \nEm outras palavras, para um passo composto por uma  dupla de estados  \\((s, t)\\), \\(f'\\) é o valor de \\(f\\) para \\(t\\).  \n\n \nDe forma semelhante, \\(P'\\) para um predicado \\(P\\) é o valor de \\(P\\) para o estado final de um passo. Assim, na avaliação da valoração de uma ação para um passo, predicados e variáveis  sem  o operador  primed  se referem aos seus respectivos valores no  primeiro estado  do passo, e sempre que  forem marcados  com o operador, fazem referência aos valores no  segundo  estado do passo.  \n \n \n \n 1.3.  Exemplos: operador  primed \n \n \\(x' = x + 1\\)  \n \\(x + 1 = x'\\)  \n \\(x = x' - 1\\)  \n \nOutros exemplos:  \n \\(x' > x\\)  \n \\(x' /= x + 1\\)  \n \nPS: É necessário muito cuidado ao usar formas diferentes de (1).  \n \n \n \n 1.4.  Ações definem Transições \n \n \nCombinando operações  primed  e predicados comuns, podemos definir as transições do modelo.  \n Uma transição é permitida no modelo definido por uma ação sse a avaliação da ação pro passo da transição é verdadeiro.  Exemplo:  Ação \\(x' = x + 1\\)  \n Transição \\(1 \\rightarrow 2\\)  \n Substituindo \\(x\\) por \\(1\\) e \\(x'\\) por \\(2\\), a igualdade é satisfeita  \n \n \n \nNote que  1  ação define  N  transições. Assim, uma única ação pode definir todas as transições de um modelo!  \n \n \n \n 1.5.  Uma fórmula temporal define o modelo! \n \n Um predicado comum define o(s) estado(s) inicial(is).  Geralmente, chamamos de \\(Init\\) ou  init .  \n Exemplo: \\(Init \\triangleq x = 0\\)  \n \n Uma ação define as transições.  Geralmente, chamamos de \\(Next\\) ou  step .  \n Exemplo: \\(Next \\triangleq x' = x + 1\\)  \n \n Uma fórmula temporal define o modelo.  \\(Spec \\triangleq Init \\land \\square Next\\)  \n \n \n \n \n \n 2.  TLA+ e Quint \n \n \n \n 2.1.  TLA+ e Quint \n \n TLA+ ( Temporal Logic of Actions+ ) combina a lógica de TLA com teoria de conjuntos, definindo uma linguagem de especificação formal.  \n Quint é uma syntaxe alternativa à TLA+, que pode ser transpilada para TLA+, e portanto pode usar as mesmas ferramentas.  Quint tem alguns recursos adicionais que não existem em TLA+, com definições de testes e execuções ( runs ).  \n Quint (ainda) não suporta algumas coisas de TLA+ que serão vistas no final da disciplina, como refinamento.  \n No geral, Quint é  intencionalmente  mais restrito que TLA+.  \n \n \n \n \n 2.2.  TLC e Apalache \n \n \nTemos dois  model checkers  disponíveis para TLA+ e Quint.  \n TLC  Primeiro  model checker  para TLA+. Faz enumeração explícita de estados.  \n Funciona apenas com TLA+, então especificações em Quint precisam ser transpiladas  \n Open source, mantido pela Microsoft Research  \n \n Apalache  Model checker  limitado simbólico. Traduz a especificação para restrições SMT e resolve-as usando o  solver  Z3.  \n Exige anotações de tipo para variáveis e constantes  \n Suporte nativo a TLA+ e Quint  \n Open source, desenvolvido majoritariamente pela Informal Systems  \n \n \n \n \n 2.3.   Model checking  TLA+ \n \n Apalache  Lembre-se de anotar os tipos  \n Use a linha de comando  \n \n TLC  Crie um arquivo  .cfg  \n Use a linha de comando ou a extensão para VSCode  \n \n Toolbox (TLC)  A IDE cria as configurações para você, porém você fica dependente da IDE para rodar o  model checker.  \n \n \n \n \n 2.4.   Model checking  Quint \n \n Linha de comando:  quint verify spec.qnt  Isso vai baixar e usar o Apalache por baixo  \n Suporte a fórmulas temporais é limitado  \n \n TLC:  Ainda não há suporte completo, mas há um script pra ajudar:  tlc/check_with_tlc.sh .  \n O script tem várias dependências, não recomendo usar ainda nesse estado.  \n \n \n \n \n 2.5.  Instalando as ferramentas - Dependências \n \n NodeJS >= 18  \n Java Development Kit >= 17  \n \n \n \n 2.6.  Quint \n \n Com acesso de administrador  Instalar:  npm i @informalsystems/quint -g  \n Executar:  quint --help  \n \n\n Sem acesso de administrador  Instalar:  npm i @informalsystems/quint --user  \n Executar:  npx quint --help  \n Essa instalação é local, então você vai precisar instalar de novo se trocar de pasta  \n \n \nTambém temos binários para download direto na  release do GitHub  \n Isso é novo e não foi muito testado ainda, mas deve ser tranquilo usar  \n \n \n \n 2.7.  TLC \n \n TLC para linha de comando  Opcional, se quiser usar pela linha de comando  \n \n Extensão no VSCode (TLA+ Nightly)  Após instalar, abra um arquivo  .tla , aperte F1 e procure o comando “TLA+: Check model with TLC”  \n \n \n \n \n 2.8.  Apalache \n \n Apalache para linha de comando  \n É usado internamente pelo Quint quando invocamos  quint verify . Só precisa baixar separadamente se quiser utilizar com TLA+.  Se não funcionar (comando ficar “travado” e não termina nunca), abra outra terminal e execute:  \n \n \n  ~/.quint/apalache-dist-0.47.2/apalache/bin/apalache-mc server\n \n \n \n \n \n \n 3.  Exemplos \n \n \n \n 3.1.  Semáforos \n \n \nVamos ver novamente o exemplo dos semáforos e verificar propriedades em Quint e TLA+  \n Arquivo no moodle/site da disciplina  \n \n \n \n 3.2.  Testando as ferramentas \n \n \nAtividade EaD valendo presença na aula do dia 24/03  \n\n \nDescrição no moodle: Usando as ferramentas: TLA+ e Quint  \n \n \n \n 3.3.  Referências \n \n \n    LAMPORT, L. The temporal logic of actions.  ACM trans. program. lang. syst. , v. 16, n. 3, p. 872–923, 1994.  \n \n \n \n \n\n             \n         \n    ","url":"20240319195624-mfo_logica_temporal_das_acoes.html"},{"title":"Por que e pra que métodos formais?","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Por que e pra que métodos formais? \n                  Slides \n \n Table of Contents \n \n 0.1. Introdução \n 0.2. Introdução II \n 1. Joost-Pieter Katoen \n 1.1. Joost-Pieter Katoen \n 1.2. Impacto \n 1.3. Overdose de radiação na Therac-25 (1985-87) \n 1.4. Colapso da rede de telefonia da AT&T (1990) \n 1.5. Acidente do míssel Ariane 5 (1996) \n 1.6. Defeito de ponto flutuante (1994) \n \n 2. A Casa Branca \n 2.1. Documento da Casa Branca ( HOUSE, 2024 ) \n 2.2. Parágrafo 1 \n 2.3. Parágrafo 2 \n 2.4. Parágrafo 3 \n 2.5. Parágrafo 4 \n 2.6. Parágrafo 5 \n \n 3. Leslie Lamport \n 3.1. Leslie Lamport \n 3.2. Quem constrói casas sem antes desenhar plantas? ( LAMPORT, 2015 ) \n 3.3. Usando a comparação com plantas \n 3.4. Escrevendo especificações \n \n 4. Hillel Wayne \n 4.1. Hillel Wayne \n 4.2. Hillel’s Pitch ( WAYNE, 2019 ) \n 4.3.     Achando bugs rapidamente ( WAYNE, 2020 ) \n 4.4.     Economizando no desenvolvimento e manutenção \n 4.5.     Achando bugs em sistemas legado \n 4.6. Demo (Adaptada) \n 4.7. Demo - bug   \n 4.8. Demo - características do bug   \n 4.9. Quando não usar métodos formais \n \n 5. Outros \n 5.1. Outros exemplos \n 5.2. Referências \n \n \n \n 0.1.  Introdução \n \n \nEm todas as aulas dessa disciplina, eu vou estar, explicita ou implicitamente, tentando convencer vocês de que usar métodos formais para verificar sistemas complexos é importante.  \n\n \nContudo, pessoas diferentes tem visões diferentes, e tem muita gente de respeito por aí falando da importância de métodos formais. Essa aula vai apresentar as respostas de  outras pessoas  à pergunta:  Por que e pra que métodos formais?  \n \n \n \n 0.2.  Introdução II \n \n \nEu posso pensar como na figura abaixo, mas cada pessoa se motiva de uma forma diferente (por exemplo, ver  Moving Motivators ).  \n\n \n   \n \n \n \n \n 1.  Joost-Pieter Katoen \n \n \n \n 1.1.  Joost-Pieter Katoen \n \n\n \n   \n \n Cientista teórico da computação  \n Professor renomado e líder do Grupo de Modelagem e Verificação de softwareda na universidade RWTH Aachen University.  \n Um dos autores do livro “Principles of Model Checking”, da bibliografia do curso  \n \n \n \n 1.2.  Impacto \n \n \nO impacto que um  bug  pode ter varia muito de acordo com o tipo de sistema.  \n\n \nVamos ver alguns exemplos de  bugs  que tiveram um impacto muito grande. Esses exemplos foram dados pelo professor Joost-Pieter Katoen em uma aula introdutória a  model checking  ( KATOEN, 2013 ).  \n \n \n \n 1.3.  Overdose de radiação na Therac-25 (1985-87) \n \n\n \n   \n \n\n Therac-25 era uma máquina de radioterapia controlada por computador  \n 6 acidentes por overdose de radiação (~100x da dose)  3 pacientes morreram  \n \n Causa: software de controle entre dois modos de tratamento  \n \n \n \n 1.4.  Colapso da rede de telefonia da AT&T (1990) \n \n 9 horas de serviço interrompido em grande parte dos EUA.  \n Causa: um  break  incorreto em C (deveria sair de um  if , mas estava saindo de um  switch ), que fez os computadores reiniciarem em cadeia a cada 6s.  \n Prejuízo: Centenas de milhões de dólares  \n \n \n \n 1.5.  Acidente do míssel Ariane 5 (1996) \n \n\n \n   \n \n\n Conversão de um float 64 bits pra um inteiro de 16 bits  \n \n \n \n 1.6.  Defeito de ponto flutuante (1994) \n \n\n \n   \n \n\n Em inglês,  Pentium FDIV bug  \n Lançamento da família  Pentium  da Intel  \n Uma das inovações era uma tabela para aumentar a velocidade de multiplicação de ponto flutuante  Ainda na fase de testes, descobriram um problema, mas acreditava-se ser muito raro  \n No fim, não era tão raro assim, e tiveram que fazer  recall  dos produtos  \n \n Prejuízo: ~500 milhões de dólares e grande perda de reputação da Intel  \n \n \n \n \n 2.  A Casa Branca \n \n \n \n 2.1.  Documento da Casa Branca ( HOUSE, 2024 ) \n \n\n \n   \n \n \n \n \n 2.2.  Parágrafo 1 \n \n \nEven if engineers build with memory safe programming languages and memory safe chips, one must think about the vulnerabilities that will persist even after technology manufacturers take steps to eliminate the most prevalent classes. Given the complexities of code,  testing is a necessary but insufficient step  in the development process to fully reduce vulnerabilities at scale. If correctness is defined as the ability of a piece of software to meet a specific security requirement, then it is possible to  demonstrate correctness using mathematical techniques  called formal methods. These techniques, often used to prove a range of software outcomes, can also be used in a cybersecurity context and are  viable even in complex environments like space . While formal methods have been studied for decades, their deployment remains limited;  further innovation in approaches to make formal methods widely accessible is vital to accelerate broad adoption . Doing so enables formal methods to serve as another powerful tool to give software developers greater assurance that entire classes of vulnerabilities, even beyond memory safety bugs, are absent.  \n \n \n \n 2.3.  Parágrafo 2 \n \n \nWhile there are several types of formal methods that span a range of techniques and stages in the software development process, this report highlights a few specific examples.  Sound static analysis  examines the software for specific properties without executing the code. This method is effective because it can be used across many representations of software, including the source code, architecture, requirements, and executables.  Model checkers  can answer questions about a number of higher-level properties. These algorithms can be used during production; however, they are limited in their scaled use due to their computational complexity.  Assertion-based testing  is a formal statement of properties carried in the code that may be used to cross-check the code during testing or production. These generated proofs allow for  faults to be detected much earlier  and closer to the erroneous code, rather than tracing back from externally visible systems failures.  \n \n \n \n 2.4.  Parágrafo 3 \n \n \nThere are two ways software engineers can use these techniques across software and hardware. First, formal methods can be incorporated directly into  the developer toolchain . As the programmer builds, tests, and deploys software, the compiler can automate these mathematical proofs and verify that a security condition is met. Additionally, the developer can  use formally verified core components  in their software supply chain. By choosing provably secure software libraries, developers can ensure the components they are using are less likely to contain vulnerabilities.  \n \n \n \n 2.5.  Parágrafo 4 \n \n \nFormal methods can be incorporated throughout the development process to reduce the prevalence of multiple categories of vulnerabilities. Some emerging technologies are also well-suited to this technique. As questions arise about the safety or trustworthiness of a new software product,  formal methods can accelerate market adoption in ways that traditional software testing methods cannot . They allow for proving the presence of an  affirmative requirement, rather than testing for the absence of a negative condition .  \n \n \n \n 2.6.  Parágrafo 5 \n \n \nWhile memory safe hardware and formal methods can be  excellent complementary approaches  to mitigating undiscovered vulnerabilities, one of the most impactful actions software and hardware manufacturers can take is  adopting memory safe programming languages . They offer a way to eliminate, not just mitigate, entire bug classes. This is a remarkable opportunity for the technical community to improve the cybersecurity of the entire digital ecosystem.  \n \n \n \n \n 3.  Leslie Lamport \n \n \n \n 3.1.  Leslie Lamport \n \n\n \n   \n \n Muitos trabalhos importantes na área de Sistemas Distribuídos  \n Autor inicial do LaTeX  \n Recebeu um prêmio de Turing em 2013  \n Criador de TLA e TLA+  \n \n \n \n 3.2.  Quem constrói casas sem antes desenhar plantas? ( LAMPORT, 2015 ) \n \n \n \nWriting is nature’s way of letting you know how sloppy your thinking is. –Dick Guindon  \n \n\n \nPlantas nos permitem pensar com clareza sobre o que estamos construindo. Antes de escrever código, nós deveriamos escrever uma “planta” - em software, uma especificação.  \n \n \n \n 3.3.  Usando a comparação com plantas \n \n Muitas pessoas argumentam que especificar software é uma perda de tempo  Por exemplo: especificações são inúteis porque não podemos gerar todo o  código  a partir dela  Isso é como dizer que desenhar plantas é inútil porque ainda precisa-se de  construtores  para construir.  \n \n \n Alguns argumentam que essa analogia não é válida porque é mais fácil  mudar código  do que  mudar uma construção  Não!  Pode ser muito difícil mudar código, principalmente sem introduzir bugs. Especialmente sem especificações.  \n \n \n \n \n 3.4.  Escrevendo especificações \n \n \n \nBut few engineers write specs because they have little  time to learn how  on the job, and they are unlikely to have learned in school. Some graduate schools teach courses on specification languages, but few teach how to use specification  in practice . It’s hard to draw blueprints for a skyscraper without ever having drawn one for a toolshed.  \n \n\n \nUma dica é evitar usar o código como base para escrever especificações. Arquitetos não fazem as plantas usando tijolos.  \n \n \n \n \n 4.  Hillel Wayne \n \n \n \n 4.1.  Hillel Wayne \n \n\n \n   \n \n Autor do site  Learn TLA+ , do livro   Practical TLA+  e da  documentação do Alloy  (linguagem de especificação)  \n Trabalha como consultor pra empresas, ensinado times a usarem TLA+  Muita experiência prática  \n \n \n \n \n 4.2.  Hillel’s Pitch ( WAYNE, 2019 ) \n \n \n \nFormal methods are an incredibly powerful tool. The biggest barrier to using them, in my opinion, is  education . FM requires a different mindset from coding and sometimes people have trouble  building the intuition . There’s also an implicitly-assumed set of math skills that are easy to learn but hard to realize you need to learn.  \n \n \n \n \n 4.3.      Achando bugs rapidamente ( WAYNE, 2020 ) \n \n \nQuanto antes os bugs são encontrados, menos dano eles causam.  \n AWS ( CHRIS NEWCOMBE, 2014 )  Modelaram DynamoDB e S3 (entre outros)  \n Encontraram bugs complexos em ambos, um deles requeria 35 passos para reprodução  \n Testes, QA e revisão de código não foram suficientes  \n Também conseguiram fazer otimizações agressivas com mais confiança  \n \n eSparkLearning ( WAYNE, 2017 )  Precisaram modificar o sistema para atender um cliente grande  \n Dois dias investidos em uma especificação em TLA+  \n Bugs significantes encontrados, que causariam a perda desse cliente  \n Estimativa de $300k/ano economizados  \n \n \n \n \n 4.4.      Economizando no desenvolvimento e manutenção \n \n \nFormalizando designs, é possível simplificar os sistemas antes de começar a desenvolver.  \n OpenComRTOS ( VERHULST et al., 2011 )  Real-time operating system (RTOS)  \n Modelar ajudou com que desenvolvedores júniores (menos experientes) pudessem contribuir para o sistema complexo  \n \n Cockroach Labs ( VANBENSCHOTEN, 2019 )  Modelo em TLA+ para uma otimização de commits paralelos  \n Encontraram um bug que precisaria de mais de 10 horas para debugar  \n O modelo deu confiança de que a solução para o bug funcionava  \n \n \n \n \n 4.5.      Achando bugs em sistemas legado \n \n \nMesmo em sistemas legados, e muito útil achar bugs antes que os usuários os achem.  \n Rackspace ( PARLAR, 2019 )  Analisando um sistema em produção com Alloy, acharam um bug tão severo que tiveram que refazer  um ano  de trabalho. Se tivessem usado métodos formais desde o início, poderiam ter salvado esse ano.  \n \n ElasticSearch ( HOWELL, 2018 )  Em três dias de modelagem de algumas partes da engine do ElasticSearch, um problema significante foi econtrado.  \n Três meses depois de arrumarem o problema, alguém encontrou e reportou o exato problema em uma versão antiga.  \n \n \n \n \n 4.6.  Demo (Adaptada) \n \n Estou doando meu sofá, alguém quer?  \n Quem quiser, me manda um e-mail essa semana e é seu  \n \nMais detalhes:  \n Um sofá tem um dono  \n O dono do sofá pode ofertá-lo a outra pessoa. Quem recebe a oferta pode aceitá-la, e assim o sofá passa a ser dessa pessoa, ou rejeitá-la, e assim nada acontece  \n A aceitação/rejeição é assíncrona. O dono do sofá pode oferecê-lo para várias pessoas e a pessoa pode esperar alguns dias antes de aceitar ou rejeitar a oferta  \n \nTemos um problema aqui, conseguem ver?  \n \n \n \n 4.7.  Demo - bug   \n \n Gabriela tem o sofá  \n Gabriela oferece o sofá pra Alice  \n Gabriela oferece o sofá pro Bob  \n Alice aceita. O sofá agora é da Alice  \n Bob aceita. O sofá agora é do Bob  \n \nA Alice não ofereceu o sofá para o Bob, mas o sofá era dela e passou a ser do Bob.  \n \n \n \n 4.8.  Demo - características do bug   \n \n É complexo: envolve três pessoas e quatro passos. Difícil de especificar com testes unitários.  \n É sutíl: O único sintoma é que a Alice ficou sem sofá. Uma pessoa testando o OLX não ia perceber isso.  \n É perigoso: Viola um requisito principal do sistema. A Alice (e quem ouvir a história dela) vai deixar de confiar em mim.  \n \nEm ( WAYNE, 2020 ), o Hillel apresenta uma especificação em TLA+ de 15 linhas para um sistema análogo a esse e econtra o bug usando um model checker.  \n \n \n \n 4.9.  Quando não usar métodos formais \n \n \nAlguns pontos negativos:  \n Não é possível obter a  implementação  a partir da especificação. Se você precisa ter absoluta certeza que a implementação corresponde à implementação, muito mais recursos são necessários.  \n Escrever especificações é útil para sistemas complexos. Se você consegue manter o sistema inteiro na sua cabeça, pode não ser benéfico escrever uma especificação.  “Rule of thumb”: Especificar coisas que levam menos de uma semana pra desenvolver não vale a pena.  \n \n Especificações não são a melhor ferramenta pra encontrar erros simples de implementação, como null-checks.  \n \n \n \n \n 5.  Outros \n \n \n \n 5.1.  Outros exemplos \n \n Deepseek usou P para especificar o  Fire-Flyer File System (3FS)  \n Lista de várias empresas e que tipos de métodos formais estão usando na prática:  https://github.com/ligurio/practical-fm . Entre eles:  AWS  \n Intel  \n Google  \n IBM  \n Microsoft  \n Kaspersky  \n MongoDB  \n NASA  \n Oracle  \n Elastic (ElasticSearch)  \n Ethereum  \n Bosch  \n Airbus  \n \n \n \n \n 5.2.  Referências \n \n \n    CHRIS NEWCOMBE, F. Z. Tim Rath.  Use of formal methods at amazon web services . Disponível em: < https://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf >.  \n    HOUSE, T. W.  Back to the building blocks: A path toward secure and measurable software . Disponível em: < https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf >.  \n    HOWELL, K.  Possible to index duplicate documents with same id and routing id . Disponível em: < https://github.com/elastic/elasticsearch/issues/31976#ISSUECOMMENT-404722753 >.  \n    KATOEN, J.-P.  Introduction to model checking . Disponível em: < https://moves.rwth-aachen.de/wp-content/uploads/SS16/mc/lec1.pdf >.  \n    LAMPORT, L.  Who builds a house without drawing blueprints?   Commun. acm , v. 58, n. 4, p. 38–41, Mar. 2015.  \n    PARLAR, J.  Finding bugs without running or even looking at code . Disponível em: < https://www.youtube.com/watch?v=FvNRlE4E9QQ&ab_channel=StrangeLoopConference >.  \n    VANBENSCHOTEN, N.  Parallel commits: An atomic commit protocol for globally distributed transactions . Disponível em: < https://www.cockroachlabs.com/blog/parallel-commits/ >.  \n    VERHULST, E. et al.  Formal development of a network-centric rtos . [s.l: s.n.].  \n    WAYNE, H.  Formal methods in practice: Using tla+ at espark learning . Disponível em: < https://medium.com/espark-engineering-blog/formal-methods-in-practice-8f20d72bce4f >.  \n    WAYNE, H.  Using formal methods at work . Disponível em: < https://www.hillelwayne.com/post/using-formal-methods/ >.  \n    WAYNE, H.  The business case for formal methods . Disponível em: < https://www.hillelwayne.com/post/business-case-formal-methods/ >.  \n \n \n \n \n\n             \n         \n    ","url":"20240310185059-por_que_e_pra_que_metodos_formais.html"},{"title":"Checando propriedades com Lógica Temporal II","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Checando propriedades com Lógica Temporal II \n                  Slides \n \n Table of Contents \n \n 1. Revisão & Cheatsheet \n 1.1. \\(\\square\\) ou  G :  Globally , sempre \n 1.2. \\(\\Diamond\\) ou  F : Finally, eventualmente, no Futuro \n 1.3. \\(\\bigcirc\\) ou  X :  Ne( x )t , próximo \n 1.4.  U :  Until , até \n 1.5.  R :  Release , libera \n \n 2. Exemplos \n 2.1. Ônibus \n 2.2. Ar condicionado da sala de aula \n \n 3. Exercício prático \n 3.1. Exercício prático \n 3.2. Tarefa de casa \n 3.3. FIM \n \n \n \n \n 1.  Revisão & Cheatsheet \n \n \n \n 1.1.  \\(\\square\\) ou  G :  Globally , sempre \n \n \n G  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro por toda a execução a partir de agora.  \n\n \n G  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro em  todos  os momentos \\(t' \\geq t\\).  \n\n \nExemplo: Comida sacia a fome.  \n\n\n \n   \n \n \n \n \n 1.2.  \\(\\Diamond\\) ou  F : Finally, eventualmente, no Futuro \n \n \n F  \\(\\phi\\): eventualmente (na execução a partir de agora), \\(\\phi\\) deve ser verdadeiro.  \n\n \n F  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro em  algum  o momento \\(t' \\geq t\\).  \n\n \nExemplo: Eventualmente, terei fome.  \n\n\n \n   \n \n \n \n \n 1.3.  \\(\\bigcirc\\) ou  X :  Ne( x )t , próximo \n \n \n X  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro no próximo estado.  \n\n \n X  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro no momento \\(t + 1\\).  \n\n \nExemplo: Logo após comer, tenho sede.  \n\n\n \n   \n \n \n \n \n 1.4.   U :  Until , até \n \n \n\\(\\psi\\)  U  \\(\\phi\\): \\(\\psi\\) deve ser verdade até que \\(\\phi\\) seja verdade, sendo que \\(\\phi\\) deve ser verdade no presente ou no futuro.  \n\n \n\\(\\psi\\)  U  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro em algum momento \\(t' \\geq t\\) e, para todo tempo \\(t''\\) (tal que \\(t \\leq t'' < t'\\)), \\(\\psi\\) é verdadeiro.  \n\n \nExemplo: Eu tenho fome até eu comer alguma coisa.  \n\n\n \n   \n \n \n \n \n 1.5.   R :  Release , libera \n \n \n\\(\\psi\\)  R  \\(\\phi\\): \\(\\phi\\) deve ser verdade até e incluindo o momento que \\(\\psi\\) se torna verdadeiro. Se \\(\\psi\\) nunca ficar verdadeiro, \\(\\phi\\) deve permanecer verdadeiro para sempre.  \n\n \n\\(\\psi\\)  R  \\(\\phi\\) é verdadeiro num momento \\(t\\) se…  \n \n…\\(\\phi\\) é verdadeiro em todos os momentos \\(t' \\geq t\\) até e incluindo o momento \\(t''\\) onde \\(\\psi\\) também é verdadeiro. Alternativamente, pode ser que \\(\\psi\\) nunca seja verdadeiro, e nesse caso \\(\\phi\\) deve ser verdadeiro para todo momento \\(t' \\geq t\\).  \n\n \nExemplo: Ao comer chocolate, deixo de ter vontade de comer doce.  \n\n\n \n   \n \n \n \n \n \n 2.  Exemplos \n \n \n \n 2.1.  Ônibus \n \n \nNormalmente, Joãozinho pega ônibus pra udesc e de volta pra casa. Às vezes, Joãozinho erra o ônibus e vai parar em Pirabeiraba.  \n\n \n   \n \n\n F casa : true  \n \n \n \n 2.2.  Ar condicionado da sala de aula \n \n\n \n   \n \n\n aula_acontecendo -> sem_aula V ar_ligado : true  \n aula_acontecendo -> ar_ligado U sem_aula : false, porque podemos ficar em aula pra sempre :)  \n \n \n \n \n 3.  Exercício prático \n \n \n \n 3.1.  Exercício prático \n \n \nVamos escrever um avaliador de operadores para operadores temporais  \n Isso não é um  model checker , porque não vamos considerar todas as possíveis execuções de um sistema  \n Dado uma única execução e uma fórmula temporal, a fórmula é verdadeira para essa execução?  \n \n \n \n 3.2.  Tarefa de casa \n \n \nLer página 10 de  https://bidenwhitehouse.archives.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf  \n \n \n \n 3.3.  FIM \n \n \n \n \n\n             \n         \n    ","url":"20240306214020-mfo_logica_temporal_2.html"},{"title":"Checando propriedades com Lógica Temporal","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Checando propriedades com Lógica Temporal \n                  Slides \n \n Table of Contents \n \n 1.  Model checking \n 1.1. Contexto \n 1.2. Interface de um  model checker \n 1.3. Vantagens e Desvantagens \n 1.4.    Modelos \n 1.5.    Propriedades -    Lógica temporal \n 1.6.    Propriedades -    Invariantes \n 1.7.    Contra-exemplo \n 1.8.    Exercício: Qual dessas fórmulas pode ser um invariante? \n \n 2. Lógica Temporal \n 2.1. Operadores Temporais - Unários \n 2.2. Operadores Temporais - Binários \n 2.3. LTL e CTL \n 2.4. LTL e CTL - Visualização \n \n 3. LTL \n 3.1. LTL -  Linear Temporal Logic \n 3.2. Equivalências \n 3.3. Negações de fórmulas \n 3.4. Exercícios \n 3.5. LTL em Estruturas de Kripke \n \n 4. CTL \n 4.1. CTL -  Computational Tree Logic \n 4.2. Visualização \n \n 5. Verificando propriedades \n 5.1. LTL vs CTL \n 5.2. Exemplo chaleiras - modelo \n 5.3. Exemplo chaleiras \n 5.4. Exemplo Adultos e Crianças - modelo \n 5.5. Exemplo Adultos e Crianças \n 5.6.  Workaround  para falta do existencial com invariantes \n 5.7. Referências \n \n \n \n \n 1.   Model checking \n \n \n \n 1.1.  Contexto \n \n Problema : É difícil pensar em todos os cenários, principalmente em sistemas concorrentes/distribuídos  \n Solução : Diferentes níveis de verificação     Fuzzing  e simulação  \n    Model checking  \n   Provas (com assistente de provas)  \n \n \n \n \n 1.2.  Interface de um  model checker \n \n \nComo um  model checker  é usado?  \n \n  Duas entradas:  \n   Um modelo - uma máquina de estado finita*  \n   Uma propriedade - uma fórmula de alguma lógica temporal  \n \n \n  Três possíveis saídas  \n   Sucesso  \n   Contra-exemplo: Uma sequência de estados que viola a propriedade  \n   Não há memória suficiente  \n \nOpcionalmente, também pode detectar  deadlocks .  \n Deadlock : o modelo não obedece a restrição de uma estrutura de Kripke, ou seja, existe um estado sem transição alguma saindo dele.  \n \n \n \n \n 1.3.  Vantagens e Desvantagens \n \n \n Vantagens  \n   Contra-exemplos  \n   Verificação parcial  \n   Processo automatizado  \n   Sequências infinitas de estados  \n \n Desvantagens  \n   Explosão de estados  \n   Não permite generalização (i.e. \\(N\\) processos)  \n    Model checkers  em si não são verificados  \n \nNo geral, é um método bom para encontrar falhas em software, que permite a verificação com certas restrições.  \n\n \nComparado a testes e simulações aleatórias, pode ser mais eficiente em encontrar casos de borda onde falhas ocorrem.  \n \n \n \n 1.4.     Modelos \n \n \nLinguagens de especificação fornecem diferentes abstrações para como definir uma máquina de estados. Exemplos: Redes de Petri, TLA+ ( Temporal Logic of Actions+ ), CSP ( Communicating Sequential Processes ), Alloy, entre outras.  \n \n \n \n 1.5.     Propriedades -    Lógica temporal \n \n \nDois operadores temporais principais:  \n Eventualmente (\\(\\Diamond\\)) ou Finalmente (\\(F\\)): Cada semáforo deve eventualmente ficar verde  \n Sempre (\\(\\square\\)) ou (\\(A\\)): O número do próximo estado é sempre maior que o número no estado anterior  \n \nFórmulas de lógica temporal são sobre um comportamento (execução) do sistema modelado.  \n \n \n \n 1.6.     Propriedades -    Invariantes \n \n \nInvariantes são predicados sobre estados individuais do sistema. Um invariante é satisfeito se e somente se ele é verdadeiro para todos os estados do sistema.  \n\n \n Invariantes Indutivos  são tipos especiais de invariantes que podem ser provados com indução matemática, isso é, sem necessidade de explorar todos os estados.  \n Muito poderosos mas também difíceis de se definir  \n \n \n \n 1.7.     Contra-exemplo \n \n \n Entradas:  \n   Modelo: 2 semáforos sem controle de revezamento  \n   Propriedade: para cada semáforo, ele deve eventualmente ficar verde  \n \nExecução do  model checker  \n \n Saída -    Contra-exemplo:  \n Semáforo 1 inicia vermelho, semáforo 2 inicia vermelho  \n Semáforo 1 fica verde (e semáforo 2 permanece vermelho)  \n Semáforo 1 fica amarelo (e semáforo 2 permanece vermelho)  \n Retorna ao estado (1)  \n \nÓtimo artefato para reprodução de bugs e geração de testes automatizados.  \n \n \n \n 1.8.     Exercício: Qual dessas fórmulas pode ser um invariante? \n \n Ao fazer uma transferência bancária, eu acabo com menos dinheiro do que tinha antes  \n Ao ligar uma chaleira elétrica, ela eventualmente chegará a 100 graus  \n Em um jogo da velha, a diferença entre o número de X e O não é maior do que 1  \n \n\\faLightbulb Dica: Um invariante é uma fórmula a ser avaliada em cada estado do sistema.  \n\n \nResposta: 3  \n \n \n \n \n 2.  Lógica Temporal \n \n \n \n 2.1.  Operadores Temporais - Unários \n \n \\(\\square\\) ou  G :  Globally , sempre.  G  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro por toda a execução a partir de agora.  \n Exemplo: Comida sacia a fome  \n \n \\(\\Diamond\\) ou  F : Finally, eventualmente, no Futuro.  F  \\(\\phi\\): eventualmente (na execução a partir de agora), \\(\\phi\\) deve ser verdadeiro.  \n Exemplo: Eventualmente, terei fome  \n \n \\(\\bigcirc\\) ou  X :  Ne( x )t , próximo.  X  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro no próximo estado.  \n Exemplo: Logo após comer, tenho sede  \n \n \n \n \n 2.2.  Operadores Temporais - Binários \n \n U :  Until , até.  \\(\\psi\\)  U  \\(\\phi\\): \\(\\psi\\) deve ser verdade até que \\(\\phi\\) seja verdade, sendo que \\(\\phi\\) deve ser verdade no presente ou no futuro.  \n Exemplo: Eu tenho fome até eu comer alguma coisa  \n \n R :  Release , libera.  \\(\\psi\\)  R  \\(\\phi\\): \\(\\phi\\) deve ser verdade até e incluindo o momento que \\(\\psi\\) se torna verdadeiro. Se \\(\\psi\\) nunca ficar verdadeiro, \\(\\phi\\) deve permanecer verdadeiro para sempre.  \n Exemplo: Ao comer chocolate, deixo de ter vontade de comer doce. Detalhe: Eu posso continuar com vontade de comer e acabar nunca comendo chocolate.  \n \n \n \n \n 2.3.  LTL e CTL \n \n LTL  -  Linear Temporal Logic  (Lógica Temporal Linear). Em LTL, as fórmulas são implicitamente universalmente quantificadas. Propriedades que falam sobre a existência de uma execução não podem ser expressadas.  \n CTL  -  Computational Tree Logic  (Lógica de Árvore Computacional). CTL é uma lógica sobre a ramificação do tempo.  \n \n \n \n 2.4.  LTL e CTL - Visualização \n \n\n \n   \n Figure 1:  Fonte ( BULTAN, 2023 ) \n \n \n \n \n \n 3.  LTL \n \n \n \n 3.1.  LTL -  Linear Temporal Logic \n \n \nNa lógica temporal linear (LTL), temos operadores para descrever eventos ao longo de uma única execução.  \n \nSeja \\(AP\\) um conjunto finito de proposições atômicas (i.e. \\(\\{ p_0, p_1, ..., p_n \\}\\)), o conjunto de fórmulas LTL sobre \\(AP\\) é definido indutivamente por:  \n se \\(p \\in AP\\) então \\(p\\) é uma fórmula LTL;  \n se \\(\\psi\\) e \\(\\phi\\) são fórmulas LTL, então \\(\\neg\\psi\\), \\(\\phi \\lor \\psi\\), \\(\\mathbf{X} \\psi\\), e \\(\\phi \\mathbf{U} \\psi\\) são fórmulas LTL.  \n \n\\[\\phi ::= \\bot\\mid\\top\\mid p\\mid \\neg\\phi \\mid \\phi \\lor \\psi \\mid \\mathbf{X} \\psi \\mid \\phi \\mathbf{U} \\psi\\]  \n \n \n \n 3.2.  Equivalências \n \n \nOs operadores  G ,  F  e  R  podem ser definidos usando somente  X  e  U .  \n\n \\(\\mathbf{G}\\psi \\equiv \\bot\\mathbf{R}\\psi \\equiv \\neg\\mathbf{F}\\neg\\psi\\)  \n \\(\\mathbf{F}\\psi \\equiv \\top\\mathbf{U}\\psi\\)  \n \\(\\phi\\mathbf{R}\\psi \\equiv \\neg(\\neg\\phi\\mathbf{U}\\neg\\psi)\\)  Até o momento que \\(\\psi\\) fica falso, \\(\\phi\\) não pode ser falso  \n \n \\(\\neg\\mathbf{G}\\psi \\equiv \\mathbf{F}\\neg\\psi\\)  \n \n \n \n 3.3.  Negações de fórmulas \n \n \nUma formula ser falsa não significa que sua negação é verdadeira. Por exemplo, a fórmula a seguir não é necessariamente verdadeira:  \n\\[\\mathbf{F}p_1 \\lor \\neg\\mathbf{F}p_1\\]  \n\n \nExemplo:  \n\n \n   \n \n \n \n \n 3.4.  Exercícios \n \n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   X , Next  \n\n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   G , Globally  \n\n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   U , Until  \n\n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   F , Finally  \n\n \nQual dos operadores temporais G ( Globally ), F ( Finally ), X ( Next ), U ( Until ) e R ( Release ) pode ser representado pelo diagrama a seguir?  \n\n\n \n   \n \n\n \n Resposta:   R , Release  \n \n \n \n 3.5.  LTL em Estruturas de Kripke \n \n \nUma fórmula LTL é verdadeira para uma  estrutura de Kripke  se ela é verdadeira no(s)  estado(s) inicial(is) .  \n\n \nUma fórmula LTL é verdadeira em um  estado  se ela é verdadeira para  todas as execuções  iniciando naquele estado.  \n\n \nOu seja, a fórmula deve ser verdadeira para todos as execuções (comportamentos) da estrutura.  \n \n \n \n \n 4.  CTL \n \n \n \n 4.1.  CTL -  Computational Tree Logic \n \n \nA gramática a seguir define fórmulas em CTL (sendo \\(p \\in AP\\)):  \n\\[\\phi ::= \\bot\\mid\\top\\mid p\\mid \\neg\\phi \\mid \\phi \\lor \\psi \\mid A[\\phi\\mathbf{U}\\psi]\\mid E[\\phi\\mathbf{U}\\psi]\\mid A\\mid E\\]  \n\n \nTodos os operadores temporais devem ser precedidos de  A  ( All , Todo) ou  E  ( Exists , Existe).  \n A  \\(\\phi\\): \\(\\phi\\) deve ser verdadeiro em todas as execuções a partir do estado atual;  \n E  \\(\\phi\\): Existe ao menos um caminho a partir do estado atual onde \\(\\phi\\) é verdade.  \n \n \n \n 4.2.  Visualização \n \n\n \n   \n Figure 2:  Fonte ( RAJU, 2014 ) \n \n \n \n \n \n 5.  Verificando propriedades \n \n \n \n 5.1.  LTL vs CTL \n \n \n Atenção:  \\(LTL \\nsubseteq CTL\\) and \\(CTL \\nsubseteq LTL\\)  \n\n \\(\\mathbf{F}(\\mathbf{G}p)\\) é uma fórmula LTL que não pode ser expressa em CTL.  \n \\(\\mathbf{EX}p\\) é uma fórmula CTL que não pode ser expressa em LTL.  \n \n \n \n 5.2.  Exemplo chaleiras - modelo \n \n\n \n   \n \n \n \n \n 5.3.  Exemplo chaleiras \n \n \nPS: Release é  V  nesse sistema  \n \n CTL:  \n EF(cem_graus) : true  \n esquentando -> AF cem_graus : false  \n esquentando -> EF temperatura_ambiente : true  \n EF(EG(!cem_graus)) : true  \n \n LTL:  \n F(temperatura_ambiente | cem_graus) : false  \n F(esquentando | esfriando) : true  A não ser que haja uma auto-transição em  temperatura_ambiente  \n \n \n \n \n 5.4.  Exemplo Adultos e Crianças - modelo \n \n\n \n   \n \n \n \n \n 5.5.  Exemplo Adultos e Crianças \n \n \n CTL:  \n EF trabalho : true  \n AF trabalho : false  \n \n LTL:  \n F trabalho : false  Não é possível expressar nada como  EF trabalho  \n \n formatura -> X(G(trabalho | adulto_dormir)) : true  \n formatura -> X(trabalho U adulto_dormir) : true  \n (F brincar) U formatura : false  \n \n \n \n 5.6.   Workaround  para falta do existencial com invariantes \n \n \nNa prática, quando queremos verificar o equivalente a  EF p  onde  p  é uma proposição (não uma fórmula temporal), fazemos o seguinte:  \n \nDefinimos  p  como uma invariante (isso é,  p  deve ser verdade em todos os estados)  \n \nRodamos o  model checker  \n \nInvertemos o resultado:  \n Se for “ok”, é porque a propriedade  EF p  é falsa  \n Se for uma violação, é porque a propriedade  EF p  é verdadeira (e o contra-exemplo é um exemplo de execução onde  F p  é verdade).  \n \n \n \n \n 5.7.  Referências \n \n \n    BULTAN, T.  Cs 267: Automated verification - lecture 2 . Disponível em: < https://sites.cs.ucsb.edu/~bultan/courses/267/lectures/l2.pdf >.  \n    RAJU, D.  Ltl and ctl - lecture notes by dhananjay raju . Disponível em: < https://www.cs.utexas.edu/~draju/Verification/class2.pdf >.  \n \n \n \n \n\n             \n         \n    ","url":"20240303165631-mfo_logica_temporal.html"},{"title":"Estruturas de Kripke","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Estruturas de Kripke \n                  Slides \n \n Table of Contents \n \n 1. Sistemas de transições \n 1.1. Sistema de transições: Definição \n 1.2. Sistema de transições: Definição formal \n 1.3. Sistemas de transições finito \n 1.4. Determinismo e Não-Determinismo \n \n 2. Estruturas de Kripke \n 2.1. Estruturas de Kripke \n 2.2. Exemplo:    Semáforo \n 2.3. Exercício:       Dois semáforos \n 2.4. Exercício:          Três semáforos \n 2.5. N semáforos em TLA+ \n 2.6. N semáforos em Quint \n 2.7. Perguntas \n \n 3. Não determinismo \n 3.1. Não determinismo nos semáforos \n 3.2. Não determinismo na realidade \n 3.3. Definindo a fronteira \n 3.4. Exemplo: Notas de alunos \n 3.5. Exemplo: Notas de alunos - input professor \n 3.6. Exemplo: Notas de alunos - escolhas dos alunos \n 3.7. Exemplo: Vôo com conexões \n 3.8. Exemplo: Vôo com conexões - Não determinismo \n 3.9. Exemplo: Vôo com conexões - Perdendo a conexão \n 3.10. Referências \n \n \n \n \n 1.  Sistemas de transições \n \n \n \n 1.1.  Sistema de transições: Definição \n \n Abstrações que descrevem o comportamento de sistemas com precisão matemática e sem ambiguidade ( BAIER; KATOEN, 2008 ) .  \n Podem ser vistos como grafos dirigidos onde  Os nós são  estados  \n As arestas são  transições  \n \n \nUm  estado  descreve as informações de um sistema em um momento específico.  \n\n \nUma  transição  descreve como um sistema pode mudar de um estado para outro.  \n \n \n \n 1.2.  Sistema de transições: Definição formal \n \n \nUm sistema de transições é definido pela tripla \\((S, \\to, I)\\) onde  \n \\(S\\) é um conjunto de estados,  \n \\(\\to\\ \\subseteq S \\times S\\) é uma relação de transições, e  \n \\(I \\subseteq S\\) é um conjunto de estados iniciais.  \n \nUm  comportamento  ou  execução  \\(\\rho\\) de um sistema de transições é uma sequência de estados tal que  \n\\[\\rho = s_0, s_1, \\dots\\ tal\\ que\\ s_i \\to s_{i+1}\\ para\\ todo\\ i \\geq 0\\]  \n \n \n \n 1.3.  Sistemas de transições finito \n \n \nUm sistema de transições é dito  finito  se e somente se \\(S\\) é finito.  \n\n \n Pergunta : Comportamentos de sistemas de transições finitos são sempre finitos?  \n\n \nNão! Comportamentos sobre uma sequência de estados ainda podem ser infinitos, mesmo que os estados sejam finitos.  \n \n \n \n 1.4.  Determinismo e Não-Determinismo \n \n \nO conjunto de  sucessores  de um estado \\(s\\) é definido por \\(Post(s) = \\{ s' \\in S\\ |\\ s \\to s' \\}\\).  \n\n \nUm sistema de transições é dito  determinístico  se e somente se \\(|I| \\leq 1 \\land \\forall s \\in S : |Post(s)| \\leq 1\\). Ou seja:  \n Tem apenas um estado inicial, e  \n Todo estado tem, no máximo, um sucessor.  \n \nNão-Determinismo acontece quando há múltiplos estados iniciais \\(|I| > 1\\) ou múltiplos sucessores para o mesmo estado (\\(|Post(s)| > 1\\)).  \n \n \n \n \n 2.  Estruturas de Kripke \n \n \n \n 2.1.  Estruturas de Kripke \n \n \nEstruturas de Kripke são um tipo de sistema de transições com uma restrição adicional:  \n \n \nA relação \\(\\to\\) deve ser total  \n \n\n \nou seja  \n\n \n \n\\(\\forall s \\in S, \\exists s' \\in S : s \\to s'\\)  \n \n \n  Estados terminais  \n \nEm sistemas de transições, um estado é dito terminal se \\(Post(s) = \\emptyset\\).  \n\n \nIsso não é possível em estruturas de Kripke, devido a restrição acima. Em  \nestruturas de Kripke, estados terminais são aqueles que possuem apenas  \ntransições para si mesmo, ou seja \\(Post(s) = \\{s\\}\\)  \n \n \n \n \n 2.2.  Exemplo:    Semáforo \n \n \nUm semáforo pode ser representado por uma estrutura de Kripke \\((S, \\to, I)\\) onde  \n \\(S = \\{ verde, amarelo, vermelho \\}\\)  \n \\(\\to = \\{ verde \\to amarelo, amarelo \\to vermelho, vermelho \\to verde \\}\\)  \n \\(I = \\{ vermelho \\}\\)  \n \n   \n \n \n \n \n 2.3.  Exercício:       Dois semáforos \n \n \nUm sistema com  dois  semáforos pode ser representado por uma estrutura de Kripke \\((S, \\to, I)\\) onde  \n \\(S = \\{ (1: vermelho\\ e\\ 2: vermelho), (1: amarelo\\ e\\ 2: vermelho), (1: verde\\ e\\ 2: vermelho),\n  (1: vermelho\\ e \\2: amarelo), (1: vermelho\\ e\\ 2: verde) \\}\\)  \n \\(\\begin{aligned}\n   \\to\\ = \\{ &\\\\\n      & (1: vermelho\\ e\\ 2: vermelho) \\to (1: verde\\ e\\ 2: vermelho),\\\\\n      & (1: verde\\ e\\ 2: vermelho) \\to (1: amarelo\\ e\\ 2: vermelho),\\\\\n      & (1: amarelo\\ e\\ 2: vermelho) \\to (1: vermelho\\ e\\ 2: vermelho),\\\\\n      & (1: vermelho\\ e\\ 2: vermelho) \\to (1: vermelho\\ e\\ 2: verde),\\\\\n      & (1: vermelho\\ e\\ 2: verde) \\to (1: vermelho\\ e\\ 2: amarelo),\\\\\n      & (1: vermelho\\ e\\ 2: amarelo) \\to (1: vermelho\\ e\\ 2: vermelho),\\\\\n    \\} &\n    \\end{aligned}\\)  \n \n\\(I = \\{ (1: vermelho\\ e\\ 2: vermelho ) \\}\\)  \n \n   \n \n\n \n https://forsyte.at/kripke/  \n\n AF(B_verde)  \n AF(A_vermelho & B_vermelho)  \n \n \n \n 2.4.  Exercício:          Três semáforos \n \n Vish!  \n Muita coisa pra escrever, certo?  \n Um jeito melhor: linguagens de especificação  \n \n  Vamos perceber algumas generalizações  \n Cada semáforo deve iniciar vermelho, e fazer o caminho vermelho \\(\\to\\) verde \\(\\to\\) amarelo enquanto os outros permanecem vermelhos.  \n Quando um semáforo fecha, queremos que  outro  semáforo abra  Com três semáforos, deve haver um revezamento que garanta que cada um vai abrir de vez em quando.  \n \n \n \n \n \n 2.5.  N semáforos em TLA+ \n \n\n \n   \n \n \n \n \n 2.6.  N semáforos em Quint \n \n \nEspecificação completa no GitHub.  \n\n \n module  semaforos {\n   type  Cor = Vermelho | Verde | Amarelo\n   type  Semaforo =  int \n\n   var  cores: Semaforo -> Cor\n   var  proximo: Semaforo\n\n   const  SEMAFOROS:  Set [Semaforo]\n\n   action  fica_verde(s: Semaforo):  bool  =  all  {\n    proximo == s,\n    SEMAFOROS.forall(s2 => cores.get(s2) == Vermelho),\n\n    cores' = cores.set(s, Verde),\n    proximo' = (s + 1) % SEMAFOROS.size(),\n  }\n\n  ...\n}\n \n \n \n \n \n 2.7.  Perguntas \n \n \nTodos os exemplos de semáforos (1, 2, 3 e N) são sistemas de transições. Quais deles são Estruturas de Kripke?  \n    Para um sistema de transições ser uma estrutura de Kripke, \\(\\to\\) deve ser total:  \\(\\forall s \\in S, \\exists s' \\in S : s \\to s'\\)  \n \n Resposta : Sim! Sempre há um passo para um próximo estado  \n \n \nOs sistemas de semáforos são finitos?  \n   Um sistema de transições é dito  finito  se e somente se \\(S\\) é finito.  \n Resposta : Sim! Os estados são um conjunto finito.  \n \n \nNossas definições de semáforo são determinísticas?  \n   O conjunto de  sucessores  de um estado \\(s\\) é definido por \\(Post(s) = \\{ s' \\in S\\ |\\ s \\to s' \\}\\).  \n   Sistema é deterministico sse \\(|I| \\leq 1 \\land \\forall s \\in S : |Post(s)| \\leq 1\\)  \n Resposta : Nem todas. A definição que demos para 2 semáforos contém não determinismo. As definições para 1 semáforo e N semáforos são determinísticas.  \n \n \n \n \n \n 3.  Não determinismo \n \n \n \n 3.1.  Não determinismo nos semáforos \n \n \nComo seriam semáforos com não determinismo?  \n \\(Post(s) = \\{ s' \\in S\\ |\\ s \\to s' \\}\\).  \n Sistema é deterministico sse \\(|I| \\leq 1 \\land \\forall s \\in S : |Post(s)| \\leq 1\\)  \n \nQualquer estado pode ser um estado inicial. Se definirmos isso (\\(I = S\\)), temos não determinismo  \n \\(|I| \\leq 1\\) não é satisfeito  \n \n \nCaso o primeiro semáforo a abrir não esteja definido  \n \\(|Post(1: vermelho\\ e\\ ...\\ e\\ N: vermelho\\ e\\ próximo: indefinido)| \\leq 1\\) não é satisfeito  \n \n \nCaso a definição de próximo seja removida  \n \\(|Post(1: vermelho\\ e\\ ...\\ e\\ N: vermelho)| \\leq 1\\) não é satisfeito  \n \n \n \n \n 3.2.  Não determinismo na realidade \n \n \nOnde podemos encontrar não determinismo em sistemas de software?  \n \nEscolhas de usuário  \n Depósitos e saques  \n Qualquer input em geral  \n \n \nFatores aleatórios  \n Se rolar 20 no dado, o dano é dobrado  \n \n \nInfluências do ambiente  \n Falha de hardware  \n Falha na rede  \n \n Ordem de execução quando há concorrência  Processo A executa antes do processo B  \n Requisição A é recebida antes da requisição B  \n \n \n \n \n 3.3.  Definindo a fronteira \n \n \nAo especificar um sistema, especialmente quando há não determinismo, é preciso definir uma fronteira.  \n Até aquela fronteira, fatores externos não especificados determinam o que acontece.  \n O não determinismo é uma forma de abstrair esses fatores externos  i.e. De A, vou pra B ou C. Isso depende de algum fator externo. Se é a jogada de um dado ou o input de um usuário, não me importa.  \n Se isso me importa, então vou modelar a jogada de dado.  \n \n \n \n \n 3.4.  Exemplo: Notas de alunos \n \n \nVamos considerar duas fronteiras diferentes:  \n \nO professor coloca uma nota no SIGA. Se a nota for \\(\\geq 7\\), o aluno passa.  \n Não determinismo no input do professor  \n \n O aluno pode ou não prestar atenção nas aulas. Se prestar atenção, vai se dar bem na prova, sua nota será maior que 7, e portanto vai passar.  Não determinismo nas escolhas do aluno  \n A nota que o professor dá é  determinada  pelas escolhas do aluno  \n \n \nNo caso (2) estamos detalhando mais o mundo externo fora do SIGA, enquanto no (1) a fronteira é na interface do SIGA.  \n\n \nO caso (1) é uma especificação do SIGA, enquanto o (2) fala mais sobre um sistema universitário.  \n \n \n \n 3.5.  Exemplo: Notas de alunos - input professor \n \n\n \n   \n \n \n \n \n 3.6.  Exemplo: Notas de alunos - escolhas dos alunos \n \n\n \n   \n \n \n \n \n 3.7.  Exemplo: Vôo com conexões \n \n \n Versão 1 :  \n \n \nJoinville → São Paulo → Paris  \n \n\n \n Versão 2 :  \n \n \nCheck-in em Joinville → Despacho de Bagagem em Joinville → Check de Segurança em Joinville → Embarque em Joinville → Pouso em São Paulo → Check de Segurança em São Paulo → Embarque em São Paulo → Pouso em Paris → Retirada de bagagem em Paris  \n \n \n \n \n 3.8.  Exemplo: Vôo com conexões - Não determinismo \n \n \nOnde poderia ter  não determinismo ?  \n Chegar atrasado e perder o check-in  \n Acharem uma bomba na bagagem  \n Problemas técnicos no vôo  \n Perder a conexão  \n \nPodemos ter não determinismo em cada estado. Nos casos listados, podemos ou não determinar o que acontece. Cabe ao nível de detalhe, ou a  fronteira  da nossa modelagem.  \n \n \n \n 3.9.  Exemplo: Vôo com conexões - Perdendo a conexão \n \n\n \n   \n \n\n\n \n   \n \n\n\n \n   \n \n \n \n \n 3.10.  Referências \n \n \n    BAIER, C.; KATOEN, J.-P.  Principles of model checking . Cambridge, MA: The MIT Press, 2008.  \n \n \n \n \n\n             \n         \n    ","url":"20240217142930-mfo_estruturas_de_kripke.html"},{"title":"Programação e matemática não são a mesma coisa","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Programação e matemática não são a mesma coisa \n                  Slides \n \n Table of Contents \n \n 1. Introdução \n 1.1. Essa aula não é sobre \n 1.2. Essa aula é sobre \n 1.3. Ainda sobre essa aula \n \n 2. Correspondências interessantes \n 2.1. Philip Wadler \n 2.2. Um pouco de história \n 2.3. Computabilidade \n 2.4. Correspondências interessantes - está tudo interligado! \n 2.5. A matemática é inventada ou descoberta? \n 2.6. A matemática é inventada ou descoberta? - Cont. \n 2.7. Isomorfismo de Curry-Howard \n 2.8. Interpretação algébrica para tipos \n 2.9. Exponenciação como tipos de funções I \n 2.10. Sistemas de tipos \n 2.11. Tipos dependentes \n 2.12. Funções parciais \n \n 3. Diferenças importantes \n 3.1. Erros vs indefinições \n 3.2. Funções vs Maps \n 3.3. Implementação vs definição \n 3.4. Em resumo \n 3.5. Referências \n \n \n \n \n 1.  Introdução \n \n \n \n 1.1.  Essa aula não é sobre \n \n \nEssa aula não é sobre:  \n “Precisa saber matemática pra programar?”  \n “Quem tem base matemática programa melhor?”  \n \n… que muitas vezes são derivados de “precisa ter faculdade pra trabalhar com programação?”  \n\n \nVocês estão cursando Ciência da Computação, então independente disso tudo, vão sim aprender uma base lógica/matemática.  \n \n \n \n 1.2.  Essa aula é sobre \n \n \nComo matemática e programação se relacionam, e a importância de entender as diferenças.  \n \n  Métodos Formais são sobre matemática ou sobre programação?  \n \nVamos trabalhar com ambos no mesmo ambiente, e o domínio sobre quando usar uma perspectiva ou outra é a principal habilidade para se escrever uma boa  especificação formal .  \n\n \nNo geral, nós, programadores, tendemos à  perspectiva da programação , e precisamos nos esforçar para descrever algumas coisas na  perspectiva matemática .  \n\n \nPara isso, primeiro precisamos entender as semelhanças e diferenças  \n \n \n \n \n 1.3.  Ainda sobre essa aula \n \n \nSe você gostar muito do conteúdo dessa aula:  \n Maravilha, considere fazer TCC/pesquisa sobre um dos assuntos!  \n Sinta-se motivado para a disciplina  \n \nSe você  não  gostar da aula e ela só te assustar:  \n Calma, a disciplina não vai ser nesse nível de loucura  \n Começamos tudo do básico na próxima aula, e a maioria do conteúdo dessa aula nem será visto na disciplina  \n \nPensem nisso como uma apresentação de feira de profissões (para a profissão métodos formais e adjacentes).  \n \n \n \n \n 2.  Correspondências interessantes \n \n \n \n 2.1.  Philip Wadler \n \n \nA primeira parte dessa aula é baseada na palestra/artigo do Philip Wadler ( WADLER, 2015 )  \n\n \n   \n \n \n \n \n 2.2.  Um pouco de história \n \n \nEm 1928, Hilbert propõe um desafio intitulado  entscheidungsproblem  (problema de decisão).  \n Ele acredita que existe um possível algoritmo que diz se uma declaração pode ou não ser provada pelas regras de uma lógica.  \n Isso é equivalente a afirmar que a lógica é completa: tudo o que é provado é verdadeiro, e tudo o que e verdadeiro é provável.  \n \nGödel prova a incompletude da lógica em 1931 (teorema da incompletude de Gödel). Ele mostra como representar o seguinte teorema em qualquer lógica capaz de representar aritmética:  \n \n \n“Esta declaração não é provável”  \n \n Se for verdade, não é provável  \n Se for provável, não é verdade  \n \n \n \n 2.3.  Computabilidade \n \n \nO primeiro computador (ENIAC) surgiu somente em 1946. Na época de Hilbert, o conceito de algoritmo é um conjunto de instruções a ser seguido por um humano.  \n Não havia uma definição formal do que é computabilidade/algoritmo  \n \nEnquanto as pessoas acreditavam que Hilbert estava correto, não havia necessidade de definir computabilidade.  \n Quando alguém encontrar a solução para o problema, a solução será um algoritmo.  \n \nPara mostrar que o  entscheidungsproblem  é indecidível, precisamos da definição de computabilidade  \n Para que seja possível mostrar que nenhum possível algoritmo pode resolver o problema.  \n \n \n \n 2.4.  Correspondências interessantes - está tudo interligado! \n \n \nEntão, as pessoas começam a tentar definir computabilidade. Surpreendentemente, três pessoas independentemente encontram soluções:  \n Em maio de 1935, Alonzo Church define o cálculo lambda  \n Em julho de 1935, Kurt Gödel (e seu aluno Kleene) define funções recursivas  \n Em maio de 1936, Alan Turing define maquinas de Turing  \n \nAs três são equivalentes!  \n \n \n \n 2.5.  A matemática é inventada ou descoberta? \n \n ( WADLER, 2015 ) Quais partes dessa imagem um alienígena tem mais chances de entender?  \n \n   \n \n\n Quais linguagens de programação eles teriam mais chances de entender?  \n \n \n \n 2.6.  A matemática é inventada ou descoberta? - Cont. \n \n \nWadler faz uma ótima argumentação de que a matemática é descoberta, o que ressoa muito comigo pessoalmente.  \n Se Church, Gödel e Turing tivessem inventado (e não descoberto) essas definições, quais as chances delas acabarem sendo equivalentes?  \n \nVamos ver mais um argumento de Wadler a favor dessa perspectiva: o Isomorfismo de Curry-Howard.  \n \n \n \n 2.7.  Isomorfismo de Curry-Howard \n \n Proposições como tipos  \n Provas como programas  \n Simplificação de provas como avaliação de programas  \n   Lógica \n Tipos \n Falso \n Void \n Verdadeiro \n () \n \\(a \\lor b\\) \n Either a b \n \\(a \\land b\\) \n (a,b) \n \\(a \\implies b\\) \n a -> b \n \nExemplo: implicação e abstração + aplicação  \n   Lógica \n Tipos \n \\({\\displaystyle {\\frac {}{\\Gamma _{1},\\alpha ,\\Gamma _{2}\\vdash \\alpha }}{\\text{Ax}}} \\rule{0pt}{4ex}\\) \n \\({\\displaystyle {\\frac {}{\\Gamma _{1},x:\\alpha ,\\Gamma _{2}\\vdash x:\\alpha }}}\\) \n \\({\\displaystyle {\\frac {\\Gamma ,\\alpha \\vdash \\beta }{\\Gamma \\vdash \\alpha \\rightarrow \\beta }}\\rightarrow I} \\rule{0pt}{8ex}\\) \n \\({\\displaystyle {\\frac {\\Gamma ,x:\\alpha \\vdash t:\\beta }{\\Gamma \\vdash \\lambda x.t:\\alpha \\rightarrow \\beta }}}\\) \n \\({\\displaystyle {\\frac {\\Gamma \\vdash \\alpha \\rightarrow \\beta \\qquad \\Gamma \\vdash \\alpha }{\\Gamma \\vdash \\beta }}\\rightarrow E} \\rule{0pt}{8ex}\\) \n \\({\\displaystyle {\\frac {\\Gamma \\vdash t:\\alpha \\rightarrow \\beta \\qquad \\Gamma \\vdash u:\\alpha }{\\Gamma \\vdash t\\;u:\\beta }}}\\) \n \n \n \n 2.8.  Interpretação algébrica para tipos \n \n A teoria das categorias define um nível ainda mais alto de abstração para enxergar algumas coisas. Um dos exemplos mais simples de uma categoria é a categoria dos conjuntos (e das funções entre eles) ( DE FRANÇA, 2019 ).  \n As chamadas categorias cartesianas fechadas podem ser relacionadas a nossa álgebra de ensino médio  A categoria dos tipos é uma delas!  \n \n    Lógica \n Tipos \n Álgebra \n Falso \n Void \n \\(0\\) \n Verdadeiro \n () \n \\(1\\) \n \\(a \\lor b\\) \n Either a b \n \\(a + b\\) \n \\(a \\land b\\) \n (a,b) \n \\(a * b\\) \n \\(a \\implies b\\) \n a -> b \n \\(b^a\\) \n \n \n \n 2.9.  Exponenciação como tipos de funções I \n \n \nVamos escrever tipos função ( a -> b ) como operações de exponenciação da álgebra:  \n \n\\(a^0 = 1\\) tem assinatura  Void -> a . Apenas uma função tem essa assinatura (em Haskell,  absurd )  \n \n\\(a^1 = a\\) tem assinatura  () -> a . O número de funções com esse tipo é o mesmo número de valores do tipo  a .  \n Por exemplo, pra  a  sendo  bool , temos  f x = false  e  f x = true  \n Qualquer outra versão de  f x  pra esse tipo será equivalente a uma dessas duas  \n \n \n\\(1^a = 1\\) tem assinatura  a -> () . Apenas uma função tem essa assinatura ( f x = () )  \n \n\\(a^{b+c}\\) tem assinatura  Either b c -> a  \n Para definir uma função desse tipo, temos que definir os casos  Left  com tipo  b -> a  e  Right  com tipo  c -> a  \n Ou seja, \\(a^{b + c} = a^b * a^c\\)  \n \n \n\\((a^b)^c\\) tem assinatura  c -> (b -> a)  \n Lembrando de currying, sabemos que isso é equivalente a  (c,b) -> a .  \n Ou seja, \\((a^b)^c = a^{(b*c)}\\)  \n \n \\((a*b)^c\\) tem assinatura  c -> (a, b)  Equivalente a um par de funções  c -> a  e  c -> b  \n Ou seja, \\((a*b)^c = a^c * b^c\\)  \n \n \n \n \n 2.10.  Sistemas de tipos \n \n Com tudo o que vimos até aqui, é seguro afirmar que istemas de tipos são uma parte da ciência da computação que tem uma grande intersecção com a matemática  \n Sistemas de tipos também são métodos formais: Definimos uma especificação (assinaturas de tipos) e o type checker é nosso sistema de verificação.  \n Estudar matemática avançada pode dar base para usos cada vez mais avançados de sistemas de tipos  Tipos dependentes  \n HoTT (Homotopy Type Theory)  \n \n \n \n \n 2.11.  Tipos dependentes \n \n \nTipos dependentes: quando o tipo depende do valor. No exemplo a seguir, usamos o sistema de tipos para provar que a função  map  não altera o tamanho de um vetor. Isso não é possível sem tipos dependentes.  \n \n map : {A B : Set} {n : Nat} -> (A -> B) -> Vec A n -> Vec B n\nmap f [] = []\nmap f (x :: xs) = f x :: map f xs\n \n \n\n \nTipos dependentes são uma parte importante de muitos assistentes de provas (como Coq e Agda). Bem provável que vamos ver mais sobre eles durante os seminários da disciplina.  \n \n \n \n 2.12.  Funções parciais \n \n \nAgora, um caso mais tangível para voltarmos um pouco para a nossa realidade.  \n \nNa matemática, funções podem ser totais ou parciais  \n Para transformar funções parciais em totais, adicionamos o valor bottom (\\(\\bot\\)) ao co-domínio e mapeamos todos os valores anteriormente indefinidos ao bottom.  \n \n Na computação, funções parciais precisam retornar o tipo soma. Dependendo da linguagem, pode ser algo como:  f(x: int): int | undefined  \n int -> Maybe int  \n \n \n \n \n \n 3.  Diferenças importantes \n \n \n \n 3.1.  Erros vs indefinições \n \n Na matemática, algumas fórmulas são indefinidas.  Divisão não está definida para denominador \\(0\\)  \n Exponenciação não está definida para \\(0^0\\)  \n \n Na programação, precisamos  definir  o que acontece nesses cenários  Normalmente, o que queremos é reportar algum tipo de erro  \n Programação envolve humanos. Humanos erram e precisam entender aonde erraram.  “Opa, você tentou dividir por 0 na linha X coluna Y” - pode salvar alguém de horas de debugging  \n \n \n \n \n \n 3.2.  Funções vs Maps \n \n \nFunções matemáticas podem ser programadas através de funções ou  Maps  ( KONNOV, 2024 ). Pense nos exemplos  \n Função de um número para seu dobro.  \n Função do nome da pessoa para sua idade.  \n \nNa programação, vamos considerar os fatores  \n Uso de Memória  \n Velocidade de resposta  \n \nNuma especificação formal, memória e velocidade não importam da mesma forma  \n \n \n \n 3.3.  Implementação vs definição \n \n \nImagine a seguinte definição:  \n Dada uma função que ordena uma lista de inteiros  \n \nO que você pensou sobre essa função?  \n \nBem possível que pensou em um ou mais algoritmos de ordenação (i.e. bubble sort, selection sort, quick sort)  \n \nNa matemática, não importa  como  a ordenação é feita. A função em questão poderia ser descrita mais precisamente por:  \n Seja \\(f: \\overline{\\mathbb{Z}} \\rightarrow \\overline{\\mathbb{Z}}\\) tal que \\(f(x)_i \\leq f(x)_{i+1}\\) para todo \\(i \\in [0, |x|-1)\\)  \n \nNuma especificação formal, se não há relevância no algoritmo de ordenação (contanto que ele, de fato, ordene), podemos economizar recursos na verificação ao especificar somente a propriedade de ordenação.  \n \n \n \n 3.4.  Em resumo \n \n Matemática e programação estão muito interligados  \n Contudo, há diferenças nos níveis de abstração entre o que costumamos descrever em definições matemáticas e em programas.  Em programas, nos importamos com memória e velocidade, o que normalmente não é representado na matemática.  \n Em programas, precisamos detalhar  como  cada função é implementada, enquanto na matemática podemos somente definir funções pelas suas propriedades.  Inclusive, precisamos detalhar o que acontece em casos indefinidos pela matemática, como divisão por 0.  \n \n \n \n \n \n 3.5.  Referências \n \n \n    DE FRANÇA, F. O.  Tipo função . Disponível em: < https://haskell.pesquisa.ufabc.edu.br/teoria-das-categorias/09-tipofuncao/ >.  \n    KONNOV, I.  You should not care about memory in protocol specifications . Disponível em: < https://konnov.github.io/protocols-made-fun/quint/2024/01/14/maps.html >.  \n    WADLER, P.  Propositions as types .  Commun. acm , v. 58, n. 12, p. 75–84, Nov. 2015.  \n \n \n \n \n\n             \n         \n    ","url":"20240213151141-mfo_programacao_e_matematica_nao_sao_a_mesma_coisa.html"},{"title":"Apresentação","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Apresentação \n                  Slides \n \n Table of Contents \n \n 1. Contexto \n 1.1. Sobre Métodos Formais \n 1.1.1. Essência \n 1.1.2. Histórico da disciplina \n \n 1.2. Sobre Mim \n 1.2.1. Sobre Mim \n 1.2.2. Meu envolvimento com Métodos Formais \n \n \n 2. Plano de Ensino \n \n 2.0.1. Vamos aprender TLA+ e Quint? \n 2.0.2. Vamos aprender TLA+ e Quint? - Continuação \n \n 2.1. Conteúdo \n 2.1.1. Plano de ensino \n 2.1.2. Conteúdo programático \n 2.1.3. Metodologia \n \n 2.2. Sistema de avaliação \n 2.2.1. Do desempenho do aluno \n 2.2.2. OFF: guia para navegar as avaliações \n 2.2.3. Exame \n 2.2.4. Do desempenho da disciplina e da professora \n \n 2.3. Bibliografia \n 2.3.1. Bibliografia básica \n 2.3.2. Bibliografia complementar \n \n \n 3. Recursos \n \n 3.0.1. Recursos \n \n \n \n \n \n 1.  Contexto \n \n \n \n 1.1.  Sobre Métodos Formais \n \n \n \n 1.1.1.  Essência \n \n \nMétodos formais são técnicas, embasadas na matemática, que visam verificar que algum hardware/software faz o que se propõe.  \n\n \nAs técnicas incluem dois componentes:  \n Uma linguagem de especificação  \n Um sistema de verificação  \n \n \n \n 1.1.2.  Histórico da disciplina \n \n Lá por 2015~2017, ensinava-se uma linguagem chamada Z  \n Em ~2018, ensinava-se Redes de Petri  \n Em 2019, o prof Cristiano assumiu a disciplina ensinando Coq  \n Em 2024/1, eu assumi a disciplina ensinando TLA+ (Temporal Logic of Actions+) e Quint  \n \n \n \n \n 1.2.  Sobre Mim \n \n \n \n 1.2.1.  Sobre Mim \n \n \nAcademia:  \n Ciência da Computação - UDESC - 2015-2019  TCC : Tradução automática de especificação formal modelada em TLA+ para linguagem de programação  \n \n Computação Aplicada - UDESC - 2020-2022  Dissertação : Test Generation From TLA+ Specifications  \n \n \nIndústria:  \n Magrathea Labs (agora Trusted Health) - 2018-2021  Estágio (5 meses) + Engenheira de Software  \n \n Informal Systems - 2021-presente  Engenheira de Pesquisa  \n \n \n \n \n 1.2.2.  Meu envolvimento com Métodos Formais \n \n Aprendi TLA+ na graduação para fazer meu TCC, e continuei estudando TLA+ no mestrado  \n \nEntrei na Informal Systems devido à pesquisa ativa (minha e deles) em TLA+  \n Muitos engenheiros com dificuldade em aprender e usar TLA+  \n \nTinham a proposta de uma nova syntaxe para TLA+, que chamamos hoje de  Quint  \n Sou a principal desenvolvedora dessa linguagem desde o início de 2022  \n \n \n \n \n \n \n \n 2.  Plano de Ensino \n \n \n \n 2.0.1.  Vamos aprender TLA+ e Quint? \n \n \nSim, mas vocês vão escolher em qual das duas fazer o primeiro trabalho  \n Na prova, sempre que houver exemplo de código, haverá versões nas duas linguagens  \n \nOs exemplos em aula poderão ser em qualquer uma das linguagens.  \n\n \nMinha expectativa é que vocês consigam entender especificações em ambas as linguagens, já que toda a base lógica para elas é a mesma - e a base lógica é a parte mais importante da disciplina.  \n \n \n \n 2.0.2.  Vamos aprender TLA+ e Quint? - Continuação \n \n \nTLA+ é uma linguagem de especificação bem estabelecida, e será nossa principal fundamentação teórica da disciplina  \n Alguns assuntos mais avançados vamos abordar somente em TLA+  \n \nQuint é opcional, vocês podem escolher fazer tudo em TLA+ se quiserem.  \n A linguagem e o ferramental de Quint pode facilitar bastante a vida de vocês.  \n O trabalho final será em Quint, mas vocês vão receber a especificação pronta.  Será necessário rodar comandos no terminal, então todos terão que instalar o Quint.  \n \n Vamos conversar mais sobre isso no decorrer das aulas.  \n \n \n \n 2.1.  Conteúdo \n \n \n \n 2.1.1.  Plano de ensino \n \n \nDisponível no SIGA (assim que for aprovado). Vamos ver juntos agora.  \n \n  Objetivo Geral  \n \nDesenvolver habilidades para reconhecimento de cenários, em sistemas computacionais, onde o uso de métodos formais é apropriado; e para aplicação de métodos formais.  \n \n \n  Objetivo Específico  \n Estimular o  senso de necessidade  de técnicas que auxiliem a garantir comportamentos em sistemas computacionais.  \n Desenvolver a  capacidade de abstração  ao descrever comportamentos de sistemas em linguagens de especificação formal.  \n Trabalhar técnicas de testes baseados em modelos para  conectar especificações com implementações .  \n \n \n \n \n 2.1.2.  Conteúdo programático \n \n Introdução: Programação e matemática não são a mesma coisa  \n Estruturas de Kripke  \n Lógica Temporal  \n Exemplo com semáforos  \n Motivação para o uso de métodos formais  \n Linguagens de especificação formal  \n Lógica Temporal de Ações: TLA+ e Quint  \n Exemplo com Jogo da Velha  \n Formulas temporais em TLA+ e Quint  \n Métodos formais no design de protocolos  \n Especificações para sistemas distribuídos  \n Exemplo sobre a efetivação em duas fases (two phase commit)  \n Verificação vs testes  \n Testes baseados em modelos  \n Outros métodos formais  \n Métodos formais no ciclo de desenvolvimento de software  \n Model checking  \n Refinamento  \n Model values e conjuntos de simetria  \n \n \n \n 2.1.3.  Metodologia \n \n \nA disciplina será desenvolvida através de aulas expositivo-dialogadas, com exercícios e trabalhos práticos, e seminários. O conteúdo da disciplina poderá ser ministrado na modalidade de ensino a distância em até 20% do total de sua Carga Horária (MEC PORTARIA No 4.059, DE 10 DE DEZEMBRO DE 2004 publicado no DOU de 13/12/2004, Seção 1, p. 34).  \n \n \n \n \n 2.2.  Sistema de avaliação \n \n \n \n 2.2.1.  Do desempenho do aluno \n \n \nA qualidade do desempenho do aluno será avaliada com base em:  \n Uma prova individual (P) - 30%  \n Dois trabalhos práticos (T1 e T2) - 25% cada  \n Um seminário (S) - 10%  \n Exercícios (E) - 10%  \n \nAssim, a Média Semestral (MS) será calculada pela fórmula  \n \nMS = (30 * P + 25 * T1 + 25 * T2 + 10 * S + 10 * E)/100  \n \n \n \n 2.2.2.  OFF: guia para navegar as avaliações \n \n O trabalho 1 é o mais trabalhoso e importante  \n O seminário é bem simples, mas não deixem de fazer porque depois a nota faz falta  É também mais no início do semestre onde vocês tem mais tempo livre  \n \n Os exercícios existem exclusivamente para prepará-los para o primeiro trabalho.  Eu não estava cobrando até semestre passado, mas decidi cobrar para incentivá-los a não chegarem despreparados para o trabalho.  \n \n O trabalho 2 é bem tranquilo. Pensem nele como um impulso extra para passar (e não como um motivo de desistir).  \n \n \n \n 2.2.3.  Exame \n \n \nCaso o discente não obtenha média MS igual ou superior a 7,0, um exame escrito será aplicado objetivando aferir o conhecimento teórico do estudante. Não há recuperação das provas por não comparecimento, exceto nos casos previstos no regulamento da UDESC na resolução 0392015 - CONSEPE.  \n \n \n \n 2.2.4.  Do desempenho da disciplina e da professora \n \n \nOs estudantes terão, igualmente, a oportunidade de fazer uma avaliação do desempenho da professora e da disciplina. As informações sobre esta atividade serão fornecidas pelo coordenador do curso.  \n \n \n \n \n 2.3.  Bibliografia \n \n \n \n 2.3.1.  Bibliografia básica \n \n \n  \n \n    BAIER, C.; KATOEN, J.-P.  Principles of model checking . Cambridge, MA: The MIT Press, 2008.  \n    LAMPORT, L.  Specifying systems: The tla+ language and tools for hardware and software engineers . Boston: Addison-Wesley, 2002.  \n    MONIN, J. F.; HINCHEY, M. G.  Understanding formal methods . Berlin, Heidelberg: Springer-Verlag, 2001.  \n \n \n \n \n 2.3.2.  Bibliografia complementar \n \n \n  \n \n    KONNOV, I.; KUKOVEC, J.  Tla+ language reference manual . Disponível em: < https://apalache.informal.systems/docs/lang/index.html#tla-language-reference-manual- >.  \n    LAMPORT, L.  A science of concurrent programs . 2024. Disponível em: < https://lamport.azurewebsites.net/tla/science.pdf >.  \n    TEAM, T. Q.  Quint . Disponível em: < https://quint-lang.org >.  \n \n \n \n \n \n \n 3.  Recursos \n \n \n \n 3.0.1.  Recursos \n \n Aulas em HTML no meu site:  bugarela.com/mfo  Todo o conteúdo dos slides  \n \n Toda a bibliografia tem disponível online gratuitamente  \n Páginas web relevantes  TLA+:  https://lamport.azurewebsites.net/tla/tla.html  \n Quint:  https://quint-lang.org  \n \n \n \n \n\n             \n         \n    ","url":"20240210123703-mfo_apresentacao.html"}]