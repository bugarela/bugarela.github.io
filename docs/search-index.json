[{"title":"Homepage","content":"\n     \n       \n   \n     \n     \n     \n       \n           Gabriela Moreira \n       \n       \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n       \n       \n   Created using Emacs and  org-mode \n \n\n     \n   \n \n\n       \n         Homepage \n         \n Índice \n \n Apresentação \n Aulas \n Trabalho 1 \n \n \n \n Apresentação \n \n \n Aulas \n \n Testando um problema da maratona \n Programação e matemática não são a mesma coisa \n Estruturas de Kripke \n Checando propriedades com Lógica Temporal \n Checando propriedades com Lógica Temporal II \n Por que e pra que métodos formais? \n Introdução à Lógica Temporal das Ações \n Primeiras Especificações \n Revisão de programação funcional em Quint \n Jogo da Velha em Quint \n Introdução ao TLA+ \n Primeiras Especificações em TLA+ \n Exercícios Pokemon \n Especificar vs Implementar \n Efetivação em Duas Fases \n Design de protocolos \n Propriedades \n \n \n \n Trabalho 1 \n \n Trabalho 1 \n FAQ Trabalho 1 \n Dicas Trabalho 1 \n \n \n\n       \n     \n  ","url":"sitemap.html"},{"title":"Métodos Formais ","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Métodos Formais  \n                    \n  \n Links úteis \n \n Apresentação \n Cheatsheet Lógica Temporal (PDF) \n Exercícios para a prova \n \n \n Quint \n \n Getting Started: Quint \n Exemplos \n \n \n \n TLA+ \n \n Getting Started: TLA+ \n Exemplos \n \n \n \n \n Aulas \n \n \n \n Motivação \n \n Programação e matemática não são a mesma coisa \n \n \n \n\n             \n         \n    ","url":"index.html"},{"title":"TLA+ Getting Started","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 TLA+ Getting Started \n                  \nEsse é um pequeno guia cobrindo desde a instalação até sua primeira verificação em TLA+. Baseado no  Getting Started do Quint .\n \n\n \nInstalar a extensão TLA+ Nightly no VSCode\nAbra o painel de extensões (Ctrl+Shift+X ou clicando no ícone)\nProcure por TLA+ Nightly e clique e instalar\n \n Se a extensão “TLA+” estiver instalada, desinstale-a, porque as duas não funcionam bem juntas. A versão Nightly tem mais features, e vamos precisar de uma delas logo. \n \nPS: Se aparecer pra você que essa versão está depreciada e recomendar a nova “TLA+ (Temporal Logic of Actions)”, pode instalar a nova. Na aula de segunda isso não apareceu pra mim, mas vi esse aviso no meu computador de casa agora. Eles acabaram de lançar essa versão, e ela parecer ter tudo o que vamos precisar pra disciplina, então tudo bem. Se instalarem essa, lembrem de desinstalar a TLA+/TLA+ Nightly.\n \n\n \nEscreva sua primeira especificação\nPara rodar as ferramentas do TLA+, precisamos primeiro de uma especificação em TLA+. Vamos usar a seguinte especificação de um banco, que tem um bug:\n \n \n --------------------------  MODULE  bank --------------------------\n EXTENDS  Integers\n\n \\* A state variable to store the balance of each account \n VARIABLE  balances\n\nADDRESSES == {  \"alice\" ,  \"bob\" ,  \"charlie\"  }\n\nDeposit(account, amount) ==\n   \\* Increment balance of account by amount \n  balances' = [balances  EXCEPT  ![account] = @ + amount]\n\nWithdraw(account, amount) ==\n   \\* Decrement balance of account by amount \n  balances' = [balances  EXCEPT  ![account] = @ - amount]\n\nInit ==\n   \\* At the initial state, all balances are zero \n  balances = [ addr \\in ADDRESSES |->  0  ]\n\nNext ==\n   \\* Non-deterministically pick an address and an amount \n  \\E account \\in ADDRESSES, amount \\in  1 .. 100  :\n     \\* Non-deterministically choose to either deposit or withdraw \n    \\/ Deposit(account, amount)\n    \\/ Withdraw(account, amount)\n\nNoNegatives == \\A addr \\in ADDRESSES : balances[addr] >=  0 \n=================================================================\n \n \n\n \nCrie um arquivo  bank.tla  com o conteúdo acima. O arquivo deve ter esse nome, porque em TLA+, o nome do modulo deve ser idêntico ao do arquivo. Vamos tentar checar a invariante  NoNegatives , que diz que nenhum dos saldos ( balances ) pode ser negativo. Uma invariante é algo que precisa ser verdadeiro em todos os estados alcançáveis.\n \n\n \nAdicionalmente, precisamos de um arquivo  bank.cfg  para configurar os parâmeros, com o conteúdo a seguir.\n \n \n INIT\nInit\n\nNEXT\nNext\n\nINVARIANT\nNoNegatives\n \n \n\n \nEncontrando uma violação\nPrimeiro, vamos usar o modo de simulação para encontrar uma violação. Esse modo vai tentar várias (mas não todas) execuções.\n \n\n Abra o arquivo  bank.tla  e use F1 ou Ctrl+Shift+P para abrir o menu de comandos do VSCode \n Selecione a opção “TLA+: Check model with TLC” \n No prompt que aparece, substitua o valor padrão  -coverage=1  por  -simulate num=10000  para rodar o TLC no modo de simulação com 10 mil amostras e aperte Enter. \n \nIsso deve resultar em uma violação, mostrando uma execução onde alguém fica com saldo negativo.\n \n\n \nConsertando o bug\nAtualize a definição  Withdraw  para previnir que esse cenário aconteça: usuários não deveriam poder sacar mais do que eles tem em saldo.\n \n\n \n Withdraw(account, amount) ==\n   \\* A precondition, there should be enough to withdraw \n  /\\ balances[account] >= amount\n   \\* Decrement balance of account by amount \n  /\\ balances' = [balances  EXCEPT  ![account] = @ - amount]\n \n \n\n \nAgora, podemos rodar o simulador novamente (repetir passo 3) e nenhuma violação deve ser encontrada.\n \n\n \nVerificando o resultado\n \n\n \nContudo, o simulador pode não ter considerado algumas execuções. Para ter certeza que o problema foi consertado, devemos rodar o  model checker . O TLC não é um model checker limitado, e como essa especificação lida com inteiros arbitrários, ele vai ficar rodando até ficar sem memória. Então, precisamos antes restringir nosso espaço de busca. Vamos modificar nosso  Next  para que a execução só consiga progredir enquanto os saldos forem menor do que  50  (você pode diminuir esse número se o TLC ainda estiver demorando muito):\n \n \n Next ==\n   \\* Only continue if balance is small enough to avoid a big state space \n  /\\ \\A addr \\in ADDRESSES : balances[addr] <=  50 \n   \\* Non-deterministically pick an address and an amount \n  /\\ \\E account \\in ADDRESSES, amount \\in  1 .. 100  :\n       \\* Non-deterministically choose to either deposit or withdraw \n      \\/ Deposit(account, amount)\n      \\/ Withdraw(account, amount)\n \n \n\n \nAgora podemos rodar:\n \n Abra o arquivo  bank.tla  e use F1 ou Ctrl+Shift+P para abrir o menu de comandos do VSCode \n Selecione a opção “TLA+: Check model with TLC” \n No prompt que aparece, substitua o valor por  -deadlock  e aperte Enter. Como introduzimos um deadlock na nossa especificação (ela não progride quando o saldo fica maior que 50), precisamos pedir pro TLC ignorar deadlocks, e por isso passamos a flag  -deadlock . \n \nEsse comando irá verificar todas as possíveis execuções, e deve retornar sucesso, o que significa que de fato consertamos o problema e não temos mais saldos negativos.\n \n \n         \n    ","url":"20240828153443-tla_getting_started.html"},{"title":"Exercícios para a prova","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Exercícios para a prova \n                  Table of Contents \n \n Estruturas de Kripke \n Questão 1 \n Questão 2 \n \n Lógica temporal \n Questão 3 \n Questão 4 \n \n Propriedades e Suposições \n Questão 5 \n Questão 6 \n Questão 7 \n \n Perguntas gerais \n Questão 8 \n \n TLA+ e Quint \n Questão 9 \n Especificação A \n Especificação B \n \n Questão 10 \n Questão 11 \n Questão 12 \n \n \n \n Estruturas de Kripke \n \n \n \n Questão 1 \n \n \nIdentifique em quais estruturas de Kripke a seguir tem não-determinismo e  justifique sua resposta .\n \n \nSemáforos. Considere o conjunto de estados inicial \\(I = \\{vermelho\\}\\)\n \n\n  [Resposta] \nDeterminístico (não há não-determinismo), porque existe somente um estado inicial e, para cada um dos três estados, há apenas uma possível transição.\n \n \n\n \nChaleira. Considere o conjunto de estados inicial \\(I = \\{temperatura\\_ambiente\\}\\)\n \n\n  [Resposta] \nNão-determinístico (há não-determinismo), porque, para os estados “esquentando” e “esfriando”, há mais de uma transição possível.\n \n \n \n \n \n Questão 2 \n \n \nDefina uma estrutura de Kripke para um sistema de caixa da água com as seguintes características:\n \n A caixa da água contém uma bóia que impede que ela transborde, ou seja, a bóia interrompe o enchimento quando a caixa está completamente cheia. \n A caixa não enche enquanto está sendo usada, ou seja, ela não pode estar enchendo e esvaziando ao mesmo tempo. \n Se a caixa está vazia, ela não pode ser esvaziada. \n O sistema inicia com a caixa vazia \n \nPS: Tente usar o mínimo de estados e transições necessários para representar esse sistema.\n \n [Resposta] \\(S = \\{vazia, enchendo, cheia, esvaziando\\}\\) \n \\(\\rightarrow = \\{vazia \\rightarrow enchendo, enchendo \\rightarrow esvaziando, enchendo \\rightarrow cheia, cheia \\rightarrow esvaziando, esvaziando \\rightarrow enchendo, esvaziando \\rightarrow vazia\\}\\) \n \\(I = \\{vazia\\}\\) \n \n \n \n \n Lógica temporal \n \n \n \n Questão 3 \n \n \nDada uma fórmula temporal e uma execução, indique se a fórmula é verdadeira ou falsa para a execução. Ou seja, responda verdadeiro se a execução satisfaz a fórmula e falso caso não satisfaça. Considere que \\(a\\) e \\(b\\) são proposições.\n \n\n Fórmula: \\(X(b)\\)\n [ ]  \\([b], [b], [a]\\) \n [ ]  \\([a], [b], [a]\\) \n [ ]  \\([a], [a], [b]\\) \n \n Fórmula: \\(a -> b\\)\n [ ]  \\([a], [a], [a]\\) \n [ ]  \\([a], [b], [a]\\) \n [ ]  \\([a, b], [a], [a]\\) \n [ ]  \\([b], [a], [a]\\) \n \n Fórmula: \\(F(a)\\)\n [ ]  \\([a], [a], [a]\\) \n [ ]  \\([b], [a], [b]\\) \n \n [Resposta] Fórmula: \\(X(b)\\)\n [V] \\([b], [b], [a]\\) \n [V] \\([a], [b], [a]\\) \n [F] \\([a], [a], [b]\\) \n \n Fórmula: \\(a -> b\\)\n [F] \\([a], [a], [a]\\) \n [F] \\([a], [b], [a]\\) \n [V] \\([a, b], [a], [a]\\) \n [V] \\([b], [a], [a]\\) \n \n Fórmula: \\(F(a)\\)\n [V] \\([a], [a], [a]\\) \n [V] \\([b], [a], [b]\\) \n \n \n \n \n Questão 4 \n \n \nExplique a diferença entre LTL (Lógica Temporal Linear) e CTL (Lógica de árvore computacional -  Computational Tree Logic ).\n \n [Resposta] \nA representação de árvore da CTL permite que usemos quantificações existenciais com nossas fórmulas temporais: existe alguma execução onde eventualmente X. Já na LTL, todas as fórmulas são implicitamente universalmente quantificadas, e isso não é possível. Essa diferença faz com que existam fórmulas na LTL que não podem ser espressadas em CTL e fórmulas na CTL que não podem ser espressadas na LTL.\n \n \n \n \n \n Propriedades e Suposições \n \n \n \n Questão 5 \n \n \nAssinale as fórmulas abaixo com [V] (verdadeiro) se a propriedade pode ser espressa com uma invariante ou [F] (falso) caso seja preciso uma fórmua temporal. Lembre-se que não importa se a fórmula é verdadeira ou falsa.\n \n [ ]  Para cada compra no cartão de crédito, vem uma cobrança na fatura ao final do mês. \n [ ]  Nunca vou para a academia sem meus fones de ouvido \n [ ]  Em algum momento vou terminar de pagar as parcelas do meu apartamento \n [ ]  Sempre uso óculos para dirigir \n [ ]  Não é possível estar na aula e no shopping ao mesmo tempo \n [ ]  Todos os códigos em C++ serão migrados para Rust \n [Resposta] [F] Para cada compra no cartão de crédito, vem uma cobrança na fatura ao final do mês. \n [V] Nunca vou para a academia sem meus fones de ouvido \n [F] Em algum momento vou terminar de pagar as parcelas do meu apartamento \n [V] Sempre uso óculos para dirigir \n [V] Não é possível estar na aula e no shopping ao mesmo tempo \n [F] Todos os códigos em C++ serão migrados para Rust \n \n \n \n Questão 6 \n \n \nLeia a contextualização e responda:\n \n \n \nEstou vendendo peças de computador e contrato uma transportadora para fazer as entregas. Essas peças são frágeis, e podem quebrar se não forem transportadas de maneira adequada. A caixa não pode ser virada (a mesma face deve permanecer para cima durante todo o transporte), e não pode se mover no baú do caminhão. Para ter certeza de que a transportadora está fazendo seu serviço corretamente, instalei câmeras internas nos baús dos caminhões que me enviam fotos a cada 5 minutos. Agora, só preciso analisar essas fotos e determinar se a transportadora cumpre os requisitos.\n \n \n\n \nConsiderando uma execução dada pela sequência de fotos enviadas, escreva propriedades de segurança e vivacidade que digam sobre a qualidade do serviço da transportadora. Informe o tipo (invariante/temporal e segurança/vivacidade) de cada propriedade. Liste também que tipo de suposições estão sendo feitas para viabilizar essa análise.\n \n\n [Resposta] \nPropriedades:\n \n Invariante de segurança: a face de cima da caixa está para cima \n Temporal de segurança: sempre (a posição da caixa no próximo estado é a mesma que no estado atual ou ela é retirada pra entrega) \n Temporal de vivacidade: eventualmente a caixa é retirada para entrega \n \nSuposições:\n \n é possível determinar a posição da caixa em cada foto \n é possível determinar se a face correta da caixa está pra cima \n se a caixa for retirada, é por conta de uma entrega \n \n \n \n Questão 7 \n \n \nAlice e Bob estavam combinando de se encontrar e Alice mandou a seguinte mensagem para Bob: “Encontre-me as 15h na cafeteria Café Quentinho”. Ao fazer essa comunicação, Alice estava supondo algumas coisas. Descreva qual suposição de Alice estava errada para cada um dos cenários a seguir.\n \n \nBob não apareceu. A bateria do celular dele acabou antes que visse a mensagem de Alice.\nResponda: Alice assumiu que …\n \n [Resposta] \nAlice assumiu que Bob havia recebido a mensagem dela.\n \n \n \nBob foi em outro Café Quentinho - acontece que havia outra cafeteria com esse nome em outro bairro.\nResponda: Alice assumiu que …\n \n [Resposta] \nAlice assumiu que havia apenas uma “Café Quentinho” na cidade\n \n \n \nQuando Alice chegou, o Bob já estava lá por uma hora. Ele havia esquecido de ajustar seu relógio no fim do horário de verão.\nResponda: Alice assumiu que …\n \n [Resposta] \nAlice assumiu que o relógio de Bob estava no mesmo horário que o dela.\n \n \n \n \n \n \n Perguntas gerais \n \n \n \n Questão 8 \n \n \nSuponha que temos um modelo e uma propriedade que é violada numa execução de 5 passos. Considere que estamos usando um simulador aleatório com até 10.000 amostras e 10 passos, e um  model checker  com até 10 passos. Assinale com verdadeiro ou falso  e justifque sua resposta .\n \n [ ]  O simulador irá encontar um contraexemplo para propriedades \n [ ]  O  model checker  encontrará um contraexemplo de 5 passos \n [ ]  O  model checker  demorará mais tempo que o simulador para responder \n [ ]  O simulador demorará mais tempo que o  model checker  para responder \n [ ]  O  model checker  poderá finalizar a execução sem encontrar o contraexemplo \n [ ]  O simulador pode encontrar um contraexemplo de 9 passos \n [Resposta] [F] O simulador irá encontar um contraexemplo para propriedades \n [V] O  model checker  encontrará um contraexemplo de 5 passos \n [F] O  model checker  demorará mais tempo que o simulador para responder \n [F] O simulador demorará mais tempo que o  model checker  para responder \n [F] O  model checker  poderá finalizar a execução sem encontrar o contraexemplo \n [V] O simulador pode encontrar um contraexemplo de 9 passos \n \n \n \n \n TLA+ e Quint \n \n \n \n Questão 9 \n \n \nDada uma especificação simples, escreva uma breve descrição do que ela faz. Observe o seguinte exemplo:\nQuint:\n \n \n var  x:  int \n\n action  init = x' = 0\n\n action  step = x' =  if  (x < 10) x + 1  else  x\n \n \n\n \nTLA+:\n \n \n VARIABLE  x\n\nInit == x =  0 \n\nNext == x' =  IF  (x <  10 )  THEN  x +  1   ELSE  x\n \n \n\n \nPoderíamos descrever como: Um modelo onde x começa em zero e é incrementado até chegar a 10, com incrementos de tamanho 1. Ao chegar a 10, x permanece com o mesmo valor pra sempre\n \n\n \nAgora, responda com uma descrição para cada especificação abaixo:\n \n \n \n Especificação A \n \n \nQuint:\n \n \n var  x:  int \n\n action  init = x' = 0\n\n action  step =  any  {\n   all  {\n    x < 5,\n    x' = x + 1\n  },\n   all  {\n    x > -5,\n    x' = x - 1\n  }\n}\n \n \n\n \nTLA+\n \n \n VARIABLE  x\n\nInit == x =  0 \n\nNext ==\n  \\/ /\\ x <  5 \n     /\\ x' = x +  1 \n  \\/ /\\ x > -5\n     /\\ x' = x -  1 \n\n \n \n\n [Resposta] \nUm modelo onde x começa em zero e pode ser incrementado em 1 caso seja menor que 5, ou decrementado em 1 caso seja maior que -5. Ou seja, a cada passo x terá seu valor modificado (mais um ou menos um) e permanecerá sempre entre -5 e 5.\n \n \n \n \n Especificação B \n \n \nQuint:\n \n \n var  x:  int \n\n action  init = x' = 1\n\n action  step = {\n   nondet  v = 1.to(10).oneOf()\n   all  {\n    x != v,\n    x' = v\n  }\n}\n \n \n\n \nTLA+:\n \n \n VARIABLE  x\n\nInit == x =  1 \n\nNext == \\E v \\in  1 .. 10 :\n  /\\ x /= v\n  /\\ x' = v\n \n \n\n [Resposta] \nUm modelo onde x começa em 1 e a cada passo recebe um novo valor, diferente do atual, entre 1 e 10.\n \n \n \n \n \n Questão 10 \n \n \nConsidere o modelo a seguir:\n \n\n \nQuint:\n \n \n var  x:  int \n\n action  init = x' = 10\n\n action  step =  any  {\n   all  {\n    x < 20,\n    x % 2 == 0,\n    x' = x + 3\n  },\n   all  {\n    x > 5,\n    x' = x - 1\n  }\n}\n \n \n\n \nTLA+:\n \n \n VARIABLE  x\n\nInit == x =  10 \n\nNext ==\n  \\/ /\\ x <  20 \n     /\\ x %  2  =  0 \n     /\\ x' = x +  3 \n  \\/ /\\ x >  5 \n     /\\ x' = x -  1 \n \n \n\n \nPara cada execução a seguir, assinale verdadeiro se o modelo permite a execução e falso caso contrário. Quando responder falso,  justifique sua resposta .\n \n [ ]   x: 7, x: 6, x: 9, x: 8 \n [ ]   x: 10, x: 13, x: 12, x: 11, x: 10 \n [ ]   x: 10, x: 9, x: 8, x: 11 \n [ ]   x: 10, x: 9, x: 12, x: 15 \n [Resposta] [F]  x: 7, x: 6, x: 9, x: 8 \n x não pode ser 7 no estado inicial. Deve ser 10. \n \n [V]  x: 10, x: 13, x: 12, x: 11, x: 10 \n [V]  x: 10, x: 9, x: 8, x: 11 \n [F]  x: 10, x: 9, x: 12, x: 15 \n não podemos somar 3 ao 9 para chegar em 12, porque uma das pré-condições para somar 3 é que x seja divisível por 2, e 9 não é. \n \n \n \n \n Questão 11 \n \n \nO operador primed ( ' ) permite que escrevamos predicados sobre o próximo estado. Assinale verdadeiro se o operador primed está sendo usado corretamente, ou falso se o uso resultará em um erro. Caso responder falso,  justifique sua resposta . Considere que x e y são variáveis. As respostas para Quint ou TLA+ são as mesmas, responda apenas uma delas.\n \n\n \nQuint:\n \n [ ]   all { x' = 1, x' = 2 } \n [ ]   any { x' = 1, x' = 2 } \n [ ]   all { x' = 1, y' = 2 } \n [ ]   any { x' = 1, y' = 2 } \n \nTLA+:\n \n [ ]   x' = 1 /\\ x' = 2 \n [ ]   x' = 1 \\/ x' = 2 \n [ ]   x' = 1 /\\ y' = 2 \n [ ]   x' = 1 \\/ y' = 2 \n [Resposta] \nQuint:\n \n [F]  all { x' = 1, x' = 2 } \n x é atualizado duas vezes na mesma ação \n \n [V]  any { x' = 1, x' = 2 } \n [V]  all { x' = 1, y' = 2 } \n [F]  any { x' = 1, y' = 2 } \n atualização desbalanceada: em uma das ramificações apenas x é atualizado, e em outra apenas y \n \n \nTLA+:\n \n [F]  x' = 1 /\\ x' = 2 \n x é atualizado duas vezes na mesma ação \n \n [V]  x' = 1 \\/ x' = 2 \n [V]  x' = 1 /\\ y' = 2 \n [F]  x' = 1 \\/ y' = 2 \n atualização desbalanceada: em uma das ramificações apenas x é atualizado, e em outra apenas y \n \n \n \n \n Questão 12 \n \n \nAgora escreva a propriedade em Quint ou em TLA+ para:\n \n\n “Não é possível estar na aula e no shopping ao mesmo tempo”. Considere que existam duas variáveis de estado do tipo  bool :  na_aula  e  no_shopping . \n “Sempre uso óculos para dirigir”. Considere que existam duas variáveis de estado do tipo  bool :  estou_dirigindo  e  estou_de_oculos . \n “Em algum momento vou terminar de pagar as parcelas do meu apartamento”. Considere que exista uma variável de estado do tipo  int  para o número restante de parcelas:  parcelas_restantes . \n “Todos os códigos em C++ serão migrados para Rust”. Considere que exista uma variável  codigos  do tipo  int -> { codigo: str, linguagem: str }  sendo a chave (domínio) um identificador único daquele código e o campo  linguagem  pode conter  \"c++\" ,  \"haskell\"  ou  \"rust\" . \n [Resposta] not(na_aula) or not(no_shopping) \n estou_dirigindo implies estou_de_oculos \n eventually(parcelas_restantes == 0) \n codigos.keys().forall(k => codigos.get(k).linguagem ==  \"c++\"   implies  eventually(codigos.get(k).linguagem ==  \"rust\" )) \n \n \n \n\n             \n         \n    ","url":"20240525134648-mfo_exercicios_para_a_prova.html"},{"title":"Programação e matemática não são a mesma coisa","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Programação e matemática não são a mesma coisa \n                  Slides \n \n Table of Contents \n \n 1. Introdução \n 1.1. Essa aula não é sobre \n 1.2. Essa aula é sobre \n 1.3. Ainda sobre essa aula \n \n 2. Correspondências interessantes \n 2.1. Philip Wadler \n 2.2. Um pouco de história \n 2.3. Computabilidade \n 2.4. Correspondências interessantes - está tudo interligado! \n 2.5. A matemática é inventada ou descoberta? \n 2.6. A matemática é inventada ou descoberta? - Cont. \n 2.7. Isomorfismo de Curry-Howard \n 2.8. Interpretação algébrica para tipos \n 2.9. Exponenciação como tipos de funções I \n 2.10. Sistemas de tipos \n 2.11. Tipos dependentes \n 2.12. Funções parciais \n \n 3. Diferenças importantes \n 3.1. Erros vs indefinições \n 3.2. Funções vs Maps \n 3.3. Implementação vs definição \n 3.4. Em resumo \n 3.5. Referências \n \n \n \n \n 1.  Introdução \n \n \n \n 1.1.  Essa aula não é sobre \n \n \nEssa aula não é sobre:  \n “Precisa saber matemática pra programar?”  \n “Quem tem base matemática programa melhor?”  \n \n… que muitas vezes são derivados de “precisa ter faculdade pra trabalhar com programação?”  \n\n \nVocês estão cursando Ciência da Computação, então independente disso tudo, vão sim aprender uma base lógica/matemática.  \n \n \n \n 1.2.  Essa aula é sobre \n \n \nComo matemática e programação se relacionam, e a importância de entender as diferenças.  \n \n  Métodos Formais são sobre matemática ou sobre programação?  \n \nVamos trabalhar com ambos no mesmo ambiente, e o domínio sobre quando usar uma perspectiva ou outra é a principal habilidade para se escrever uma boa  especificação formal .  \n\n \nNo geral, nós, programadores, tendemos à  perspectiva da programação , e precisamos nos esforçar para descrever algumas coisas na  perspectiva matemática .  \n\n \nPara isso, primeiro precisamos entender as semelhanças e diferenças  \n \n \n \n \n 1.3.  Ainda sobre essa aula \n \n \nSe você gostar muito do conteúdo dessa aula:  \n Maravilha, considere fazer TCC/pesquisa sobre um dos assuntos!  \n Sinta-se motivado para a disciplina  \n \nSe você  não  gostar da aula e ela só te assustar:  \n Calma, a disciplina não vai ser nesse nível de loucura  \n Começamos tudo do básico na próxima aula, e a maioria do conteúdo dessa aula nem será visto na disciplina  \n \nPensem nisso como uma apresentação de feira de profissões (para a profissão métodos formais e adjacentes).  \n \n \n \n \n 2.  Correspondências interessantes \n \n \n \n 2.1.  Philip Wadler \n \n \nA primeira parte dessa aula é baseada na palestra/artigo do Philip Wadler ( WADLER, 2015 )  \n\n \n   \n \n \n \n \n 2.2.  Um pouco de história \n \n \nEm 1928, Hilbert propõe um desafio intitulado  entscheidungsproblem  (problema de decisão).  \n Ele acredita que existe um possível algoritmo que diz se uma declaração pode ou não ser provada pelas regras de uma lógica.  \n Isso é equivalente a afirmar que a lógica é completa: tudo o que é provado é verdadeiro, e tudo o que e verdadeiro é provável.  \n \nGödel prova a incompletude da lógica em 1931 (teorema da incompletude de Gödel). Ele mostra como representar o seguinte teorema em qualquer lógica capaz de representar aritmética:  \n \n \n“Esta declaração não é provável”  \n \n Se for verdade, não é provável  \n Se for provável, não é verdade  \n \n \n \n 2.3.  Computabilidade \n \n \nO primeiro computador (ENIAC) surgiu somente em 1946. Na época de Hilbert, o conceito de algoritmo é um conjunto de instruções a ser seguido por um humano.  \n Não havia uma definição formal do que é computabilidade/algoritmo  \n \nEnquanto as pessoas acreditavam que Hilbert estava correto, não havia necessidade de definir computabilidade.  \n Quando alguém encontrar a solução para o problema, a solução será um algoritmo.  \n \nPara mostrar que o  entscheidungsproblem  é indecidível, precisamos da definição de computabilidade  \n Para que seja possível mostrar que nenhum possível algoritmo pode resolver o problema.  \n \n \n \n 2.4.  Correspondências interessantes - está tudo interligado! \n \n \nEntão, as pessoas começam a tentar definir computabilidade. Surpreendentemente, três pessoas independentemente encontram soluções:  \n Em maio de 1935, Alonzo Church define o cálculo lambda  \n Em julho de 1935, Kurt Gödel (e seu aluno Kleene) define funções recursivas  \n Em maio de 1936, Alan Turing define maquinas de Turing  \n \nAs três são equivalentes!  \n \n \n \n 2.5.  A matemática é inventada ou descoberta? \n \n ( WADLER, 2015 ) Quais partes dessa imagem um alienígena tem mais chances de entender?  \n \n   \n \n\n Quais linguagens de programação eles teriam mais chances de entender?  \n \n \n \n 2.6.  A matemática é inventada ou descoberta? - Cont. \n \n \nWadler faz uma ótima argumentação de que a matemática é descoberta, o que ressoa muito comigo pessoalmente.  \n Se Church, Gödel e Turing tivessem inventado (e não descoberto) essas definições, quais as chances delas acabarem sendo equivalentes?  \n \nVamos ver mais um argumento de Wadler a favor dessa perspectiva: o Isomorfismo de Curry-Howard.  \n \n \n \n 2.7.  Isomorfismo de Curry-Howard \n \n Proposições como tipos  \n Provas como programas  \n Simplificação de provas como avaliação de programas  \n   Lógica \n Tipos \n Falso \n Void \n Verdadeiro \n () \n \\(a \\lor b\\) \n Either a b \n \\(a \\land b\\) \n (a,b) \n \\(a \\implies b\\) \n a -> b \n \nExemplo: implicação e abstração + aplicação  \n   Lógica \n Tipos \n \\({\\displaystyle {\\frac {}{\\Gamma _{1},\\alpha ,\\Gamma _{2}\\vdash \\alpha }}{\\text{Ax}}} \\rule{0pt}{4ex}\\) \n \\({\\displaystyle {\\frac {}{\\Gamma _{1},x:\\alpha ,\\Gamma _{2}\\vdash x:\\alpha }}}\\) \n \\({\\displaystyle {\\frac {\\Gamma ,\\alpha \\vdash \\beta }{\\Gamma \\vdash \\alpha \\rightarrow \\beta }}\\rightarrow I} \\rule{0pt}{8ex}\\) \n \\({\\displaystyle {\\frac {\\Gamma ,x:\\alpha \\vdash t:\\beta }{\\Gamma \\vdash \\lambda x.t:\\alpha \\rightarrow \\beta }}}\\) \n \\({\\displaystyle {\\frac {\\Gamma \\vdash \\alpha \\rightarrow \\beta \\qquad \\Gamma \\vdash \\alpha }{\\Gamma \\vdash \\beta }}\\rightarrow E} \\rule{0pt}{8ex}\\) \n \\({\\displaystyle {\\frac {\\Gamma \\vdash t:\\alpha \\rightarrow \\beta \\qquad \\Gamma \\vdash u:\\alpha }{\\Gamma \\vdash t\\;u:\\beta }}}\\) \n \n \n \n 2.8.  Interpretação algébrica para tipos \n \n A teoria das categorias define um nível ainda mais alto de abstração para enxergar algumas coisas. Um dos exemplos mais simples de uma categoria é a categoria dos conjuntos (e das funções entre eles) ( DE FRANÇA, 2019 ).  \n As chamadas categorias cartesianas fechadas podem ser relacionadas a nossa álgebra de ensino médio  A categoria dos tipos é uma delas!  \n \n    Lógica \n Tipos \n Álgebra \n Falso \n Void \n \\(0\\) \n Verdadeiro \n () \n \\(1\\) \n \\(a \\lor b\\) \n Either a b \n \\(a + b\\) \n \\(a \\land b\\) \n (a,b) \n \\(a * b\\) \n \\(a \\implies b\\) \n a -> b \n \\(b^a\\) \n \n \n \n 2.9.  Exponenciação como tipos de funções I \n \n \nVamos escrever tipos função ( a -> b ) como operações de exponenciação da álgebra:  \n \n\\(a^0 = 1\\) tem assinatura  Void -> a . Apenas uma função tem essa assinatura (em Haskell,  absurd )  \n \n\\(a^1 = a\\) tem assinatura  () -> a . O número de funções com esse tipo é o mesmo número de valores do tipo  a .  \n Por exemplo, pra  a  sendo  bool , temos  f x = false  e  f x = true  \n Qualquer outra versão de  f x  pra esse tipo será equivalente a uma dessas duas  \n \n \n\\(1^a = 1\\) tem assinatura  a -> () . Apenas uma função tem essa assinatura ( f x = () )  \n \n\\(a^{b+c}\\) tem assinatura  Either b c -> a  \n Para definir uma função desse tipo, temos que definir os casos  Left  com tipo  b -> a  e  Right  com tipo  c -> a  \n Ou seja, \\(a^{b + c} = a^b * a^c\\)  \n \n \n\\((a^b)^c\\) tem assinatura  c -> (b -> a)  \n Lembrando de currying, sabemos que isso é equivalente a  (c,b) -> a .  \n Ou seja, \\((a^b)^c = a^{(b*c)}\\)  \n \n \\((a*b)^c\\) tem assinatura  c -> (a, b)  Equivalente a um par de funções  c -> a  e  c -> b  \n Ou seja, \\((a*b)^c = a^c * b^c\\)  \n \n \n \n \n 2.10.  Sistemas de tipos \n \n Com tudo o que vimos até aqui, é seguro afirmar que istemas de tipos são uma parte da ciência da computação que tem uma grande intersecção com a matemática  \n Sistemas de tipos também são métodos formais: Definimos uma especificação (assinaturas de tipos) e o type checker é nosso sistema de verificação.  \n Estudar matemática avançada pode dar base para usos cada vez mais avançados de sistemas de tipos  Tipos dependentes  \n HoTT (Homotopy Type Theory)  \n \n \n \n \n 2.11.  Tipos dependentes \n \n \nTipos dependentes: quando o tipo depende do valor. No exemplo a seguir, usamos o sistema de tipos para provar que a função  map  não altera o tamanho de um vetor. Isso não é possível sem tipos dependentes.  \n \n map : {A B : Set} {n : Nat} -> (A -> B) -> Vec A n -> Vec B n\nmap f [] = []\nmap f (x :: xs) = f x :: map f xs\n \n \n\n \nTipos dependentes são uma parte importante de muitos assistentes de provas (como Coq e Agda). Bem provável que vamos ver mais sobre eles durante os seminários da disciplina.  \n \n \n \n 2.12.  Funções parciais \n \n \nAgora, um caso mais tangível para voltarmos um pouco para a nossa realidade.  \n \nNa matemática, funções podem ser totais ou parciais  \n Para transformar funções parciais em totais, adicionamos o valor bottom (\\(\\bot\\)) ao co-domínio e mapeamos todos os valores anteriormente indefinidos ao bottom.  \n \n Na computação, funções parciais precisam retornar o tipo soma. Dependendo da linguagem, pode ser algo como:  f(x: int): int | undefined  \n int -> Maybe int  \n \n \n \n \n \n 3.  Diferenças importantes \n \n \n \n 3.1.  Erros vs indefinições \n \n Na matemática, algumas fórmulas são indefinidas.  Divisão não está definida para denominador \\(0\\)  \n Exponenciação não está definida para \\(0^0\\)  \n \n Na programação, precisamos  definir  o que acontece nesses cenários  Normalmente, o que queremos é reportar algum tipo de erro  \n Programação envolve humanos. Humanos erram e precisam entender aonde erraram.  “Opa, você tentou dividir por 0 na linha X coluna Y” - pode salvar alguém de horas de debugging  \n \n \n \n \n \n 3.2.  Funções vs Maps \n \n \nFunções matemáticas podem ser programadas através de funções ou  Maps  ( KONNOV, 2024 ). Pense nos exemplos  \n Função de um número para seu dobro.  \n Função do nome da pessoa para sua idade.  \n \nNa programação, vamos considerar os fatores  \n Uso de Memória  \n Velocidade de resposta  \n \nNuma especificação formal, memória e velocidade não importam da mesma forma  \n \n \n \n 3.3.  Implementação vs definição \n \n \nImagine a seguinte definição:  \n Dada uma função que ordena uma lista de inteiros  \n \nO que você pensou sobre essa função?  \n \nBem possível que pensou em um ou mais algoritmos de ordenação (i.e. bubble sort, selection sort, quick sort)  \n \nNa matemática, não importa  como  a ordenação é feita. A função em questão poderia ser descrita mais precisamente por:  \n Seja \\(f: \\overline{\\mathbb{Z}} \\rightarrow \\overline{\\mathbb{Z}}\\) tal que \\(f(x)_i \\leq f(x)_{i+1}\\) para todo \\(i \\in [0, |x|-1)\\)  \n \nNuma especificação formal, se não há relevância no algoritmo de ordenação (contanto que ele, de fato, ordene), podemos economizar recursos na verificação ao especificar somente a propriedade de ordenação.  \n \n \n \n 3.4.  Em resumo \n \n Matemática e programação estão muito interligados  \n Contudo, há diferenças nos níveis de abstração entre o que costumamos descrever em definições matemáticas e em programas.  Em programas, nos importamos com memória e velocidade, o que normalmente não é representado na matemática.  \n Em programas, precisamos detalhar  como  cada função é implementada, enquanto na matemática podemos somente definir funções pelas suas propriedades.  Inclusive, precisamos detalhar o que acontece em casos indefinidos pela matemática, como divisão por 0.  \n \n \n \n \n \n 3.5.  Referências \n \n \n    DE FRANÇA, F. O.  Tipo função . Disponível em: < https://haskell.pesquisa.ufabc.edu.br/teoria-das-categorias/09-tipofuncao/ >.  \n    KONNOV, I.  You should not care about memory in protocol specifications . Disponível em: < https://konnov.github.io/protocols-made-fun/quint/2024/01/14/maps.html >.  \n    WADLER, P.  Propositions as types .  Commun. acm , v. 58, n. 12, p. 75–84, Nov. 2015.  \n \n \n \n \n\n             \n         \n    ","url":"20240213151141-mfo_programacao_e_matematica_nao_sao_a_mesma_coisa.html"},{"title":"Apresentação","content":"\n         \n             \n     \n         \n               Gabriela Moreira \n         \n     \n     \n          \n         MFO \n         Métodos Formais \n         Materiais da disciplina \n     \n     \n     \n        Created using Emacs and\n         org-mode .  \n        Style from\n         The Monospace Web .\n     \n \n\n \n\n             \n                \n                 Apresentação \n                  Slides \n \n Table of Contents \n \n 1. Contexto \n 1.1. Sobre Métodos Formais \n 1.1.1. Essência \n 1.1.2. Histórico da disciplina \n \n 1.2. Sobre Mim \n 1.2.1. Sobre Mim \n 1.2.2. Meu envolvimento com Métodos Formais \n \n \n 2. Plano de Ensino \n \n 2.0.1. Vamos aprender TLA+ e Quint? \n 2.0.2. Vamos aprender TLA+ e Quint? - Continuação \n \n 2.1. Conteúdo \n 2.1.1. Plano de ensino \n 2.1.2. Conteúdo programático \n 2.1.3. Metodologia \n \n 2.2. Sistema de avaliação \n 2.2.1. Do desempenho do aluno \n 2.2.2. OFF: guia para navegar as avaliações \n 2.2.3. Exame \n 2.2.4. Do desempenho da disciplina e da professora \n \n 2.3. Bibliografia \n 2.3.1. Bibliografia básica \n 2.3.2. Bibliografia complementar \n \n \n 3. Recursos \n \n 3.0.1. Recursos \n \n \n \n \n \n 1.  Contexto \n \n \n \n 1.1.  Sobre Métodos Formais \n \n \n \n 1.1.1.  Essência \n \n \nMétodos formais são técnicas, embasadas na matemática, que visam verificar que algum hardware/software faz o que se propõe.  \n\n \nAs técnicas incluem dois componentes:  \n Uma linguagem de especificação  \n Um sistema de verificação  \n \n \n \n 1.1.2.  Histórico da disciplina \n \n Lá por 2015~2017, ensinava-se uma linguagem chamada Z  \n Em ~2018, ensinava-se Redes de Petri  \n Em 2019, o prof Cristiano assumiu a disciplina ensinando Coq  \n Em 2024/1, eu assumi a disciplina ensinando TLA+ (Temporal Logic of Actions+) e Quint  \n \n \n \n \n 1.2.  Sobre Mim \n \n \n \n 1.2.1.  Sobre Mim \n \n \nAcademia:  \n Ciência da Computação - UDESC - 2015-2019  TCC : Tradução automática de especificação formal modelada em TLA+ para linguagem de programação  \n \n Computação Aplicada - UDESC - 2020-2022  Dissertação : Test Generation From TLA+ Specifications  \n \n \nIndústria:  \n Magrathea Labs (agora Trusted Health) - 2018-2021  Estágio (5 meses) + Engenheira de Software  \n \n Informal Systems - 2021-presente  Engenheira de Pesquisa  \n \n \n \n \n 1.2.2.  Meu envolvimento com Métodos Formais \n \n Aprendi TLA+ na graduação para fazer meu TCC, e continuei estudando TLA+ no mestrado  \n \nEntrei na Informal Systems devido à pesquisa ativa (minha e deles) em TLA+  \n Muitos engenheiros com dificuldade em aprender e usar TLA+  \n \nTinham a proposta de uma nova syntaxe para TLA+, que chamamos hoje de  Quint  \n Sou a principal desenvolvedora dessa linguagem desde o início de 2022  \n \n \n \n \n \n \n \n 2.  Plano de Ensino \n \n \n \n 2.0.1.  Vamos aprender TLA+ e Quint? \n \n \nSim, mas vocês vão escolher em qual das duas fazer o primeiro trabalho  \n Na prova, sempre que houver exemplo de código, haverá versões nas duas linguagens  \n \nOs exemplos em aula poderão ser em qualquer uma das linguagens.  \n\n \nMinha expectativa é que vocês consigam entender especificações em ambas as linguagens, já que toda a base lógica para elas é a mesma - e a base lógica é a parte mais importante da disciplina.  \n \n \n \n 2.0.2.  Vamos aprender TLA+ e Quint? - Continuação \n \n \nTLA+ é uma linguagem de especificação bem estabelecida, e será nossa principal fundamentação teórica da disciplina  \n Alguns assuntos mais avançados vamos abordar somente em TLA+  \n \nQuint é opcional, vocês podem escolher fazer tudo em TLA+ se quiserem.  \n A linguagem e o ferramental de Quint pode facilitar bastante a vida de vocês.  \n O trabalho final será em Quint, mas vocês vão receber a especificação pronta.  Será necessário rodar comandos no terminal, então todos terão que instalar o Quint.  \n \n Vamos conversar mais sobre isso no decorrer das aulas.  \n \n \n \n 2.1.  Conteúdo \n \n \n \n 2.1.1.  Plano de ensino \n \n \nDisponível no SIGA (assim que for aprovado). Vamos ver juntos agora.  \n \n  Objetivo Geral  \n \nDesenvolver habilidades para reconhecimento de cenários, em sistemas computacionais, onde o uso de métodos formais é apropriado; e para aplicação de métodos formais.  \n \n \n  Objetivo Específico  \n Estimular o  senso de necessidade  de técnicas que auxiliem a garantir comportamentos em sistemas computacionais.  \n Desenvolver a  capacidade de abstração  ao descrever comportamentos de sistemas em linguagens de especificação formal.  \n Trabalhar técnicas de testes baseados em modelos para  conectar especificações com implementações .  \n \n \n \n \n 2.1.2.  Conteúdo programático \n \n Introdução: Programação e matemática não são a mesma coisa  \n Estruturas de Kripke  \n Lógica Temporal  \n Exemplo com semáforos  \n Motivação para o uso de métodos formais  \n Linguagens de especificação formal  \n Lógica Temporal de Ações: TLA+ e Quint  \n Exemplo com Jogo da Velha  \n Formulas temporais em TLA+ e Quint  \n Métodos formais no design de protocolos  \n Especificações para sistemas distribuídos  \n Exemplo sobre a efetivação em duas fases (two phase commit)  \n Verificação vs testes  \n Testes baseados em modelos  \n Outros métodos formais  \n Métodos formais no ciclo de desenvolvimento de software  \n Model checking  \n Refinamento  \n Model values e conjuntos de simetria  \n \n \n \n 2.1.3.  Metodologia \n \n \nA disciplina será desenvolvida através de aulas expositivo-dialogadas, com exercícios e trabalhos práticos, e seminários. O conteúdo da disciplina poderá ser ministrado na modalidade de ensino a distância em até 20% do total de sua Carga Horária (MEC PORTARIA No 4.059, DE 10 DE DEZEMBRO DE 2004 publicado no DOU de 13/12/2004, Seção 1, p. 34).  \n \n \n \n \n 2.2.  Sistema de avaliação \n \n \n \n 2.2.1.  Do desempenho do aluno \n \n \nA qualidade do desempenho do aluno será avaliada com base em:  \n Uma prova individual (P) - 30%  \n Dois trabalhos práticos (T1 e T2) - 25% cada  \n Um seminário (S) - 10%  \n Exercícios (E) - 10%  \n \nAssim, a Média Semestral (MS) será calculada pela fórmula  \n \nMS = (30 * P + 25 * T1 + 25 * T2 + 10 * S + 10 * E)/100  \n \n \n \n 2.2.2.  OFF: guia para navegar as avaliações \n \n O trabalho 1 é o mais trabalhoso e importante  \n O seminário é bem simples, mas não deixem de fazer porque depois a nota faz falta  É também mais no início do semestre onde vocês tem mais tempo livre  \n \n Os exercícios existem exclusivamente para prepará-los para o primeiro trabalho.  Eu não estava cobrando até semestre passado, mas decidi cobrar para incentivá-los a não chegarem despreparados para o trabalho.  \n \n O trabalho 2 é bem tranquilo. Pensem nele como um impulso extra para passar (e não como um motivo de desistir).  \n \n \n \n 2.2.3.  Exame \n \n \nCaso o discente não obtenha média MS igual ou superior a 7,0, um exame escrito será aplicado objetivando aferir o conhecimento teórico do estudante. Não há recuperação das provas por não comparecimento, exceto nos casos previstos no regulamento da UDESC na resolução 0392015 - CONSEPE.  \n \n \n \n 2.2.4.  Do desempenho da disciplina e da professora \n \n \nOs estudantes terão, igualmente, a oportunidade de fazer uma avaliação do desempenho da professora e da disciplina. As informações sobre esta atividade serão fornecidas pelo coordenador do curso.  \n \n \n \n \n 2.3.  Bibliografia \n \n \n \n 2.3.1.  Bibliografia básica \n \n \n  \n \n    BAIER, C.; KATOEN, J.-P.  Principles of model checking . Cambridge, MA: The MIT Press, 2008.  \n    LAMPORT, L.  Specifying systems: The tla+ language and tools for hardware and software engineers . Boston: Addison-Wesley, 2002.  \n    MONIN, J. F.; HINCHEY, M. G.  Understanding formal methods . Berlin, Heidelberg: Springer-Verlag, 2001.  \n \n \n \n \n 2.3.2.  Bibliografia complementar \n \n \n  \n \n    KONNOV, I.; KUKOVEC, J.  Tla+ language reference manual . Disponível em: < https://apalache.informal.systems/docs/lang/index.html#tla-language-reference-manual- >.  \n    LAMPORT, L.  A science of concurrent programs . 2024. Disponível em: < https://lamport.azurewebsites.net/tla/science.pdf >.  \n    TEAM, T. Q.  Quint . Disponível em: < https://quint-lang.org >.  \n \n \n \n \n \n \n 3.  Recursos \n \n \n \n 3.0.1.  Recursos \n \n Aulas em HTML no meu site:  bugarela.com/mfo  Todo o conteúdo dos slides  \n \n Toda a bibliografia tem disponível online gratuitamente  \n Páginas web relevantes  TLA+:  https://lamport.azurewebsites.net/tla/tla.html  \n Quint:  https://quint-lang.org  \n \n \n \n \n\n             \n         \n    ","url":"20240210123703-mfo_apresentacao.html"}]